

=== FILE START: src/app/layout.js ===

import { Geist, Geist_Mono } from 'next/font/google';
import './globals.css';

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
});

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
});

export const metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable}`}>{children}</body>
    </html>
  );
}


=== FILE END: src/app/layout.js ===



=== FILE START: src/app/contact/page.js ===



=== FILE END: src/app/contact/page.js ===



=== FILE START: src/app/page.js ===

import Image from 'next/image';
import styles from './page.module.css';

export default function Home() {
  return (
    <div className={styles.page}>
      <main className={styles.main}>
        <Image className={styles.logo} src="/next.svg" alt="Next.js logo" width={180} height={38} priority />
        <ol>
          <li>
            Get started by editing <code>src/app/page.js</code>.
          </li>
          <li>Save and see your changes instantly.</li>
        </ol>

        <div className={styles.ctas}>
          <a
            className={styles.primary}
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image className={styles.logo} src="/vercel.svg" alt="Vercel logomark" width={20} height={20} />
            Deploy now
          </a>
          <a
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
            className={styles.secondary}
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className={styles.footer}>
        <a
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image aria-hidden src="/file.svg" alt="File icon" width={16} height={16} />
          Learn
        </a>
        <a
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image aria-hidden src="/window.svg" alt="Window icon" width={16} height={16} />
          Examples
        </a>
        <a
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image aria-hidden src="/globe.svg" alt="Globe icon" width={16} height={16} />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}


=== FILE END: src/app/page.js ===



=== FILE START: src/app/playground/page.js ===

"use client";

import Page from "@/lib/page/pagemain";
import Intro from "./intro";

class PlaygroundPage extends Page {
  constructor(main) {
    super(main);
  }

  async create(content, main, temp = undefined) {
    super.create(content, main);

    if (temp !== undefined) {
      document.querySelector("#content").insertAdjacentHTML("afterbegin", temp);
    } else {
      const data = await fetch(`${main.base}/wp-json/wp/v2/pages/${content.dataset.id}`)
        .then(res => res.json());
      document.querySelector("#content").insertAdjacentHTML("afterbegin", data.csskfields.main);
    }

    this.el = document.querySelector("main");

    this.DOM = { el: this.el };

    if (this.main.webgl === 0 || this.main.device > 0) {
      document.documentElement.classList.add("NOGL");
      await this.loadImages();
      await this.loadVideos();
    }

    await this.createComps();
    await this.createIos();
    await this.getReady();
  }
}

export default PlaygroundPage;

=== FILE END: src/app/playground/page.js ===



=== FILE START: src/app/projects/page.js ===

"use client";

import Page from "@/lib/page/pagemain";
import Intro from "./intro";

class ProjectsPage extends Page {
  constructor(main) {
    super(main);
  }

  async create(content, main, temp = undefined) {
    super.create(content, main);

    if (temp !== undefined) {
      document.querySelector("#content").insertAdjacentHTML("afterbegin", temp);
    } else {
      const data = await fetch(`${main.base}/wp-json/wp/v2/pages/${content.dataset.id}`)
        .then(res => res.json());
      document.querySelector("#content").insertAdjacentHTML("afterbegin", data.csskfields.main);
    }

    this.el = document.querySelector("main");

    this.DOM = { el: this.el };

    if (this.main.webgl === 0) {
      await this.loadImages();
      await this.loadVideos();
    }

    await this.createComps();
    await this.createIos();
    await this.getReady();
  }

  async createComps() {
    await super.createComps();

    if (this.DOM.el.querySelector(".projects_intro")) {
      this.components.intro = new Intro(this.DOM.el.querySelector(".projects_intro"), this.main.device);
    }
  }
}

export default ProjectsPage;

=== FILE END: src/app/projects/page.js ===



=== FILE START: src/app/projects/intro.js ===

"use client";

import { useEffect, useRef } from "react";
import gsap from "gsap";

export default function ProjectsIntro({ el, device }) {
  const elementRef = useRef(null);

  useEffect(() => {
    if (!elementRef.current) return;
    gsap.to(elementRef.current, { opacity: 1, duration: 1 });
  }, []);

  return <div ref={elementRef} className="projects-intro"></div>;
}

=== FILE END: src/app/projects/intro.js ===



=== FILE START: src/app/projects/[slug]/page.js ===



=== FILE END: src/app/projects/[slug]/page.js ===



=== FILE START: src/app/about/io.js ===

"use client";

import { useEffect, useRef } from "react";
import gsap from "gsap";
import SplitType from "split-type";

export default function AboutAnimation({ el, device, touch }) {
  const elementRef = useRef(null);
  const animationRef = useRef(null);

  useEffect(() => {
    if (!elementRef.current) return;

    const anim = gsap.timeline({ paused: true });
    const splitText = new SplitType(elementRef.current.querySelectorAll("p"), { types: "lines" });

    splitText.lines.forEach((line, i) => {
      anim.fromTo(line, { y: "1.2rem", opacity: 0 }, { y: "0rem", opacity: 1, duration: 0.3 }, i * 0.2);
    });

    animationRef.current = anim;
  }, []);

  return <div ref={elementRef} className="about-animation"></div>;
}

=== FILE END: src/app/about/io.js ===



=== FILE START: src/app/about/page.js ===

"use client";

import Page from '@/lib/page/pagemain'; // Correct path to pagemain.js
import Intro from './intro'; // Correct path to intro.js
import Scr from './io'; // Correct path to io.js

class AboutPage extends Page {
  constructor(main) {
    super(main);
  }

  async create(content, main, temp = undefined) {
    super.create(content, main);
    
    if (temp !== undefined) {
      document.querySelector("#content").insertAdjacentHTML("afterbegin", temp);
    } else {
      const data = await fetch(`${main.base}/wp-json/wp/v2/pages/${content.dataset.id}`)
        .then(res => res.json());
      document.querySelector("#content").insertAdjacentHTML("afterbegin", data.csskfields.main);
    }

    this.el = document.querySelector("main");

    this.DOM = {
      el: this.el,
    };

    if (this.main.webgl === 0) {
      await this.loadImages();
      await this.loadVideos();
    }

    await this.createComps();
    await this.createIos();
    await this.getReady();
  }

  iOpage(animobj) {
    if (animobj.el.classList.contains("iO-scr")) {
      animobj.class = new Scr(animobj, this.main.device, this.main.touch);
    }
    return animobj;
  }

  async createComps() {
    await super.createComps();
    if (this.DOM.el.querySelector(".about_intro")) {
      this.components.intro = new Intro(this.DOM.el.querySelector(".about_intro"), this.main.device);
    }
  }
}

export default AboutPage;

=== FILE END: src/app/about/page.js ===



=== FILE START: src/app/about/intro.js ===

"use client";

import { useEffect, useRef } from "react";
import gsap from "gsap";

export default function AboutIntro({ el, device }) {
  const elementRef = useRef(null);
  const animationRef = useRef(null);

  useEffect(() => {
    if (!elementRef.current) return;

    const anim = gsap.timeline({
      paused: true,
      onComplete: () => {
        elementRef.current.classList.add("act");
      },
    });

    animationRef.current = anim;
  }, []);

  return <div ref={elementRef} className="about-intro"></div>;
}

=== FILE END: src/app/about/intro.js ===



=== FILE START: src/app/page.module.css ===

.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}


=== FILE END: src/app/page.module.css ===



=== FILE START: src/app/project/io.js ===


//import SplitType from 'split-type'


export default class {
    constructor (obj,device,animev) {
  
      this.el = obj.el    
     
  
      this.pos = obj.pos
      this.device = device
      this.isupdate = 2
      this.animev = animev
  
  
      this.DOM = {
        el:obj.el,
        // in:document.querySelector('.backto'),
        scr:obj.el.parentNode.querySelector('.top_sc'),
        cnt:obj.el.parentNode.querySelector('.cnt'),
       
      }
  
  
      this.active = 0
      this.postit = 0
      this.isstarted = 0
      this.h = window.innerHeight
      
  
      this.ctr = {
        actual:0,
        current:0,
        limit:0,
        start:0,
        prog:0,
        progt:0,
        stop:0,
      }
  
      this.create()
  
    }
    
    async create(){
      let mult = 2.4
  
      this.animnolerp = gsap.timeline({paused:true,
        onComplete:()=>{
          this.active = -1
          this.anim.play()
  
          let div = document.createElement('div')
          div.classList.add('nxtPr')
  
          this.el.parentNode.classList.add('notrans')
  
          div.appendChild(this.el.parentNode.querySelector('.cnt_n').cloneNode(true))
          div.appendChild(this.el.parentNode.querySelector('.cnt_t').cloneNode(true))
  
          
  
          this.animev.detail.el = div
          this.animev.detail.url = this.el.dataset.url
          document.dispatchEvent(this.animev)
        }
      })
      .to(this.el,{opacity:0,duration:.5},0)
     
  
  
      this.anim = gsap.timeline({paused:true,
        onReverseComplete:()=>{
          this.ctr.progt = 0
          this.ctr.prog = 0
        },
        onComplete:()=>{
          // this.ctr.progt = 1
          // this.ctr.prog = 1
  
          // let div = document.createElement('div')
          // div.classList.add('nxtPr')
          // div.dataset.n = this.el.parentNode.querySelector('.cnt_n .tt3').innerHTML
          // div.dataset.t = this.el.parentNode.querySelector('.cnt_t .tt3').innerHTML
  
          // this.animev.detail.el = div
          // this.animev.detail.url = this.el.dataset.url
          // document.dispatchEvent(this.animev)
        }
      })
      .to(this.DOM.scr,{y:30+'vh',opacity:0,duration:.5*mult},0)
      .fromTo(this.DOM.cnt,{y:30+'vh',},{y:0+'vh',duration:.35*mult},.15*mult)
      // .fromTo(this.DOM.in,{y:-10+'vh',opacity:0},{y:0+'vh',opacity:1,duration:.1*mult,immediateRender:false},.25*mult)
      // this.DOM.tits[0].classList.add('act')
      
      // this.anim.paused()
      
    }
  
  
    check(entry,pos){
      if(this.active == -1){
        return false
      }
      let vis = false
      
        if(entry.isIntersecting!=null){
        if(entry.isIntersecting == true){
          vis = true
          this.start()
  
        }
        else{
          this.stop(entry)
        }
      }
      return vis
  
    }
    
    start(){
      if(this.active==1){
        return false
      }
      this.active = 1
    }
    
    stop(entry){
  
      if(this.active==0){
        return false
      }
      if(entry.boundingClientRect.y < 12){
        this.anim.play()
      }
      else{
        this.anim.reverse()
      }
      this.active = 0
  
      
  
    }
  
    initEvents(){
     
  
    }
    removeEvents(){
     
  
    }
  
    update(speed,pos = 0){
      if(this.active != 1){
        return false
      }
      this.ctr.current = this.ctr.start - pos
      
      this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current)
      
  
      this.ctr.progt = (1 - (this.ctr.current  / this.ctr.limit))
      this.ctr.prog = window.lerp(this.ctr.prog , this.ctr.progt , .015)    
      this.anim.progress(this.ctr.prog.toFixed(4))
      this.animnolerp.progress(this.ctr.progt)
  
        
  
    }
  
    onResize(pos){
      this.h = window.innerHeight
      let bound = this.DOM.el.getBoundingClientRect()
      this.ctr.start =  parseInt((bound.y + window.scrollY))
      this.ctr.limit = this.h
  
  
     
    }
    
    
  }
  

=== FILE END: src/app/project/io.js ===



=== FILE START: src/app/project/page.js ===

"use client";

import Page from "@/lib/page/pagemain";
import Intro from "./intro";
import In from "./ioin";
import Nxt from "./io";

class ProjectPage extends Page {
  constructor(main) {
    super(main);
  }

  async create(content, main, temp = undefined) {
    super.create(content, main);

    if (temp !== undefined) {
      document.querySelector("#content").insertAdjacentHTML("afterbegin", temp);
    } else {
      const data = await fetch(`${main.base}/wp-json/wp/v2/project/${content.dataset.id}`)
        .then(res => res.json());
      document.querySelector("#content").insertAdjacentHTML("afterbegin", data.csskfields.main);
    }

    this.el = document.querySelector("main");

    this.DOM = { el: this.el };

    await this.loadImages();
    await this.loadVideos();
    await this.createComps();
    await this.createIos();
    await this.getReady();
  }
}

export default ProjectPage;

=== FILE END: src/app/project/page.js ===



=== FILE START: src/app/project/ioin.js ===


//import SplitType from 'split-type'


export default class {
    constructor (obj,device) {
  
      this.el = obj.el    
     
  
      this.pos = obj.pos
      this.device = device
      this.isupdate = 2
      
      this.DOM = {
        el:obj.el,
        scr:document.querySelector('.backto')
       
      }
  
  
      this.active = 0
      this.postit = 0
      this.isstarted = 0
      this.h = window.innerHeight
      
  
      this.ctr = {
        actual:0,
        current:0,
        limit:0,
        start:0,
        prog:0,
        progt:0,
        stop:0,
      }
  
      this.create()
  
    }
    
    async create(){
       
      this.anim = gsap.timeline({paused:true,
        onComplete:()=>{
        }
      })
      .to(this.DOM.scr,{y:5+'vh',opacity:0,duration:.4},0)
      // this.DOM.tits[0].classList.add('act')
      
      // this.anim.paused()
      
    }
  
  
    check(entry,pos){
      let vis = false
      
      if(entry.isIntersecting!=null){
        if(entry.isIntersecting == true){
          vis = true
          this.start()
  
        }
        else{
          this.stop(entry)
        }
      }
      return vis
  
    }
    
    start(){
      if(this.active==1){
        return false
      }
      this.active = 1
    }
    
    stop(entry){
      if(this.active==0){
        return false
      }
      if(entry.boundingClientRect.y < 12){
        this.anim.play()
      }
      else{
  
      }
      this.active = 0
  
     
  
    }
  
    initEvents(){
     
  
    }
    removeEvents(){
     
  
    }
  
    update(speed,pos = 0){
        this.ctr.current = pos
        
        this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current)
        
  
        this.ctr.progt = ((this.ctr.current  / this.ctr.limit))
        this.ctr.prog = window.lerp(this.ctr.prog , this.ctr.progt , .1)    
        this.anim.progress(this.ctr.prog.toFixed(4))
  
        
  
    }
  
    onResize(pos){
      this.h = window.innerHeight
      let bound = this.DOM.el.getBoundingClientRect()
      this.ctr.start = 0
      this.ctr.limit = bound.height
  
  
     
    }
    
    
  }
  

=== FILE END: src/app/project/ioin.js ===



=== FILE START: src/app/project/intro.js ===


// import './index.scss'
//import SplitType from 'split-type'

export default class {
    constructor (el,device) {
  
  
      this.DOM = {
        el:el,
        num:el.querySelector('.cnt_n .tt3'),
        title:el.querySelector('.cnt_t .tt3')
      }
      this.device = device
      this.active = 0
  
      this.create()
      
    }
  
    async create(){
      
  
  
    
    }
    
    async start(){
      this.DOM.num.classList.add('stview','inview')
      this.DOM.title.classList.add('stview','inview')
      await window.waiter(600)
    
    }
    set(){
      this.DOM.num.classList.add('notran')
      this.DOM.title.classList.add('notran')
      this.DOM.num.classList.add('stview','inview')
      this.DOM.title.classList.add('stview','inview')
      document.querySelector('.faketit').remove()
  
      setTimeout(()=>{
        this.DOM.num.classList.remove('notran')
        this.DOM.title.classList.remove('notran')
      },1000)
    
    }
    initEvents(){
  
    }
  
    removeEvents(){
      
    }
  
    onResize(){
    }
  }
  

=== FILE END: src/app/project/intro.js ===



=== FILE START: src/app/gl/gl.js ===

// import { Renderer } from 'ogl'

import { create, createScene, createCamera, cleanTemp, createTemp, createIos, show } from './create.js';

import { createEls, createMSDF, createTex, createAssets } from './els.js';

import { callIos, loadIos, showIos, checkIo } from './ios.js';

import { onResize, update, timeout, loadImage, loadVideo } from './events.js';

class Canvas {
  constructor(main) {
    this.main = main;

    this.viewport = {
      w: 1,
      h: 1,
    };

    this.isVisible = 0;

    this.ios = [];
    this.iosmap = new Map();
  }

  timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  async changeSlides(st = 0) {
    let foot = null;
    if (st == 1) {
      for (let [i, a] of this.iosmap.entries()) {
        if (a.name == 'Slides') {
          a.changeState(st);
        }
      }

      await window.waiter(1400);

      for (let [i, a] of this.iosmap.entries()) {
        if (a.name == 'Roll') {
          a.changeState(st);
        } else if (a.name == 'Footer') {
          foot = a;
        }
      }
    } else {
      for (let [i, a] of this.iosmap.entries()) {
        if (a.name == 'Roll') {
          a.changeState(st);
        }
      }

      for (let [i, a] of this.iosmap.entries()) {
        if (a.name == 'Slides') {
          a.changeState(st);
        } else if (a.name == 'Footer') {
          foot = a;
        }
      }
      await window.waiter(800);
    }

    if (foot) {
      foot.onResize(this.viewport, this.main.screen);
    }
  }
}

Canvas.prototype.create = create;
Canvas.prototype.createScene = createScene;
Canvas.prototype.createCamera = createCamera;
Canvas.prototype.cleanTemp = cleanTemp;
Canvas.prototype.createTemp = createTemp;
Canvas.prototype.createIos = createIos;
Canvas.prototype.show = show;

Canvas.prototype.createMSDF = createMSDF;
Canvas.prototype.createAssets = createAssets;
Canvas.prototype.createEls = createEls;
Canvas.prototype.createTex = createTex;

Canvas.prototype.callIos = callIos;
Canvas.prototype.loadIos = loadIos;
Canvas.prototype.showIos = showIos;
Canvas.prototype.checkIo = checkIo;

Canvas.prototype.onResize = onResize;
Canvas.prototype.update = update;
Canvas.prototype.timeout = timeout;
Canvas.prototype.loadImage = loadImage;
Canvas.prototype.loadVideo = loadVideo;

export default Canvas;


=== FILE END: src/app/gl/gl.js ===



=== FILE START: src/app/gl/events.js ===

export function onResize() {
  // if(! this.camera ){
  //   return false
  // }

  // this.aspect = this.main.screen.w/this.main.screen.h
  // this.renderer.setSize(this.main.screen.w, this.main.screen.h)

  // this.camera.perspective({
  //   aspect: this.gl.canvas.width / this.gl.canvas.height
  // })

  // const fov = this.camera.fov * (Math.PI / 180)
  // const height = 2 * Math.tan(fov / 2) * this.camera.position.z
  // const width = height * this.camera.aspect

  // this.viewport = {
  //   w:width,
  //   h:height
  // }

  // this.scale = this.main.screen.h / 1500
  for (let [i, a] of this.iosmap.entries()) {
    if (a.onResize) a.onResize(this.viewport, this.main.screen);
  }
  if (this.loader) {
    this.loader.onResize(this.viewport, this.main.screen);
  }
}

// export function update({speed,scroll,mouse,mousespeed}) {
export function update(time, wheel, pos) {
  if (this.loader) {
    if (this.loader.active != 0) {
      this.loader.update(time, wheel, pos);
    } else if (this.loader.active == 0) {
      this.loader.removeEvents();
      delete this.loader;
    }
  }
  if (this.isVisible == 0) {
    return false;
  }

  let renderme = 0;

  if (this.ios) {
    for (let [i, a] of this.iosmap.entries()) {
      if (a.active == 1) {
        a.update(time, wheel, pos);

        // if(!a.renderer){
        //   renderme = 1
        // }
      }
    }
  }
  // if(renderme == 1){
  //   this.renderer.render({
  //     scene: this.scene,
  //     camera: this.camera
  //   })
  // }
  // this.renderer.render({
  //   scene: this.scene,
  //   camera: this.camera
  // })

  // if(this.iosmap){
  //   if(this.iosmap.get(0)){
  //     this.iosmap.get(0).update(time,wheel,pos)
  //   }
  //   if(this.iosmap.get(1)){
  //     this.iosmap.get(1).update(time,wheel,pos)
  //   }
  // }
}

export function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export async function loadImage(url) {
  return new Promise((resolve, reject) => {
    let img = new Image();
    img.crossOrigin = '';

    // let gif=0
    // if(/\.(gif)$/.test(url)){
    //   gif=1
    // }

    img.onload = () => {
      resolve(img);
    };

    img.src = url;

    img.onerror = (e) => {
      resolve(img);
    };
  });
}

function cleanVid(elem) {
  elem.oncanplay = null;
  elem.onplay = null;
  elem.currentTime = 0;

  let isPlaying = elem.currentTime > 0 && !elem.paused && !elem.ended && elem.readyState > elem.HAVE_CURRENT_DATA;

  elem.pause();
}

export async function loadVideo(elem, url) {
  // Add preload="metadata" to video tag and then listen to loadedmetadata event. It works in IOS Safari as well

  return new Promise((resolve, reject) => {
    if (elem.dataset.loop) {
      elem.loop = false;
    } else {
      elem.loop = true;
    }
    elem.muted = true;
    elem.autoplay = true;
    elem.setAttribute('webkit-playsinline', 'webkit-playsinline');
    elem.setAttribute('playsinline', 'playsinline');
    elem.onplay = () => {
      elem.isPlaying = true;
    };

    elem.oncanplay = () => {
      if (elem.isPlaying) {
        elem.classList.add('Ldd');
        cleanVid(elem);
        resolve(elem);
      }
    };
    elem.src = url;

    elem.onerror = () => {
      resolve(elem);
    };

    elem.play();
  });
}


=== FILE END: src/app/gl/events.js ===



=== FILE START: src/app/gl/els.js ===

import { Camera, Plane, Triangle, Mesh, Geometry, Texture, Text, Renderer, Transform, Program, Post, Vec2 } from 'ogl';
//ASSETS
import imurl from './assets/ciclope.jpg?url';
import mapTexSrcD from './assets/PPNeueMontreal-Medium.png?url';
import jsonTexSrcD from './assets/PPNeueMontreal-Medium.json?url';

import vidurl from './assets/vid.mp4?url';
import vidsmall from './assets/vidsmall.mp4?url';
// import vidsmall from './assets/vid.mp4?url'

//LOADER

import Loader from './effects/loader/base.js';
import LoaderF from './loader/main.glsl';
import LoaderV from './loader/main.glsl';

//OIS

import Base from './ois/base.js';
import fractalF from './ois/main.glsl';
import fractalV from './ois/main.glsl';

import Bg from './bg/base.js';
import BgF from './bg/main.glsl';
import BgV from './bg/main.glsl';

import Tt from './tt/base.js';
import textF from './tt/msdf.glsl';
import textV from './tt/msdf.glsl';

import TtF from './ttf/base.js';
import textFF from './ttf/msdf.glsl';
// import textFV from './ttf/msdf.glsl'
import textpF from './ttf/parent.glsl';

import TtA from './tta/base.js';
import textFA from './tta/msdf.glsl';
// import textFV from './tta/msdf.glsl'
import textpA from './tta/parent.glsl';

import Sl from './sl/base.js';
import SlF from './sl/main.glsl';
import SlV from './sl/main.glsl';
// import textFV from './ttf/msdf.glsl'
import SlPF from './sl/parent.glsl';

import Roll from './effects/roll/base.js';
import SlSF from './roll/single.glsl';
import SlVF from './roll/single.glsl';

import PG from './pg/base.js';
import PGs from './pg/main.glsl';
import PGv from './pg/main.glsl';

// import textpV from './tt/parent.glsl'

export async function createMSDF() {
  let mapTexSrc = this.main.template + '/public/PPNeueMontreal-Medium.png';
  let jsonTexSrc = this.main.template + '/public/PPNeueMontreal-Medium.json';

  if (import.meta.env.DEV) {
    mapTexSrc = mapTexSrcD;
    jsonTexSrc = jsonTexSrcD;
  }

  let rt = [];

  //🔠🔠🔠🔠
  let fJson = await (await fetch(jsonTexSrc)).json();

  rt.push(fJson);

  //🔚🔚🔚🔚🔚

  return rt;
}

export async function createAssets(texs) {
  //💬💬💬💬💬💬
  const fntAss = await this.createMSDF();

  this.fontMSDF = fntAss[0];

  let mapTexSrc = this.main.template + '/public/PPNeueMontreal-Medium.png';

  if (import.meta.env.DEV) {
    mapTexSrc = mapTexSrcD;
  }
  this.fontTex = await this.loadImage(mapTexSrc);

  // const fakeImg = new Image()
  // fakeImg.crossOrigin = ''

  // this.imagefak = new Texture(this.gl, {
  //   generateMipmaps: false,
  //   image : fakeImg
  // })
  // fakeImg.onload = () => {
  //   this.imagefak.image = fakeImg
  // }

  // // fakeImg.src = imurl
  // fakeImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAABOCAYAAACOqiAdAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuSURBVHgB7dAxAcAgAASxb/17Bg3cnEjIt+2MZ/9IxEXiInGRuEhcJC4SF4mLxEXiInGRuEhcJC4SF4mLxEXiInGRuEhcJC4SF4mLxEXiInGRuEhcJC4SF4mLxEXiInGRuOgCb+wBm1B9GmcAAAAASUVORK5CYII='

  // await this.timeout(640)

  const video = document.createElement('video');
  video.isPlaying = false;
  video.style.display = 'none';
  video.autoplay = true;
  video.setAttribute('webkit-playsinline', 'webkit-playsinline');
  video.setAttribute('playsinline', 'playsinline');
  video.muted = true;
  video.loop = true;
  video.dataset.auto = true;

  let promiseswait = [];
  let lnt = Object.values(texs).length - 1;

  for (let a in texs) {
    if (Array.isArray(texs[a])) {
      for (let [b, u] of texs[a].entries()) {
        if (texs[a][b].i) {
          if (import.meta.env.DEV) {
            promiseswait.push(this.loadImage(imurl));
          } else {
            promiseswait.push(this.loadImage(texs[a][b].i));
          }
        } else if (texs[a][b].v) {
          let vidclone = video.cloneNode();
          if (import.meta.env.DEV) {
            promiseswait.push(this.loadVideo(vidclone, vidsmall));
          } else {
            promiseswait.push(this.loadVideo(vidclone, texs[a][b].v));
          }
        }
      }
    } else {
      if (texs[a].i) {
        if (import.meta.env.DEV) {
          promiseswait.push(this.loadImage(imurl));
        } else {
          promiseswait.push(this.loadImage(texs[a].i));
        }
      } else if (texs[a].v) {
        let vidclone = video.cloneNode();
        if (import.meta.env.DEV) {
          promiseswait.push(this.loadVideo(vidclone, vidsmall));
        } else {
          promiseswait.push(this.loadVideo(vidclone, texs[a].v));
        }
      }
    }
  }

  this.texs = [];
  for (let [i, a] of promiseswait.entries()) {
    this.texs.push(await Promise.resolve(a));
  }

  // await Promise.all(promiseswait).then((data)=>{

  //   this.texs = data

  // })
}

export async function createTex(el = null, video = null) {}

export async function createEls(el = null) {
  const temp = el.dataset.temp || 'base';
  const pos = el.dataset.oi;

  //💬💬💬💬💬💬
  if (temp == 'tt' || temp == 'foot' || temp == 'about') {
    //🅰️🅰️🅰️🅰️
    //❗ AN IF STATEMENT WILL NEED TO BE MADE FOR THE SIZES
    //❗ A SIZE CALCULATOR WILL NEED TO BE MADE

    // const renderer = new Renderer({
    //   alpha: true,
    //   dpr: Math.max(window.devicePixelRatio, 2),

    //   width: el.offsetWidth,
    //   height: el.offsetHeight,
    // })
    const renderer = new Renderer({
      alpha: true,
      dpr: Math.max(window.devicePixelRatio, 2),

      width: el.offsetWidth,
      height: el.offsetHeight,
    });

    const { gl } = renderer;

    gl.canvas.classList.add('glF');
    el.parentNode.querySelector('.cCover').appendChild(gl.canvas);
    //📽️📽️📽️📽️📽️📽️📽️📽️
    const cam = this.createCamera(gl);

    let text = '';
    let siz = el.dataset.m;

    if (temp == 'foot') {
      text = new Text({
        font: this.fontMSDF,
        text: el.dataset.text,
        // text:'a',
        // width: el.dataset.w,
        align: 'center',
        letterSpacing: el.dataset.l,
        size: siz,
        lineHeight: 1,
      });
    } else if (temp == 'about') {
      let br = ' ';
      let br2 = ' ';
      let w = (6.2 * el.dataset.m) / 0.6;
      let ls = el.dataset.l;
      let l = 0.995;
      if (this.main.device < 2) {
        br = '\n';
        br2 = '\n';
        w = 13.1;
        l = 1.035;
      }
      if (this.main.device == 2) {
        // br2 ='\n'
        w = 7.5;
        l = 1.01;
        ls = -0.015;
        siz *= 0.77;
      }
      // el.dataset.l = -.01
      text = new Text({
        font: this.fontMSDF,
        text:
          'Enthusiastic about graphic design, typography, and the dynamic areas of motion and web-based animations.' +
          br +
          'Specialized in translating brands into unique and immersive digital' +
          br2 +
          'user experiences.',

        width: w,
        align: 'center',
        letterSpacing: ls,
        size: siz,
        lineHeight: l,
      });
    } else {
      text = new Text({
        font: this.fontMSDF,
        text: el.dataset.text,
        // text:'a',
        // letterSpacing: el.dataset.l,
        // width: el.dataset.w,
        align: 'center',
        letterSpacing: el.dataset.l,
        size: siz,
        lineHeight: 1,
      });
    }

    // gl.clearColor(0, 0, 0, 0)

    //📐📐📐📐📐📐📐

    const geometry = new Geometry(gl, {
      position: { size: 3, data: text.buffers.position },
      uv: { size: 2, data: text.buffers.uv },
      // id provides a per-character index, for effects that may require it
      id: { size: 1, data: text.buffers.id },
      index: { data: text.buffers.index },
    });
    geometry.computeBoundingBox();
    // const geometry = new Triangle(gl)

    //📺📺📺📺📺📺📺
    const texTx = new Texture(gl, {
      generateMipmaps: false,
    });

    texTx.image = this.fontTex;

    // const program = new Program(gl,this.programops.text)

    let program = '';

    if (temp == 'foot') {
      let shaderMod = textFF;
      shaderMod = shaderMod.replaceAll('PITO', el.parentNode.querySelector('.Oiel').innerHTML.length);

      program = new Program(gl, {
        vertex: textV,
        fragment: shaderMod,
        uniforms: {
          uTime: { value: 0 },
          uColor: { value: 0 },
          tMap: { value: texTx },
        },
        transparent: true,
        cullFace: null,
        depthWrite: false,
      });
    } else if (temp == 'about') {
      let shaderMod = textFA;
      shaderMod = shaderMod.replaceAll('PITO', el.parentNode.querySelector('.Oiel').innerHTML.length);

      program = new Program(gl, {
        vertex: textV,
        fragment: shaderMod,
        uniforms: {
          uTime: { value: 0 },
          uStart: { value: 1 },
          uColor: { value: 0 },
          tMap: { value: texTx },
        },
        transparent: true,
        cullFace: null,
        depthWrite: false,
      });
    } else {
      let shaderMod = textF;
      shaderMod = shaderMod.replaceAll('PITO', el.parentNode.querySelector('.Oiel').innerHTML.length);

      program = new Program(gl, {
        vertex: textV,
        fragment: shaderMod,
        uniforms: {
          uTime: { value: 0 },
          uKey: { value: -2 },
          uPower: { value: 1 },
          uPowers: { value: [] },
          uWidth: { value: [] },
          uHeight: { value: [] },
          uCols: { value: 1.5 },
          uStart: { value: 1 },
          uColor: { value: 0 },
          tMap: { value: texTx },
          uMouse: { value: new Vec2(0, 0) },
        },
        transparent: true,
        cullFace: null,
        depthWrite: false,
      });
    }
    // console.log(program)
    // 🟥🟥🟥🟥🟥🟥

    const mesh = new Mesh(gl, { geometry, program });

    const scene = new Transform();
    mesh.setParent(scene);

    //❗ Possible deletion or adjustment to place it in the middle
    // mesh.position.x =  text.width * -0.5
    // mesh.position.y = text.height * 0.5
    let post = '';
    if (temp == 'foot') {
      // console.log(mesh.position.y)

      // console.log(mesh.position.y)
      // console.log(program)
      mesh.position.y = text.height * 0.58;

      post = new Post(gl);
      post.addPass({
        // If not passed in, pass will use the default vertex/fragment
        // shaders found within the class.
        fragment: textpF,
        uniforms: {
          uTime: { value: 0 },
          uStart: { value: 0 },
          uMouseT: { value: 0 },
          uMouse: { value: 0 },
          uOut: { value: 1 },
        },
      });
    } else if (temp == 'about') {
      // console.log(mesh.position.y)

      // console.log(mesh.position.y)
      // console.log(program)
      mesh.position.y = text.height * 0.58;

      post = new Post(gl);
      post.addPass({
        // If not passed in, pass will use the default vertex/fragment
        // shaders found within the class.
        fragment: textpA,
        uniforms: {
          uTime: { value: 0.4 },
          uStart: { value: -1 },
          uMouseT: { value: 0.4 },
          uMouse: { value: -1 },
        },
      });
    } else {
      mesh.position.y = text.height * 0.58;
    }
    if (el.dataset.white) {
      program.uniforms.uColor.value = 1;
    }

    const obj = {
      el,
      pos,
      renderer,
      mesh,
      text,
      post,
      scene,
      cam,
      touch: this.main.isTouch,
      canvas: gl.canvas,
    };

    if (temp == 'foot') {
      return new TtF(obj);
    } else if (temp == 'about') {
      return new TtA(obj);
    } else {
      return new Tt(obj);
    }
  } else if (temp == 'bg' || temp == 'loader') {
    //⌛️⌛️⌛️⌛️⌛️⌛️⌛️⌛️⌛️⌛️⌛️

    const renderer = new Renderer({
      alpha: true,
      dpr: Math.min(window.devicePixelRatio, 2),
      width: window.innerWidth,
      height: window.innerHeight,
    });

    const { gl } = renderer;
    const geometry = new Triangle(gl);

    if (temp == 'loader') {
      gl.canvas.id = 'glLoader';

      document.body.appendChild(gl.canvas);

      const program = new Program(gl, {
        vertex: LoaderV,
        fragment: LoaderF,
        uniforms: {
          uTime: { value: 0 },
          //DELETE
          uStart1: { value: 0.5 },
          //DELETE
          uStart0: { value: 1 },
          uStart2: { value: 1 },
          uStartX: { value: 0 },
          uStartY: { value: 0.1 },
          uMultiX: { value: -0.4 },
          uMultiY: { value: 0.45 },
          uResolution: { value: new Vec2(gl.canvas.offsetWidth, gl.canvas.offsetHeight) },
        },
      });

      const mesh = new Mesh(gl, { geometry, program: program });

      const obj = {
        el,
        pos,
        renderer,
        mesh,
        canvas: gl.canvas,
      };

      return new Loader(obj);
    } else {
      gl.canvas.id = 'glBg';
      document.body.insertBefore(gl.canvas, document.querySelector('.Mbg'));

      const program = new Program(gl, {
        vertex: BgV,
        fragment: BgF,
        uniforms: {
          uTime: { value: 0 },
          //DELETE
          uStart1: { value: 0.5 },
          //DELETE
          uStart0: { value: 1 },
          uStart2: { value: 1 },
          uStartX: { value: 0 },
          uStartY: { value: 0.1 },
          uMultiX: { value: -0.4 },
          uMultiY: { value: 0.45 },
          uResolution: { value: new Vec2(gl.canvas.offsetWidth, gl.canvas.offsetHeight) },
        },
      });

      const mesh = new Mesh(gl, { geometry, program: program });

      const obj = {
        el,
        pos,
        renderer,
        mesh,
        canvas: gl.canvas,
      };

      return new Bg(obj);
    }
  } else if (temp == 'roll') {
    const parent = document.querySelector('.cRoll');
    const renderer = new Renderer({
      alpha: true,
      dpr: Math.max(window.devicePixelRatio, 2),

      width: parent.offsetWidth,
      height: parent.offsetHeight,
    });
    const { gl } = renderer;
    //Slider
    const scene = new Transform();

    gl.canvas.classList.add('glRoll');
    parent.appendChild(gl.canvas);

    //📐📐📐📐📐📐📐

    const geometry = new Triangle(gl);

    const textures = [];
    let medias = parent.parentNode.querySelectorAll('video,img');

    for (let [i, a] of medias.entries()) {
      let texture = new Texture(gl, {
        generateMipmaps: false,
      });

      let url = a.dataset.src || a.dataset.oi;
      let exists = this.texs.find((element) => element.src == url);

      if (import.meta.env.DEV) {
        if (url.includes('.mp4')) {
          exists = this.texs[0];
        } else {
          exists = this.texs[2];
        }
      }

      if (url.includes('.mp4')) {
        if (exists) {
          texture.image = exists;
        } else {
          console.log('no fun');
          texture.image = await this.loadVideo(a, url);
        }
      } else {
        if (exists) {
          texture.image = exists;
        } else {
          console.log('no fun');
          texture.image = await this.loadImage(url);
        }
      }
      // if(i == 0){
      //   texturesingle.image = texture.image
      // }

      textures.push(texture);
    }

    const program = new Program(gl, {
      vertex: SlVF,
      fragment: SlSF,
      uniforms: {
        uStart: { value: 0 },
        uEnd: { value: 0 },
        uPos: { value: 0 },
        uChange: { value: 0 },
        tMap: { value: textures[0] },
        tMap2: { value: textures[0] },
        uCover: { value: new Vec2(0, 0) },
        uTextureSize: { value: new Vec2(0, 0) },
        uTextureSize2: { value: new Vec2(0, 0) },
      },
    });
    let mesh = new Mesh(gl, { geometry, program });

    const obj = {
      el,
      pos,
      renderer,
      mesh,
      medias,
      textures,
      canvas: gl.canvas,
    };

    return new Roll(obj);
  } else if (temp == 'slider') {
    //🎞️🎞️🎞️🎞️🎞️🎞️🎞️🎞️🎞️🎞️🎞️🎞️🎞️🎞️🎞️

    //Inits
    // const singledad = document.querySelector('.single[data-ids="'+el.dataset.ids+'"]')
    // const singlewatch = document.querySelector('.Oiwatch[data-ids="'+el.dataset.ids+'"]')

    // const renderersingle = new Renderer({
    //   alpha: true,
    //   dpr: Math.max(window.devicePixelRatio, 2),

    //   width: singledad.offsetWidth,
    //   height: singledad.offsetHeight,
    // })
    const renderer = new Renderer({
      alpha: true,
      dpr: Math.max(window.devicePixelRatio, 2),

      width: el.offsetWidth,
      height: el.offsetWidth,
    });

    const { gl } = renderer;
    //Slider
    const scene = new Transform();

    gl.canvas.classList.add('glSlider');
    el.parentNode.querySelector('.cCover').appendChild(gl.canvas);

    //📽️📽️📽️📽️📽️📽️📽️📽️
    const cam = this.createCamera(gl);

    //📐📐📐📐📐📐📐

    const geometry = new Plane(gl, {
      heightSegments: 1,
      widthSegments: 1,
    });

    //👓👓👓👓👓👓👓
    // let texturesingle = new Texture( renderersingle.gl, {
    //   generateMipmaps: false,
    // })

    const textures = [];
    const meshes = [];

    let medias = el.parentNode.querySelectorAll('video,img');
    // START TEXTURES HERE

    for (let [i, a] of medias.entries()) {
      let texture = new Texture(gl, {
        generateMipmaps: false,
      });

      let url = a.dataset.src || a.dataset.oi;
      let exists = this.texs.find((element) => element.src == url);

      if (import.meta.env.DEV) {
        if (url.includes('.mp4')) {
          exists = this.texs[0];
        } else {
          exists = this.texs[2];
        }
      }

      if (url.includes('.mp4')) {
        if (exists) {
          texture.image = exists;
        } else {
          console.log('no fun' + url);
          texture.image = await this.loadVideo(a, url);
        }
      } else {
        if (exists) {
          texture.image = exists;
        } else {
          console.log('no fun' + url);
          texture.image = await this.loadImage(url);
        }
      }

      // if(i == 0){
      //   texturesingle.image = texture.image
      // }

      textures.push(texture);
      const program = new Program(gl, {
        vertex: SlV,
        fragment: SlF,
        uniforms: {
          uStart: { value: 0 },
          uTime: { value: 0 },
          tMap: { value: texture },
          uCover: { value: new Vec2(0, 0) },
          uTextureSize: { value: new Vec2(0, 0) },
        },
      });
      let mesh = new Mesh(gl, { geometry, program });

      mesh.setParent(scene);
      meshes.push(mesh);
    }
    let post = null;
    // if(this.main.device < 2){
    if (1 == 1) {
      post = new Post(gl);
      post.addPass({
        fragment: SlPF,
        uniforms: {
          uTime: { value: 0 },
          uStart: { value: 0 },
          uHover: { value: 0 },
        },
      });
    }
    //Single

    // renderersingle.gl.canvas.classList.add('glSingle')
    // singledad.appendChild(renderersingle.gl.canvas)
    // const programsingle = new Program(renderersingle.gl,{
    //   vertex:SlVF,
    //   fragment:SlSF,
    //   uniforms:{
    //     uStart: { value: 0 },
    //     uEnd: { value: 0 },
    //     uTime: { value: 0 },
    //     tMap: { value: texturesingle },
    //     uCover: { value: new Vec2(0, 0) },
    //     uTextureSize: { value: new Vec2(0, 0) },

    //   },

    // })

    // let tr = new Triangle(renderersingle.gl)

    // let meshsingle = new Mesh( renderersingle.gl, { geometry:tr, program:programsingle })

    const obj = {
      el,
      pos,
      renderer,
      scene,
      meshes,
      medias,
      textures,
      post,
      cam,
      canvas: gl.canvas,
      dev: this.main.device,
      // singledad,
      // singlewatch,
      // renderersingle,
      // meshsingle,
      // texturesingle,
    };
    return new Sl(obj);
  } else if (temp == 'pg') {
    //🧮🧮🧮🧮🧮🧮

    const renderer = new Renderer({
      alpha: true,
      dpr: Math.max(window.devicePixelRatio, 2),

      width: window.innerWidth,
      height: el.innerHeight,
    });
    //📐📐📐📐📐📐📐

    const { gl } = renderer;

    gl.canvas.classList.add('glPlay');
    document.body.appendChild(gl.canvas);
    //📽️📽️📽️📽️📽️📽️📽️📽️
    const cam = this.createCamera(gl);
    const scene = new Transform();

    const geometry = new Plane(gl, {
      heightSegments: 1,
      widthSegments: 1,
    });

    //📺📺📺📺📺📺📺
    const texture = new Texture(gl, {
      generateMipmaps: false,
    });

    // const program = new Program(gl,{
    //   vertex:PGv,
    //   fragment:PGs,
    //   uniforms:{
    //     uTime: { value: 0 },
    //     uStart: { value: 0 },
    //     uStart1: { value: .5 },
    //     tMap: { value: texture },
    //     uCover: { value: new Vec2(0, 0) },
    //     uTextureSize: { value: new Vec2(0, 0)},
    //     uMouse: { value: new Vec2(0,0) },
    //     uLoad:{value:0}
    //   },

    // })
    // const mesh = new Mesh(gl, { geometry ,  program })

    const obj = {
      el,
      pos,
      cam,
      // mesh,
      renderer,
      texture,
      scene,
      geometry,
      // program,
      canvas: gl.canvas,
      touch: this.main.isTouch,
      device: this.main.device,
      rev: this.main.events.anim,
    };

    return new PG(obj);
  } else if (temp == 'pgel') {
    const obj = {
      el,
      pgid: el.dataset.pg,
      pos: document.querySelector('.Oi-pg').dataset.oi,
    };
    return obj;
  } else {
    //🖼️🖼️🖼️🖼️🖼️🖼️

    const renderer = new Renderer({
      alpha: true,
      dpr: Math.max(window.devicePixelRatio, 2),

      width: el.offsetWidth,
      height: el.offsetHeight,
    });
    //📐📐📐📐📐📐📐

    const { gl } = renderer;

    gl.canvas.classList.add('glMedia');
    el.parentNode.appendChild(gl.canvas);

    const geometry = new Triangle(gl, {
      heightSegments: 1,
      widthSegments: 1,
    });

    //📺📺📺📺📺📺📺
    const texture = new Texture(gl, {
      generateMipmaps: false,
    });

    let url = el.dataset.src;

    let exists = this.texs.find((element) => element.src == url);

    if (import.meta.env.DEV) {
      if (url.includes('.mp4')) {
        exists = this.texs[0];
      } else {
        exists = this.texs[2];
      }
    }

    if (url.includes('.mp4')) {
      if (exists) {
        texture.image = exists;
      } else {
        console.log('no fun');
        texture.image = await this.loadVideo(el.parentNode.querySelector('video'), url);
      }
    } else {
      if (exists) {
        texture.image = exists;
      } else {
        console.log('no fun');
        texture.image = await this.loadImage(url);
      }
    }

    const program = new Program(gl, {
      vertex: fractalV,
      fragment: fractalF,
      uniforms: {
        uTime: { value: 0 },
        uStart: { value: 0 },
        uStart1: { value: 0.5 },
        tMap: { value: texture },
        uCover: { value: new Vec2(0, 0) },
        uTextureSize: { value: new Vec2(texture.image.naturalWidth, texture.image.naturalHeight) },
        uMouse: { value: new Vec2(0, 0) },
      },
    });
    const mesh = new Mesh(gl, { geometry, program });

    const obj = {
      el,
      pos,
      mesh,
      renderer,
      texture,
      canvas: gl.canvas,
      touch: this.main.isTouch,
    };

    return new Base(obj);
  }
}


=== FILE END: src/app/gl/els.js ===



=== FILE START: src/app/gl/ios.js ===

export function callIos() {
  let root = null;
  let opts = {
    root: root,
    threshold: [0],
  };

  this.callback = (entries, observer) => {
    entries.forEach((entry) => {
      if (!entry.target.dataset.oi || this.isVisible == 0) {
        return false;
      }

      const pos = entry.target.dataset.oi;
      this.iosmap.get(parseInt(pos));
      if (this.iosmap.get(parseInt(pos))) {
        this.checkIo(pos, entry);
      }
    });
  };

  this.obs = new IntersectionObserver(this.callback, opts);

  if (this.ios) {
    for (let [i, a] of this.iosmap.entries()) {
      this.obs.observe(a.el);
    }
  }
}

export async function loadIos() {
  for (let [i, a] of this.iosmap.entries()) {
    if (a.load) {
      await a.load(this.loadImage, this.loadVideo);
    }
  }
}

export function showIos() {
  for (let [i, a] of this.iosmap.entries()) {
    a.el.style.visibility = 'visible';
  }
}

export function checkIo(pos, entry) {
  let check = false;
  if (this.iosmap.get(parseInt(pos)).check) {
    check = this.iosmap.get(parseInt(pos)).check(entry);
  }
}


=== FILE END: src/app/gl/ios.js ===



=== FILE START: src/app/gl/create.js ===

import { Camera, Plane, Triangle, Mesh, Geometry, Texture, Text, RenderTarget, Transform, Program, Vec2 } from 'ogl';

import imurl from './e.jpeg?url';

export async function create(texs = []) {
  // this.camera = await this.createCamera()
  // await this.createScene()

  // const fntAss = await this.createMSDF()
  // console.log(fntAss)
  // this.fontMSDF = fntAss[0]

  // await this.createPrograms()
  // console.log('creo tex')
  await this.createAssets(texs);
  // console.log('termino tex')

  let div = document.createElement('div');
  div.dataset.temp = 'loader';

  this.loader = await this.createEls(div);

  await this.onResize();

  this.isVisible = 1;
}

export function createCamera(gl = this.gl) {
  let camera = new Camera(gl);
  camera.position.z = 45;
  return camera;
}

export function createScene() {
  this.scene = new Transform();
}

export async function cleanTemp() {
  for (let [i, a] of this.iosmap.entries()) {
    if (a.active == 1) {
      a.removeEvents();
    } else {
      if (a.renderer) {
        a.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
        a.canvas.remove();
      }
    }
  }

  // this.isVisible = 0

  // for(let a of this.ios){

  //   a.removeEvents()
  //   a.el.removeAttribute('data-oi')

  //   this.obs.unobserve(a.el)
  //   this.scene.removeChild(a.plane)
  // }
}

export async function createTemp(temp) {
  this.ios = [];
  this.temp = temp;

  for (let [i, a] of this.iosmap.entries()) {
    this.iosmap.delete(i);
  }

  this.iosmap = new Map();

  await this.createIos();
}

export async function createIos() {
  let ios = document.querySelectorAll('main .Oi');

  // let triangle = new Triangle(this.gl)

  for (let [i, ioel] of ios.entries()) {
    ioel.dataset.oi = i;
    let io = null;

    let objio = [];
    let mesh = '';
    let geometry = '';
    let text = '';
    let plane = '';
    let tex = '';
    let program = '';

    let geometext = '';
    let meshtext = '';
    let target = '';

    let exp = ioel.dataset.temp || 'base';

    io = await this.createEls(ioel);

    if (io.isready == 0) {
      io.isready = 1;
      io.el.style.visibility = 'hidden';
      io.isdone = 0;

      io.onResize(this.viewport, this.main.screen);

      this.iosmap.set(i, io);
    } else if (io.el.classList.contains('Oi-pgel')) {
      this.iosmap.set(i, io);
      ioel.dataset.oi = io.pos;
    }
  }

  await this.loadIos();
  this.isVisible = 1;
}

export async function show() {
  this.showIos();
  await this.timeout(64);
  this.callIos();
}


=== FILE END: src/app/gl/create.js ===



=== FILE START: src/app/gl/effects/roll/base.js ===

// 🎢
import { check, start, stop, updateY, updateScale, updateAnim } from './position.js';

import { Vec2 } from 'ogl';

class Roll {
  constructor(obj) {
    this.name = 'Roll';
    this.el = obj.el;
    this.pos = obj.pos;
    this.renderer = obj.renderer;
    this.mesh = obj.mesh;
    this.scene = obj.scene;
    this.canvas = obj.canvas;
    this.medias = obj.medias;
    this.textures = obj.textures;

    this.parent = document.querySelector('.cRoll');
    this.singles = document.querySelectorAll('.stck_hold .single');

    this.renderer.gl.canvas.classList.add('hideme');

    this.active = -1;
    this.isready = 0;

    this.ctr = {
      actual: 0,
      current: 0,
      limit: 0,
      start: 0,
      prog: 0,
      progt: 0,
      stop: 0,
    };

    this.change = 0;
    this.stopt = 0;
    //MOUSE

    this.norm = 0;
    this.end = 0;
    this.lerp = 0.6;

    this.time = null;
    this.ishovered = 0;

    this.animhover = gsap.timeline({ paused: true });
    // .to(this.post.passes[0].program.uniforms.uHover,{value:1,duration:1,ease:'power2.inOut',
    // onComplete:()=>{

    // },

    // },0)

    let end = 0;
    let start = 1;
    let anim = 1.2;

    const els = document.querySelectorAll('main .cnt_el');
    const vh = 40;

    this.animctr = gsap.timeline({ paused: true, onUpdate: () => {} });

    let length = this.textures.length - 1;

    for (let [i, a] of this.textures.entries()) {
      let end = 0;
      let start = 1;
      let anim = 1.2;
      let del = 0.4;
      if (i == 0) {
        end = 0;
        start = 0;
        anim = 0;

        this.animctr
          .fromTo(
            this.mesh.program.uniforms.uChange,
            { value: 0 },
            {
              value: 1,
              duration: 0.6,
              ease: 'power2.inOut',

              onStart: () => {
                // console.log('start '+i)
                this.mesh.program.uniforms.tMap.value = this.textures[0];
                this.mesh.program.uniforms.tMap2.value = this.textures[1];
                this.checkVid(0, 1);
              },
              onReverseComplete: () => {
                // console.log('rev '+i)
                this.mesh.program.uniforms.tMap.value = this.textures[0];
                this.mesh.program.uniforms.tMap2.value = this.textures[1];
                this.checkVid(0, 1);
              },
              // onComplete:()=>{
              //   console.log('end first '+this.ctr.actual+' '+this.ctr.progt)
              // }
            },
            del
          )
          .fromTo(
            this.mesh.program.uniforms.uStart,
            { value: 0 },
            { value: 0.4, duration: 0.6, ease: 'power2.inOut' },
            del
          )
          .fromTo(
            this.mesh.program.uniforms.uEnd,
            { value: 0.4 },
            { value: 0, duration: 0.6, ease: 'power2.inOut' },
            del
          );
        // .fromTo(els[i],{y:0+'vh'},{y:vh+'vh',duration:.8,ease:'power2.inOut'},0)
        // this.animctr
        // .set(a.program.uniforms.uStart,{value:0},0)
        // .fromTo(a.program.uniforms.uChange,{value:0},{value:1.2,duration:.2,ease:'power2.inOut'},0)
        // .fromTo(a.program.uniforms.uEnd,{value:end},{value:1,duration:.1,ease:'power2.inOut'},0)
      } else {
        del = 0.4;
        if (i == length) {
          // del = 0
          // console.log('opuesiyo')
        }
        this.animctr.set(
          this.mesh.program.uniforms.tMap,
          {
            value: a,
            onReverseComplete: () => {
              // console.log('set reverse')

              // console.log('rev '+i)
              this.mesh.program.uniforms.tMap.value = this.textures[i - 1];
              this.mesh.program.uniforms.tMap2.value = this.textures[i];
              this.checkVid(i - 1, i);

              this.mesh.program.uniforms.uStart.value = 0;
              this.mesh.program.uniforms.uEnd.value = 0;
              this.mesh.program.uniforms.uChange.value = 1;
            },
            onComplete: () => {
              if (this.textures[i + 1]) {
                // console.log('set complete')
                this.mesh.program.uniforms.tMap.value = this.textures[i];
                this.mesh.program.uniforms.tMap2.value = this.textures[i + 1];
                this.checkVid(i, i + 1);

                this.mesh.program.uniforms.uStart.value = 0;
                this.mesh.program.uniforms.uEnd.value = 0;
                this.mesh.program.uniforms.uChange.value = 0;
              }
            },
          },
          i + del
        );
        if (this.textures[i + 1]) {
          this.animctr
            .fromTo(
              this.mesh.program.uniforms.uChange,
              { value: 0 },
              { value: 1, duration: 0.6, ease: 'power2.inOut' },
              i + del
            )
            .fromTo(
              this.mesh.program.uniforms.uStart,
              { value: 0 },
              { value: 0.4, duration: 0.6, ease: 'power2.inOut' },
              i + del
            )
            .fromTo(
              this.mesh.program.uniforms.uEnd,
              { value: 0.4 },
              { value: 0, duration: 0.6, ease: 'power2.inOut' },
              i + del
            );
          // .fromTo(els[i],{y:0+'vh'},{y:vh+'vh',duration:.8,ease:'power2.inOut'},i-.2)
        } else {
        }
      }
    }
    // .fromTo(this.meshsingle.program.uniforms.uChange,{value:anim},{value:0,duration:.2,ease:'power2.inOut',

    // },0)
    // .fromTo(this.meshsingle.program.uniforms.uStart,{value:start},{value:0,duration:.1,ease:'power2.inOut',

    // },0)
    // .fromTo(this.meshsingle.program.uniforms.uTime,{value:0},{value:1.2,duration:.2,ease:'power2.inOut',

    // },.5)
    // .fromTo(this.meshsingle.program.uniforms.uEnd,{value:end},{value:1,duration:.1,ease:'power2.inOut',

    // },.9)

    //STATE
    // al 0 parado
    // al 1 ejecutando
    //al -1 si está animando?
    this.state = 0;

    this.initEvents();
  }

  update(time, speed, pos) {
    if (!this.renderer) {
      return false;
    }
    if (this.time == null) {
      this.time = performance.now() - 10;
    }

    // this.time -=time

    // this.end = lerp(this.end,this.norm,this.lerp)

    // this.animmouse.progress(1 - this.end)
    // this.calcChars()

    // console.log(this.positioncur)
    // console.log(this.positiontar)

    // if(this.mesh.program.uniforms.uKey.value > -1){

    //   this.mesh.program.uniforms.uKey.value = -1
    // }

    // if(speed!= 0){
    //   this.updateY(pos)

    // }

    // this.mesh.scale.x = this.viewport[0] * (this.bound[2] )/ this.screen[0]
    // this.mesh.scale.y = this.viewport[1] * this.bound[3] / this.screen[1]
    // this.post.passes[0].program.uniforms.uTime.value = time

    // this.mesh.scale.x = 12
    // this.mesh.scale.y =

    // this.renderer.render({
    //   scene: this.scene,
    //   camera: this.camera
    // })

    if (this.state == 1) {
      this.ctr.actual = pos;
      this.updateY(pos);
      if (this.ctr.stop != 1 && this.state == 1) {
        this.updateAnim();
      }

      for (let [i, a] of this.textures.entries()) {
        if (this.textures[i].image.tagName == 'VIDEO') {
          if (this.textures[i].image.readyState >= this.textures[i].image.HAVE_ENOUGH_DATA) {
            if (!this.textures[i].image) this.textures[i].image = this.textures[i].image;

            this.textures[i].needsUpdate = true;
          }
        }
      }

      this.renderer.render({
        scene: this.mesh,
      });
      // this.post.passes[0].program.uniforms.uTime.value = time
      // this.post.render({scene:this.scene,camera:this.camera})
    }
  }
  initEvents() {
    // this.el.parentNode.onmouseenter = () =>{
    //   this.animhover.timeScale(1)
    //   this.animhover.play()
    //   this.ishovered = 1
    // }

    // this.el.parentNode.onmouseleave = () =>{
    //   this.animhover.pause()
    //   this.animhover.timeScale(.4)
    //   this.animhover.reverse()
    //   this.ishovered = 0
    // }

    this.searchTex = (i, u) => {
      // console.log('polito'+i+' '+u)

      if (this.medias[i].tagName == 'VIDEO') {
        this.mesh.program.uniforms.uTextureSize.value = [this.medias[i].width, this.medias[i].height];
      } else {
        this.mesh.program.uniforms.uTextureSize.value = [
          this.textures[i].image.naturalWidth,
          this.textures[i].image.naturalHeight,
        ];
      }

      if (this.medias[u].tagName == 'VIDEO') {
        this.mesh.program.uniforms.uTextureSize2.value = [this.medias[u].width, this.medias[u].height];
      } else {
        this.mesh.program.uniforms.uTextureSize2.value = [
          this.textures[u].image.naturalWidth,
          this.textures[u].image.naturalHeight,
        ];
      }
    };

    this.checkVid = (a, b) => {
      for (let [i, oth] of this.textures.entries()) {
        if (oth.image.tagName == 'VIDEO') {
          if (a == i || b == i) {
            oth.image.play();
          } else {
            oth.image.pause();
          }
        }
      }

      this.searchTex(a, b);
    };

    this.actualpos = 0;

    this.searchTex(this.actualpos, this.actualpos + 1);
  }

  removeEvents() {
    if (this.state != 1) {
      this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
      this.canvas.remove();
      return false;
    }
    this.active = -2;

    this.canvas.style.transition = 'none';
    this.canvas.parentNode.style.pointerEvents = 'none';
    gsap
      .timeline({
        onUpdate: () => {
          this.renderer.render({
            scene: this.mesh,
          });
        },
        onComplete: () => {
          this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
          this.canvas.remove();
        },
      })
      .to(this.mesh.program.uniforms.uStart, { value: 0.8, duration: 1, ease: 'power2.inOut' }, 0)

      .to(
        this.canvas,
        {
          webkitFilter: 'blur(' + 6 + 'px)',
          filter: 'blur(' + 6 + 'px)',
          duration: 1,
          ease: 'power2.inOut',
        },
        0
      )

      .to(
        this.canvas,
        {
          opacity: 0,
          duration: 0.6,
          ease: 'power2.inOut',
        },
        0.4
      );
  }

  onResize(viewport, screen) {
    let bound = this.el.getBoundingClientRect();
    this.bound = [bound.x, bound.y, bound.width, bound.height];

    this.screen = [this.parent.clientWidth, this.parent.clientHeight];

    this.aspect = this.parent.clientWidth / this.parent.clientHeight;
    this.renderer.setSize(this.parent.clientWidth, this.parent.clientHeight);

    let calc = 0;
    let fix = parseInt(this.screen[1] + this.el.clientHeight);
    // let fix =  0

    this.ctr.start = parseInt(bound.y + window.scrollY - this.parent.clientHeight);
    this.ctr.limit = this.el.clientHeight + this.parent.clientHeight;
    // this.ctr.end = this.ctr.limit + this.el.clientHeight

    this.updateY();
    this.updateScale();

    this.mesh.program.uniforms.uCover.value = [this.parent.clientWidth, this.parent.clientHeight];
  }

  async changeState(n) {
    if (n == 1) {
      // if(this.textures[0].image.tagName == 'VIDEO'){
      //   console.log('chuto')
      //   this.textures[0].image.play()
      // }

      const animin = gsap
        .timeline()
        .fromTo(this.mesh.program.uniforms.uStart, { value: 1.2 }, { value: 0, duration: 1, ease: 'power2.inOut' }, 0)
        .fromTo(
          this.mesh.program.uniforms.uEnd,
          { value: 1.2 },
          {
            value: 0,
            duration: 2,
            ease: 'power2.inOut',
            onStart: () => {
              this.mesh.program.uniforms.tMap.value = this.textures[0];
              this.mesh.program.uniforms.tMap2.value = this.textures[1];
              this.checkVid(0, 1);
              this.state = 1;
              this.renderer.gl.canvas.classList.remove('hideme');
              // this.singles[0].style.pointerEvents ='all'
            },
          },
          0
        );
    } else {
      this.renderer.gl.canvas.classList.add('hideme');
      this.state = 0;
      for (let [i, a] of this.textures.entries()) {
        this.singles[i].style.pointerEvents = 'none';
        if (a.image.tagName == 'VIDEO') {
          a.image.pause();
        }
      }
    }
  }
}

Roll.prototype.check = check;
Roll.prototype.start = start;
Roll.prototype.stop = stop;
Roll.prototype.updateY = updateY;
Roll.prototype.updateScale = updateScale;
Roll.prototype.updateAnim = updateAnim;

export default Roll;


=== FILE END: src/app/gl/effects/roll/base.js ===



=== FILE START: src/app/gl/effects/roll/position.js ===

export function check(entry) {
  let vis = false;

  vis = entry.isIntersecting;

  if (vis == 1) {
    this.start();
  } else if (vis == 0) {
    this.stop(entry);
  }
  return vis;
}

export function start() {
  if (this.active == 1) {
    return false;
  }

  if (this.active == -1) {
  }
  this.active = 1;
  // THE SAME IS THE PLAY ONLY IF IT IS GOING TO ENTER
  if (this.state == 1) {
    // for(let a of this.medias){
    //   if(a.tagName == 'VIDEO'){
    //     a.play()
    //   }
    // }
  }
}

export function stop(entry) {
  if (this.active < 1) {
    return false;
  }

  // THE SAME IS THE PLAY ONLY IF IT IS GOING TO ENTER
  if (this.state == 1) {
    // for(let a of this.medias){
    //   if(a.tagName == 'VIDEO'){
    //     a.play()
    //   }
    // }
    if (entry.intersectionRect.y > 0) {
      return false;
    }
    gsap.to(this.animctr, {
      progress: 1,
      duration: 0.2,
      onStart: () => {},
      onComplete: () => {
        this.ctr.current = this.ctr.limit;
        this.ctr.target = this.ctr.limit;
        this.ctr.prog = 1;
        this.ctr.progress = 1;
      },
    });
  }

  this.active = 0;
}
export function updateX(sum = 0) {}
export function updateY(y = 0) {
  if (this.ctr.stop != 1) {
    this.ctr.current = y - this.ctr.start;
    this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current);
  }
}

export function updateAnim() {
  this.ctr.progt = (this.ctr.current / this.ctr.limit).toFixed(3);
  this.ctr.prog = lerp(this.ctr.prog, this.ctr.progt, 0.03);
  this.animctr.progress(this.ctr.prog);

  // console.log(this.ctr.progt)
}

export function updateScale() {
  // a.scale.x = (this.viewport[0] * this.parent.clientWidth / this.screen[0]) * 2
  // a.scale.y = (this.viewport[1] * this.parent.clientHeight / this.screen[1]) * 2
}


=== FILE END: src/app/gl/effects/roll/position.js ===



=== FILE START: src/app/gl/effects/title/base.js ===

// 💬
import { check, start, stop, updateX, updateY, updateScale } from './position.js';

import { Vec2 } from 'ogl';

class Title {
  constructor(obj) {
    this.el = obj.el;
    this.cnt = obj.el.parentNode.querySelector('.cCover');
    this.pos = obj.pos;
    this.renderer = obj.renderer;
    this.mesh = obj.mesh;
    this.text = obj.text;
    this.canvas = obj.canvas;
    this.touch = obj.touch;

    this.fstsize = window.innerWidth;

    this.scene = obj.scene;
    this.camera = obj.cam;

    this.lastx = 0;

    this.active = -1;
    this.isready = 0;

    this.coords = [0, 0];
    this.norm = [0, 0];
    this.end = [0, 0];
    this.lerp = 0.6;
    this.actualChar = -2;

    this.power = [];
    this.positioncur = [];
    this.positiontar = [];

    this.actualChar = -2;

    this.change = 0;
    this.stopt = 0;

    this.initEvents();
  }

  update(time, speed, pos) {
    if (!this.renderer || this.active == 2) {
      return false;
    } else {
      this.end[0] = lerp(this.end[0], this.norm[0], this.lerp);
      // this.end[1] = lerp(this.end[1],this.norm[1],this.lerp)
    }

    this.mesh.program.uniforms.uMouse.value = [this.end[0], 0];
    this.mesh.program.uniforms.uTime.value = time;

    this.positioncur = this.lerpArr(this.positioncur, this.positiontar, this.lerp);

    this.mesh.program.uniforms.uPowers.value = this.positioncur;

    if (this.stopt == 0) {
      this.renderer.render({ scene: this.scene, camera: this.camera });
    }
  }
  removeEvents() {
    this.tt.classList.remove('act');

    this.lerp = 0.03;
    this.animout.pause();
    this.animin.pause();
    this.active = 2;

    // this.end[0] = 0
    // this.norm[0] = 0
    let x = this.tt.clientWidth;
    // this.mesh.program.uniforms.uKey.value =  0
    this.mesh.program.uniforms.uKey.value = this.chars.length - 1;
    this.calcChars(this.tt.clientWidth);

    this.positioncur = this.lerpArr(this.positioncur, this.positiontar, 1);

    // if(this.lastx > this.tt.clientWidth * .5){
    //   x = this.tt.clientWidth
    //   this.mesh.program.uniforms.uKey.value = this.chars.length - 1

    // }

    gsap
      .timeline({
        onUpdate: () => {
          this.calcChars(0, -0.5);

          this.end[0] = lerp(this.end[0], this.norm[0], this.lerp);
          this.mesh.program.uniforms.uMouse.value = [this.end[0], 0];
          this.positioncur = this.lerpArr(this.positioncur, this.positiontar, this.lerp);
          this.mesh.program.uniforms.uPowers.value = this.positioncur;

          this.renderer.render({ scene: this.scene, camera: this.camera });
        },
        onComplete: () => {
          this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
          this.canvas.remove();
        },
      })
      .to(this.mesh.program.uniforms.uPower, { value: 1, duration: 0.8, ease: 'power4.inOut' }, 0)
      .to(
        this.cnt,

        {
          opacity: 0,
          duration: 0.6,
          ease: 'power2.inOut',
        },
        0
      );
  }
  initEvents() {
    //ANIM MOUSE IN
    this.animin = gsap
      .timeline({ paused: true })
      .to(
        this.mesh.program.uniforms.uPower,
        { value: 1, duration: 0.36, ease: 'power4.inOut', onComplete: () => {} },
        0
      );

    //ANIMOUT

    this.animout = gsap.timeline({ paused: true }).to(
      this.mesh.program.uniforms.uPower,
      {
        value: 0,
        duration: 0.6,
        ease: 'none',
        onComplete: () => {
          this.mesh.program.uniforms.uKey.value = -1;
        },
      },
      0
    );

    this.tt = this.el.parentNode.querySelector('.Oiel');
    new window.SplitType(this.tt, { types: 'chars,words' });

    this.getChars();
    if (this.el.dataset.nome) {
      return false;
    }

    this.inFn = (e) => {
      this.stopt = 0;
      this.lerp = 0.03;
      let out = 0;
      let lX = 0;
      if (e.touches) {
        lX = e.touches[0] ? e.touches[0].pageX - this.bound[0] : 0;
      } else {
        lX = e.layerX;
      }
      if (lX < 60) {
        out = -0.5;
      } else {
        out = 0.5;
      }
      this.calcChars(lX, out);

      this.animout.pause();
      this.animin.play();
      this.lerp = 0.06;
    };

    this.mvFn = (e) => {
      let lX = 0;
      if (e.touches) {
        lX = e.touches[0] ? e.touches[0].pageX - this.bound[0] : 0;

        // console.log(lX)
      } else {
        lX = e.layerX;
      }
      this.calcChars(lX);
    };

    this.lvFn = (e) => {
      let lX = 0;
      if (e.touches) {
        lX = e.touches[0] ? e.touches[0].pageX - this.bound[0] : 0;
      } else {
        lX = e.layerX;
      }
      this.lerp = 0.03;
      let out = 0;
      if (lX < 60) {
        out = 0.5;
      } else {
        out = -0.5;
      }
      this.calcChars(lX, out);
      this.animin.pause();
    };

    if (this.touch == 0) {
      this.tt.onmouseenter = (e) => this.inFn(e);
      this.tt.onmousemove = (e) => this.mvFn(e);
      this.tt.onmouseleave = (e) => this.lvFn(e);
    } else {
      this.tt.ontouchstart = (e) => this.inFn(e);
      this.tt.ontouchmove = (e) => this.mvFn(e);
      this.tt.ontouchend = (e) => this.lvFn(e);
    }

    this.charFn = (e, i) => {
      this.mesh.program.uniforms.uKey.value = i;
      this.actualChar = i;
    };

    for (let [i, a] of this.chars.entries()) {
      a.onmouseenter = (e) => this.charFn(e, i);
      a.ontouchstart = (e) => this.charFn(e, i);
      //   // if(i != -1){
      //   //   if(this.mesh.program.uniforms.uKey.value < i){
      //   //     this.end[0] = -.5
      //   //     this.norm[0] =-.5

      //   //   }
      //   //   else if(this.mesh.program.uniforms.uKey.value > i){
      //   //     this.end[0] = .5
      //   //     this.norm[0] = .5

      //   //   }

      //   // }
      //   // this.positiontar[i] = 1
      //   // this.positioncurr[i] = 1
      //   this.mesh.program.uniforms.uKey.value = i

      //   this.actualChar = i
      // }

      // a.onmousemove = (e) =>{
      // this.coords[0] = e.clientX
      // this.coords[1] = e.clientY

      // console.log(this.coords)
      // console.log(this.viewport)
      //MAP SCREEN
      // this.norm[0] = this.map(this.coords[0], 0, this.viewport[0], -1, 1)
      // this.norm[1] = this.map(this.coords[1], 0, this.viewport[1], 1, -1)
      //  this.norm[0] = e.offsetX/e.target.clientWidth
      //  this.norm[1] = 0
      //  this.norm[0] = (this.coords[0] - this.bound[0])/e.target.clientWidth
      //  this.norm[1] = (this.coords[1] - this.bound[1])/this.bound[3]

      // this.norm[0]-=.5

      // this.norm[1]-=.5
      // }
    }
  }

  getChars() {
    this.chars = this.tt.querySelectorAll('.char');

    this.charw = [];
    this.charsposw = [];
    this.totalw = 0;

    let arrw = [];
    let arrh = [];

    for (let [i, a] of this.chars.entries()) {
      this.positiontar.push(0.5);
      this.positioncur.push(0.5);

      this.charw.push(a.clientWidth);
      this.charsposw.push(this.totalw);
      this.totalw += a.clientWidth;

      arrw.push(a.clientWidth);
      arrw.push(a.clientWidth);
      arrh.push(a.clientHeight);
    }

    this.mesh.program.uniforms.uWidth.value = arrw;
    this.mesh.program.uniforms.uHeight.value = arrh;
  }

  calcChars(x, out = undefined) {
    this.lastx = x;
    let arr = [];
    let tot = 0;
    let startp = 0;
    if (out != undefined) {
      for (let [i, a] of this.chars.entries()) {
        arr.push(out);
      }
    } else {
      for (let [i, a] of this.chars.entries()) {
        tot = x - this.charsposw[i];
        tot = tot / this.charw[i];

        tot -= 0.5;
        tot = Math.min(Math.max(tot, -0.5), 0.5);
        arr.push(tot);
      }
    }

    this.positiontar = arr;
  }

  onResize(viewport, screen) {
    let bound = this.cnt.getBoundingClientRect();
    this.bound = [bound.x, bound.y, bound.width, bound.height];

    // this.text.resize({width:parseInt(this.el.dataset.w)*444})
    // this.text.resize({width:1000})
    // this.viewport = [viewport.w,viewport.h]
    this.screen = [bound.width, bound.height];

    // console.log(this.text)
    // console.log(this.renderer)
    this.renderer.setSize(bound.width, bound.height);
    // this.aspect = 4
    this.camera.perspective({
      aspect: this.renderer.gl.canvas.clientWidth / this.renderer.gl.canvas.clientHeight,
    });
    this.camera.fov = 45;
    this.camera.position.set(0, 0, 7);

    const fov = this.camera.fov * (Math.PI / 180);
    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;
    const width = height * this.camera.aspect;

    this.viewport = [width, height];

    this.getChars();

    // this.text.update({text:this.el.dataset.text})
    // this.text.resize(334)

    // this.scene.scale.x = window.innerWidth /this.fstsize
    // this.scene.scale.y = window.innerWidth /this.fstsize

    // this.mesh.scale.x = 1.2
    // this.mesh.scale.y = 1.2
    // const fov = this.camera.fov * (Math.PI / 180)
    // const height = 2 * Math.tan(fov / 2) * this.camera.position.z
    // const width = height * this.camera.aspect

    // this.viewport = [width,height]
    // this.mesh.scale.x = this.viewport[0] * bound.width / bound.width
    // this.mesh.scale.y = this.viewport[0] * bound.width / bound.width

    // if(this.el.parentNode.querySelector('.ttj')){
    //   this.renderer.setSize(bound.width*this.el.dataset.m,bound.width*this.el.dataset.m)

    // }
    // else if(this.el.parentNode.querySelector('.tt1')){
    //   this.renderer.setSize(bound.width*this.el.dataset.m,bound.width*this.el.dataset.m)

    // }
    // this.renderer.setSize(window.innerWidth,window.innerHeight)
  }

  lerpArr(value1, value2, t, out) {
    if (typeof value1 === 'number' && typeof value2 === 'number') return lerp(value1, value2, t);
    else {
      //assume array
      var len = Math.min(value1.length, value2.length);
      out = out || new Array(len);
      for (var i = 0; i < len; i++) out[i] = lerp(value1[i], value2[i], t);
      return out;
    }
  }
}

Title.prototype.check = check;
Title.prototype.start = start;
Title.prototype.stop = stop;
Title.prototype.updateX = updateX;
Title.prototype.updateY = updateY;
Title.prototype.updateScale = updateScale;

export default Title;


=== FILE END: src/app/gl/effects/title/base.js ===



=== FILE START: src/app/gl/effects/title/position.js ===

export function check(entry) {
  let vis = false;

  vis = entry.isIntersecting;

  if (vis == 1) {
    this.start();
  } else if (vis == 0) {
    this.stop();
  }
  return vis;
}

export function start() {
  if (this.active == 1) {
    return false;
  }

  if (this.active == -1) {
    let arr = [0.8, 2, 2];
    // let arr = [.8,2]
    if (this.el.dataset.nome) {
      arr = [0.8, 2, 2];
      // arr = [1,1.4]
    }
    this.animstart = gsap
      .timeline({ paused: true })
      .fromTo(
        this.mesh.program.uniforms.uStart,
        { value: 1 },
        {
          value: 0,
          duration: arr[0],
          ease: 'power4.inOut',
        },
        0
      )
      // .fromTo(this.canvas,
      //   {webkitFilter:'blur('+3+'px)',filter:'blur('+3+'px)'},
      //   {
      //     webkitFilter:'blur('+0+'px)',filter:'blur('+0+'px)',
      //     duration:arr[2],
      //     delay:1,
      //    ease:'power2.inOut'
      //   }
      //  ,0)
      .fromTo(
        this.mesh.program.uniforms.uPower,
        { value: 0.5 },
        {
          value: 0,
          duration: arr[1],
          ease: 'power2.inOut',
        },
        0
      )
      .set(
        this.mesh.program.uniforms.uKey,

        {
          value: -1,
          onComplete: () => {
            this.tt.classList.add('act');
            this.stopt = 1;
            this.actualChar = -1;
          },
        },
        '>'
      );

    this.animstart.play();

    // let anim = anime.timeline({
    //   autoplay: false
    // })
    // .add({
    //   duration:800,
    //   targets:this.mesh.program.uniforms.uStart,
    //   value:[1,0],
    //   autoplay: false,
    //   easing:(el,i,t)=>{
    //     return function(t){
    //       return window.Power4.inOut(t)

    //     }
    //     return t

    //   }

    // },0)
    // .add({
    //   duration:2000,
    //   targets:this.mesh.program.uniforms.uPower,
    //   value:[2,0],
    //   autoplay: false,
    //   easing:(el,i,t)=>{
    //     return function(t){
    //       return window.Power2.out(t)

    //     }
    //     return t

    //   }

    // },0)
    // .add({
    //   duration:11,
    //   targets:this.mesh.program.uniforms.uKey,
    //   value:-1,
    //   autoplay: false,
    //   complete:()=>{
    //     this.tt.classList.add('act')
    //     this.actualChar = -1
    //   }

    // },2000)
  }
  this.active = 1;
}

export function stop() {
  if (this.animstart) {
    if (this.animstart.progress() != 1) {
      return false;
    }
  }
  if (this.active < 1) {
    return false;
  }

  this.active = 0;
}
export function updateX(x = 0) {
  // this.mesh.position.x = -(this.viewport[0] / 2) + (this.mesh.scale.x / 2) + ((this.bound[0] - x) / this.screen[0]) * this.viewport[0]
}
export function updateY(y = 0) {
  // this.mesh.position.y = ((this.viewport[1] / 2) - (this.mesh.scale.y / 2) - ((this.bound[1] - y) / this.screen[1]) * this.viewport[1])
}

export function updateScale() {
  // this.mesh.scale.x = this.viewport[0] * (this.bound[2] * 2.)/ this.screen[0]
  // this.mesh.scale.y = this.viewport[1] * this.bound[3] / this.screen[1]
}


=== FILE END: src/app/gl/effects/title/position.js ===



=== FILE START: src/app/gl/effects/about/base.js ===

// 👩‍⚖️
import { check, start, stop, updateX, updateY, updateAnim } from './position.js';

import { Vec2 } from 'ogl';

class About {
  constructor(obj) {
    this.name = 'About';
    this.el = obj.el;
    this.pos = obj.pos;
    this.renderer = obj.renderer;
    this.mesh = obj.mesh;
    this.post = obj.post;
    this.text = obj.text;
    this.canvas = obj.canvas;

    this.touch = obj.touch;

    this.cnt = obj.el.parentNode.querySelector('.cCover');
    this.camera = obj.cam;
    this.scene = obj.scene;

    this.active = -1;
    this.isready = 0;

    this.ctr = {
      actual: 0,
      current: 0,
      limit: 0,
      start: 0,
      prog: 0,
      progt: 0,
      stop: 0,
    };
    this.animctr = gsap.timeline({ paused: true });
    // .fromTo(this.post.passes[0].program.uniforms.uTime,{value:0},{value:2,duration:.3,immediateRender:false,ease:'power2.inOut',

    // },0)
    // .fromTo(this.post.passes[0].program.uniforms.uTime,{value:2},{value:0,duration:.3,immediateRender:false,ease:'power2.inOut',

    // },.7)
    // .fromTo(this.post.passes[0].program.uniforms.uStart,{value:.39},{value:.8,duration:1,immediateRender:false,ease:'power2.inOut',

    // },0)
    this.change = 0;
    this.stopt = 0;
    //MOUSE

    this.norm = 0;
    this.end = 0;
    this.lerp = 0.6;

    this.animmouse = gsap
      .timeline({ paused: true })
      // .fromTo(this.post.passes[0].program.uniforms.uMouseT,{value:0},{value:1,duration:.1,immediateRender:false,ease:'power2.inOut',

      // },.05)
      // .fromTo(this.post.passes[0].program.uniforms.uMouseT,{value:1},{value:0,duration:.1,immediateRender:false,ease:'power2.inOut',

      // },.95)
      .fromTo(
        this.post.passes[0].program.uniforms.uMouse,
        { value: -1 },
        {
          value: 1.2,
          duration: 1,
          immediateRender: false,
          ease: 'none',
        },
        0
      );
    this.animmouse.progress(0);

    this.initEvents();
  }

  update(time, speed, pos) {
    if (!this.renderer) {
      return false;
    }
    this.end = lerp(this.end, this.norm, this.lerp);
    // this.end = parseFloat(this.end).toFixed(3)
    this.animmouse.progress(this.end);

    // this.calcChars()

    // console.log(this.positioncur)
    // console.log(this.positiontar)

    // if(this.mesh.program.uniforms.uKey.value > -1){

    //   this.mesh.program.uniforms.uKey.value = -1
    // }

    // if(speed!= 0){
    //   this.updateY(pos)

    // }

    // this.mesh.scale.x = this.viewport[0] * (this.bound[2] )/ this.screen[0]
    // this.mesh.scale.y = this.viewport[1] * this.bound[3] / this.screen[1]
    // this.post.passes[0].program.uniforms.uTime.value = time

    // this.mesh.scale.x = 12
    // this.mesh.scale.y =

    if (this.ctr.actual != pos) {
      this.ctr.actual = pos;
      this.updateY(pos);
    }
    if (this.ctr.stop != 1) {
      this.updateAnim();
    }
    if (this.stopt == 0) {
      this.post.render({ scene: this.mesh });
    }
  }
  initEvents() {
    this.tt = this.el.parentNode.querySelector('.Oiel');
    new window.SplitType(this.tt, { types: 'chars,words' });

    this.inFn = (e) => {
      this.stopt = 0;
      this.lerp = 0.02;
    };

    this.mvFn = (e) => {
      if (e.touches) {
        this.norm = e.touches[0] ? e.touches[0].pageX - this.bound[0] : 0;
        this.norm = this.norm / this.bound[3];
      } else {
        this.norm = e.layerY / this.bound[3];
      }
      this.norm = clamp(0, 1, this.norm);
      this.norm = parseFloat(this.norm).toFixed(3);
    };

    this.lvFn = (e) => {
      this.lerp = 0.01;

      if (e.touches) {
        this.norm = e.touches[0] ? e.touches[0].pageX - this.bound[0] : 0;
        this.norm = this.norm / this.bound[3];
      } else {
        this.norm = e.layerY / this.bound[3];
      }

      this.norm = parseFloat(this.norm).toFixed(3);
    };

    // if(this.touch == 0){
    //   this.tt.onmouseenter = (e) => this.inFn(e)
    //   this.tt.onmousemove = (e) => this.mvFn(e)
    //   this.tt.onmouseleave = (e) => this.lvFn(e)

    // }
    // else{
    //   this.tt.ontouchstart = (e) => this.inFn(e)
    //   this.tt.ontouchmove = (e) => this.mvFn(e)
    //   this.tt.ontouchend = (e) => this.lvFn(e)
    // }

    // this.tt.onmouseenter = (e) =>{
    //   this.stopt = 0

    //   this.lerp = .02

    // }
    // this.tt.onmousemove = (e) =>{
    //   this.norm = e.layerY/this.bound[3]
    //   this.norm = clamp(0,1,this.norm)
    //   this.norm = parseFloat(this.norm).toFixed(3)
    // }

    // this.tt.onmouseleave = (e) =>{
    //   this.lerp = .01
    //   this.norm = e.layerY/this.bound[3]
    //   this.norm = parseFloat(this.norm).toFixed(3)
    // }
  }

  onResize(viewport, screen) {
    let bound = this.cnt.getBoundingClientRect();
    this.bound = [bound.x, bound.y, bound.width, bound.height];

    this.screen = [bound.width, bound.height];

    let calc = this.screen[1] * 0.5;
    let fix = this.screen[1] * 0.3;

    this.ctr.start = parseInt(bound.y - screen.h + window.scrollY + calc);
    this.ctr.limit = parseInt(this.el.clientHeight + calc);

    this.renderer.setSize(bound.width, bound.height);
    // this.aspect = 4
    this.camera.perspective({
      aspect: this.renderer.gl.canvas.clientWidth / this.renderer.gl.canvas.clientHeight,
    });
    this.camera.fov = 45;
    this.camera.position.set(0, 0, 7);

    const fov = this.camera.fov * (Math.PI / 180);
    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;
    const width = height * this.camera.aspect;

    this.viewport = [width, height];

    // this.renderer.setSize(window.innerWidth,window.innerHeight)

    this.renderer.render({ scene: this.scene, camera: this.camera });
  }

  removeEvents() {
    this.active = -2;
    gsap
      .timeline({
        onUpdate: () => {
          this.post.render({ scene: this.mesh });
        },
        onComplete: () => {
          this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
          this.canvas.remove();
        },
      })
      .to(
        this.post.passes[0].program.uniforms.uStart,
        {
          value: -1,
          duration: 1,
          ease: 'power2.inOut',
        },
        0
      )
      .to(
        this.canvas,
        {
          webkitFilter: 'blur(' + 6 + 'px)',
          filter: 'blur(' + 6 + 'px)',
          duration: 1,
          ease: 'power2.inOut',
        },
        0
      )

      .to(
        this.canvas,
        {
          opacity: 0,
          duration: 0.6,
          ease: 'power2.inOut',
        },
        0.4
      );
  }
}

About.prototype.check = check;
About.prototype.start = start;
About.prototype.stop = stop;
About.prototype.updateX = updateX;
About.prototype.updateY = updateY;
About.prototype.updateAnim = updateAnim;

export default About;


=== FILE END: src/app/gl/effects/about/base.js ===



=== FILE START: src/app/gl/effects/about/position.js ===

export function check(entry) {
  let vis = false;

  vis = entry.isIntersecting;

  if (vis == 1) {
    this.start();
  } else if (vis == 0) {
    this.stop();
  }
  return vis;
}

export function start() {
  if (this.active == 1) {
    return false;
  }

  if (this.active == -1) {
    // let arr = [.8,2,2]
    this.animstart = gsap.timeline({ paused: true }).set(this.canvas, { opacity: 1 }, 0).fromTo(
      this.post.passes[0].program.uniforms.uStart,
      { value: -0.92 },
      {
        value: 1,
        duration: 4,
        ease: 'power2.inOut',
      },
      0
    );
    // .fromTo(this.mesh.program.uniforms.uPower,
    //   {value:.5},
    //   {
    //    value:0,
    //    duration:arr[1],
    //    ease:'power2.inOut'
    //   }
    //  ,0)
    //  .set(this.mesh.program.uniforms.uKey,

    //    {
    //     value:-1,
    //     onComplete:()=>{

    //       this.tt.classList.add('act')
    //       this.stopt = 1
    //       this.actualChar = -1
    //     }
    //    }
    //   ,'>')

    this.animstart.play();
  }
  this.active = 1;
}

export function stop() {
  this.end = 0;
  this.ctr.prog = 0;
  this.ctr.progt = 0;
  this.animctr.progress(0);
  if (this.active < 1) {
    return false;
  }

  this.active = 0;
}
export function updateX(x = 0) {
  // this.mesh.position.x = -(this.viewport[0] / 2) + (this.mesh.scale.x / 2) + ((this.bound[0] - x) / this.screen[0]) * this.viewport[0]
}
export function updateY(y = 0) {
  if (this.ctr.stop != 1) {
    this.ctr.current = y - this.ctr.start;
    this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current);
  }

  // this.mesh.position.y = ((this.viewport[1] / 2) - (this.mesh.scale.y / 2) - ((this.bound[1] - y) / this.screen[1]) * this.viewport[1])
}

export function updateAnim() {
  this.ctr.progt = parseFloat(this.ctr.current / this.ctr.limit).toFixed(3);
  this.ctr.prog = lerp(this.ctr.prog, this.ctr.progt, 0.015);
  // this.ctr.prog = parseFloat(this.ctr.prog).toFixed(3)
  this.animctr.progress(this.ctr.prog);
}

export function updateScale() {
  // this.mesh.scale.x = this.viewport[0] * (this.bound[2] * 2.)/ this.screen[0]
  // this.mesh.scale.y = this.viewport[1] * this.bound[3] / this.screen[1]
}


=== FILE END: src/app/gl/effects/about/position.js ===



=== FILE START: src/app/gl/effects/image/base.js ===

// 🖼️
import { check, start, stop, updateX, updateY, updateScale, updateAnim } from './position.js';

import { Vec2 } from 'ogl';

class Base {
  constructor(obj) {
    this.el = obj.el;
    this.pos = obj.pos;
    this.mesh = obj.mesh;
    this.tex = obj.texture;
    this.renderer = obj.renderer;
    this.touch = obj.touch;
    this.canvas = obj.canvas;

    this.active = -1;
    this.isready = 0;
    // this.mesh.visible = false

    this.media = obj.el.parentNode.querySelector('img,video');

    if (this.tex.image.tagName == 'VIDEO') {
      this.isv = 1;
      this.mesh.program.uniforms.uTextureSize.value = [this.media.width, this.media.height];
    }

    this.coords = [0, 0];
    this.norm = [0, 0];
    this.end = [0, 0];
    this.ease = 0.06;

    this.ctr = {
      actual: 0,
      current: 0,
      limit: 0,
      start: 0,
      prog: 0,
      progt: 0,
      lerp: 0.065,
      stop: 0,
    };

    let xanim = 0.8;
    if (this.el.dataset.op) {
      xanim = -0.8;
    }

    this.animctr = gsap.timeline({ paused: true }).fromTo(
      this.mesh.program.uniforms.uStart,
      { value: xanim },
      {
        value: 0,
        ease: 'power2.inOut',
        onComplete: () => {
          this.ctr.stop = 1;
          this.el.classList.add('act');
        },
      },
      0
    );
  }

  async load() {
    // let img = await this.loadImage(this.url)
    // console.log(this.url)
    // console.log(img)
    // this.tex.image = img
    // this.mesh.program.uniforms.uTexture.value = this.tex.image
    // this.mesh.program.uniforms.uTextureSize.value = new Vec2(this.tex.image.naturalWidth,this.tex.image.naturalHeight)

    this.initEvents();
  }

  update(time, speed, pos) {
    if (!this.mesh) {
      return false;
    }
    if (this.isready == 0 || this.active < 0) {
      return false;
    }

    this.end[0] = this.lerp(this.end[0], this.norm[0], this.ease);
    this.end[1] = this.lerp(this.end[1], this.norm[1], this.ease);

    this.mesh.program.uniforms.uMouse.value = this.end;
    // this.mesh.program.uniforms.uTime.value = time

    // if(speed!= 0){
    if (this.ctr.actual != pos) {
      this.ctr.actual = pos;
      this.updateY(pos);
    }
    if (this.ctr.stop != 1) {
      this.updateAnim();
    }
    if (this.isv) {
      if (this.tex.image.readyState >= this.tex.image.HAVE_ENOUGH_DATA) {
        if (!this.tex.image) this.tex.image = this.tex.image;

        this.tex.needsUpdate = true;
      }
    }

    this.renderer.render({ scene: this.mesh });

    return true;
  }
  initEvents() {
    this.mvFn = (e) => {
      this.ease = 0.03;
      this.coords[0] = e.touches ? e.touches[0].clientX : e.clientX;
      // this.coords[1] = e.touches ? e.touches[0].clientY : e.clientY

      // console.log(this.coords)
      // console.log(this.viewport)
      //MAP SCREEN
      // this.norm[0] = this.map(this.coords[0], 0, this.viewport[0], -1, 1)
      // this.norm[1] = this.map(this.coords[1], 0, this.viewport[1], 1, -1)

      this.norm[0] = (this.coords[0] - this.bound[0]) / this.bound[2];
      //  this.norm[1] = (this.coords[1] - this.bound[1])/this.bound[3]

      this.norm[0] -= 0.5;
      //  this.norm[1]-=.5
    };

    this.lvFn = (e) => {
      this.ease = 0.01;
      this.norm[0] = 0;
      // this.norm[1] = 0
    };

    if (this.touch == 0) {
      this.el.onmousemove = (e) => this.mvFn(e);
      this.el.onmouseleave = (e) => this.lvFn(e);
    } else {
      this.ctr.lerp = 0.1;
      this.el.style.touchAction = 'none';
      this.el.ontouchmove = (e) => this.mvFn(e);
      this.el.ontouchend = (e) => this.lvFn(e);
    }
  }
  removeEvents() {
    this.active = -2;

    this.ease = 0.022;
    this.norm[0] = -0.5;
    this.el.style.pointerEvents = 'none';

    gsap
      .timeline({
        onUpdate: () => {
          this.end[0] = this.lerp(this.end[0], this.norm[0], this.ease);
          this.mesh.program.uniforms.uMouse.value = this.end;
          this.renderer.render({ scene: this.mesh });
        },
        onComplete: () => {
          this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
          this.canvas.remove();
        },
      })
      .to(
        this.canvas,
        {
          webkitFilter: 'blur(' + 6 + 'px)',
          filter: 'blur(' + 6 + 'px)',
          opacity: 0,
          duration: 0.6,
          ease: 'power2.inOut',
        },
        0.4
      );
  }
  onResize(viewport, screen) {
    this.viewport = [viewport.w, viewport.h];
    this.screen = [screen.w, screen.h];

    let bound = this.media.getBoundingClientRect();
    this.bound = [bound.x, bound.y, bound.width, bound.height];

    // let calc = (screen.h - this.media.clientHeight) * .5
    let calc = 0;

    let fix = this.screen[1] * 0.2;
    if (this.touch == 0) {
      if (this.media.clientHeight > this.screen[1] * 0.7) {
        calc = this.screen[1] * -0.4;
      }
    } else {
      if (this.screen[0] < this.screen[1]) {
        fix = 0;
        calc = 0;
      }
    }

    this.ctr.start = parseInt(bound.y - screen.h + window.scrollY + fix);
    this.ctr.limit = parseInt(this.media.clientHeight + calc + fix);

    // this.w = window.innerWidth
    // this.h = window.innerHeight

    if (this.mesh) {
      this.updateY();

      // HACER AQUI EL SET SIZE

      this.renderer.setSize(bound.width, bound.height);

      this.mesh.program.uniforms.uCover.value = new Vec2(this.bound[2], this.bound[3]);

      this.renderer.render({ scene: this.mesh });
    }
  }

  lerp(value1, value2, t) {
    return value1 * (1 - t) + value2 * t;
  }
}

Base.prototype.check = check;
Base.prototype.start = start;
Base.prototype.stop = stop;
Base.prototype.updateX = updateX;
Base.prototype.updateY = updateY;
Base.prototype.updateAnim = updateAnim;
Base.prototype.updateScale = updateScale;

export default Base;


=== FILE END: src/app/gl/effects/image/base.js ===



=== FILE START: src/app/gl/effects/image/position.js ===

export function check(entry) {
  let vis = false;

  vis = entry.isIntersecting;
  if (entry.isIntersecting == undefined) {
    return vis;
  }
  if (vis == 1) {
    this.start();
  } else if (vis == 0) {
    this.stop();
  }
  return vis;
}

export function start() {
  if (this.active == 1) {
    return false;
  }
  // if(this.mesh){
  //   this.mesh.visible = true
  // }

  if (this.isv) {
    this.tex.image.play();
  }
  this.active = 1;
  this.updateX();
  this.updateY();
  this.updateScale();
}

export function stop() {
  if (this.active == 0 || this.active == -1) {
    return false;
  }

  // if(this.mesh){
  //   this.mesh.visible = false
  // }

  if (this.isv) {
    this.media.pause();
  }
  this.active = 0;
}
export function updateX(x = 0) {}
export function updateY(y = 0) {
  if (this.ctr.stop != 1) {
    this.ctr.current = y - this.ctr.start;
    this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current);
  }
}
export function updateAnim() {
  this.ctr.progt = (this.ctr.current / this.ctr.limit).toFixed(3);
  this.ctr.prog = lerp(this.ctr.prog, this.ctr.progt, this.ctr.lerp);

  this.animctr.progress(this.ctr.prog);
}

export function updateScale() {}


=== FILE END: src/app/gl/effects/image/position.js ===



=== FILE START: src/app/gl/effects/slides/base.js ===

// 🎞️
import { check, start, stop, updateX, updateY, updateScale, updateAnim } from './position.js';

import { Vec2 } from 'ogl';

class Slides {
  constructor(obj) {
    this.name = 'Slides';
    this.el = obj.el;
    this.pos = obj.pos;
    this.renderer = obj.renderer;
    this.meshes = obj.meshes;
    this.scene = obj.scene;
    this.post = obj.post;
    this.camera = obj.cam;
    this.canvas = obj.canvas;
    this.medias = obj.medias;
    this.textures = obj.textures;

    this.device = obj.dev;
    this.h = window.innerHeight;
    this.single = document.querySelector('.single[data-ids="' + this.el.dataset.ids + '"]');

    // this.single.style.zIndex = 12
    // this.single.style.paddingLeft = (12 * this.el.dataset.ids)+'px'
    // this.single.innerHTML = parseInt(this.el.dataset.ids)+1
    // this.single.style.backgroundColor = 'red'
    // this.single.style.color = 'white'
    if (this.single) {
      this.single.style.opacity = 0;
    }
    this.oldpos = 0;
    // this.scene.visible = false
    // for(let a of this.meshes ){
    //   a.visible = false
    // }
    // console.log(this.post)
    // console.log(this.renderer.gl.getExtension('WEBGL_lose_context'))
    // this.loss = this.post.gl.getExtension('WEBGL_lose_context')
    // console.log(this.loss)
    // this.loss.loseContext()
    // console.log(this.post.passes[0])
    // this.post.gl.finish()
    // this.post.gl.flush()

    // this.renderer.gl.viewport(0, 0, 1, 1)
    if (this.el.dataset.ids == 0) {
      this.canvas.classList.add('fCanvas');
      // firstfix = window.innerHeight * .5
    }

    this.active = -1;
    this.isready = 0;

    this.posmesh = 0;
    this.posmeshes = [];
    this.objpos = { x: 0, target: 0, timer: 0 };

    this.ctr = {
      actual: 0,
      current: 0,
      limit: 0,
      start: 0,
      prog: 0,
      progt: 0,
      stop: 0,
    };

    gsap.set(this.canvas, { display: 'none' });

    this.animctr = gsap.timeline({ paused: true });
    if (this.el.dataset.ids != 0) {
      this.animctr;
      // .fromTo(this.objpos,{timer:0},{timer:1,duration:.1,ease:'power2.inOut',
      //   onUpdate:()=>{
      //     if(this.slideanim){
      //       this.slideanim.timeScale(this.objpos.timer)
      //     }
      //   }
      // },0)

      this.animctr
        .fromTo(
          this.objpos,
          { timer: 0 },
          {
            timer: 1,
            duration: 0.1,
            ease: 'power2.inOut',
            onUpdate: () => {
              if (this.slideanim) {
                this.slideanim.timeScale(this.objpos.timer);
              }
            },
          },
          0
        )
        .fromTo(this.post.passes[0].program.uniforms.uStart, { value: 1.5 }, { value: 0, duration: 0.45 }, 0);
    } else {
      //INTRO 1
      this.animin = gsap
        .timeline({
          paused: true,
          delay: 0.1,
          onStart: () => {
            this.active = 1;

            for (let a of this.textures) {
              if (a.image.tagName == 'VIDEO') {
                a.image.play();
              }
            }

            this.slideanim.play();
          },
          onComplete: () => {
            delete this.animin;
          },
        })
        .fromTo(
          this.canvas,
          {
            webkitFilter: 'blur(' + 6 + 'px)',
            filter: 'blur(' + 6 + 'px)',
          },
          {
            webkitFilter: 'blur(' + 0 + 'px)',
            filter: 'blur(' + 0 + 'px)',
            duration: 0.8,
            ease: 'power2.inOut',
          },
          0
        )

        .fromTo(
          this.canvas,
          {
            opacity: 0,
          },
          {
            opacity: 1,
            duration: 0.6,
            ease: 'power2.inOut',
          },
          0
        );

      this.animin
        .fromTo(
          this.objpos,
          { timer: 0 },
          {
            timer: 1,
            duration: 0.9,
            ease: 'none',
            onUpdate: () => {
              if (this.slideanim) {
                this.slideanim.timeScale(this.objpos.timer);
              }
            },
          },
          0.8
        )
        .fromTo(
          this.post.passes[0].program.uniforms.uStart,
          { value: 1.5 },
          { value: 0, duration: 2, ease: 'power4.inOut' },
          0.6
        );
    }

    this.animctr.fromTo(
      this.objpos,
      { timer: 1 },
      {
        timer: 0,
        duration: 0.05,
        ease: 'power2.inOut',
        onUpdate: () => {
          if (this.slideanim) {
            this.slideanim.timeScale(this.objpos.timer);
          }
        },
      },
      0.95
    );

    // .set(this.canvas,{display:'none'},1)
    // .set(this.canvas,{display:'block'},'>')

    this.animsinglectr = gsap.timeline({ paused: true });

    this.change = 0;
    this.stopt = 0;
    //MOUSE

    this.norm = 0;
    this.end = 0;
    this.lerp = 0.6;

    this.time = null;
    this.ishovered = 0;

    this.animhover = gsap.timeline({ paused: true });
    if (this.device < 3) {
      this.animhover.to(
        this.post.passes[0].program.uniforms.uHover,
        { value: 1, duration: 1, ease: 'power2.inOut', onComplete: () => {} },
        0
      );
    } else {
    }

    //STATE

    this.state = 0;

    this.initEvents();
  }

  removeEvents() {
    if (this.state != 0) {
      this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
      this.canvas.remove();
      return false;
    }
    this.active = -2;
    this.canvas.style.transition = 'none';
    this.canvas.parentNode.style.pointerEvents = 'none';

    let animout = gsap.timeline({
      onUpdate: () => {
        this.post.render({ scene: this.scene, camera: this.camera });
        // if(this.device < 2){
        //   this.post.render({scene:this.scene,camera:this.camera})
        // }
        // else{

        // this.renderer.render({ scene: this.scene,camera:this.camera })
        // }
      },
      onComplete: () => {
        this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
        this.canvas.remove();
      },
    });
    if (this.device < 3) {
      animout
        .to(this.post.passes[0].program.uniforms.uStart, { value: 1.5, duration: 1, ease: 'power2.inOut' }, 0)
        .to(this.post.passes[0].program.uniforms.uHover, { value: 1, duration: 1, ease: 'power2.inOut' }, 0);
    }
    animout
      .to(
        this.objpos,
        {
          timer: 0,
          duration: 0.6,
          ease: 'power2.inOut',
          onUpdate: () => {
            if (this.slideanim) {
              this.slideanim.timeScale(this.objpos.timer);
            }
          },
        },
        0
      )
      .to(
        this.canvas,
        {
          webkitFilter: 'blur(' + 6 + 'px)',
          filter: 'blur(' + 6 + 'px)',
          duration: 1,
          ease: 'power2.inOut',
        },
        0
      )

      .to(
        this.canvas,
        {
          opacity: 0,
          duration: 0.6,
          ease: 'power2.inOut',
        },
        0.4
      );
  }

  update(time, speed, pos) {
    if (!this.renderer) {
      return false;
    }
    // if(this.time == null){
    //   this.time = performance.now() - 10
    // }

    // this.time -=time
    // this.end = lerp(this.end,this.norm,this.lerp)

    // this.animmouse.progress(1 - this.end)
    // this.calcChars()

    // console.log(this.positioncur)
    // console.log(this.positiontar)

    // if(this.mesh.program.uniforms.uKey.value > -1){

    //   this.mesh.program.uniforms.uKey.value = -1
    // }

    // if(speed!= 0){
    //   this.updateY(pos)

    // }

    // this.mesh.scale.x = this.viewport[0] * (this.bound[2] )/ this.screen[0]
    // this.mesh.scale.y = this.viewport[1] * this.bound[3] / this.screen[1]
    // this.post.passes[0].program.uniforms.uTime.value = time

    // this.mesh.scale.x = 12
    // this.mesh.scale.y =

    // this.renderer.render({
    //   scene: this.scene,
    //   camera: this.camera
    // })

    if (this.state < 1 && this.active == 1) {
      // if(this.ctr.actual != pos){
      //   this.ctr.actual = pos
      this.updateY(pos, 0);
      if (this.ctr.stop != 1 && this.state == 0) {
        this.updateAnim(0);
      }
      // }
      this.updateX();

      for (let [i, a] of this.textures.entries()) {
        if (this.textures[i].image.tagName == 'VIDEO') {
          if (this.textures[i].image.readyState >= this.textures[i].image.HAVE_ENOUGH_DATA) {
            if (!this.textures[i].image) this.textures[i].image = this.textures[i].image;

            this.textures[i].needsUpdate = true;
          }
        }
      }
      // this.post.passes[0].program.uniforms.uTime.value = time

      this.post.render({ scene: this.scene, camera: this.camera });
      // if(this.device < 2){
      //   this.post.render({scene:this.scene,camera:this.camera})
      // }
      // else{

      // this.renderer.render({ scene: this.scene,camera:this.camera })
      // }
    }
  }
  initEvents() {
    if (this.device < 2) {
      this.el.parentNode.onmouseenter = () => {
        this.animhover.timeScale(1);
        this.animhover.play();
        this.ishovered = 1;
      };

      this.el.parentNode.onmouseleave = () => {
        this.animhover.pause();
        this.animhover.timeScale(0.7);
        this.animhover.reverse();
        this.ishovered = 0;
      };
    }

    this.checkVis = (e) => {
      // console.log(document.visibilityState+' '+this.active+' '+this.pos)
      if (this.active != 1 && this.active != -2) {
        return false;
      }

      if (document.visibilityState == 'hidden') {
        this.active = -2;
        this.slideanim.pause();
        this.slideanim.progress(0);
        this.resetMeshes();
        this.statepos = 0;
      } else {
        this.active = 1;

        this.slideanim.restart();
        this.slideanim.play();
      }
    };

    document.addEventListener('visibilitychange', (e) => this.checkVis(e));

    for (let [i, a] of this.medias.entries()) {
      if (a.tagName == 'VIDEO') {
        this.meshes[i].program.uniforms.uTextureSize.value = [a.width, a.height];
      } else {
        this.meshes[i].program.uniforms.uTextureSize.value = [
          this.textures[i].image.naturalWidth,
          this.textures[i].image.naturalHeight,
        ];
      }
    }

    this.resetMeshes = () => {
      for (let [i, a] of this.meshes.entries()) {
        this.posmeshes[i] = (this.wel + this.space) * i;

        a.position.x =
          -(this.viewport[0] / 2) + a.scale.x / 2 + (this.posmeshes[i] / this.screen[0]) * this.viewport[0];
      }
    };

    let time = 42;

    this.slideanim = gsap
      .timeline({
        paused: true,
        repeat: -1,
        onRepeat: () => {
          this.resetMeshes();
          this.statepos = 0;
        },
      })
      .fromTo(this.objpos, { x: 0 }, { x: 1, ease: 'none', duration: time }, 0);
  }

  onResize(viewport, screen) {
    if (this.state == 1) {
      return false;
    }
    let bound = this.el.getBoundingClientRect();
    this.bound = [bound.x, bound.y, bound.width, bound.height];

    this.h = window.innerHeight;
    this.screen = [bound.width, bound.height];

    this.statepos = 0;
    if (this.device < 3) {
      this.wel = this.bound[2] * 0.322;
    } else {
      this.wel = this.bound[2] * 0.75;
    }

    this.space = parseFloat(
      window
        .getComputedStyle(this.el.parentNode.parentNode.querySelector('.nfo_t'), null)
        .getPropertyValue('padding-left')
    );

    this.firstpos = 0;

    this.minpos = this.wel * -1;

    // this.maxpos = (this.screen[0]) + this.wel + ( (this.meshes.length - 1) * 20)

    this.maxpos = (this.meshes.length - 1) * (this.wel + this.space);
    this.totalpos = this.meshes.length * (this.wel + this.space);

    this.aspect = this.screen[0] / this.bound[3];
    this.renderer.setSize(this.screen[0], this.bound[3]);

    this.camera.perspective({
      aspect: this.renderer.gl.canvas.width / this.renderer.gl.canvas.height,
    });

    const fov = this.camera.fov * (Math.PI / 180);
    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;
    const width = height * this.camera.aspect;

    this.viewport = [width, height];
    let firstfix = 0;
    if (this.el.dataset.ids == 0) {
      firstfix = window.innerHeight * -0.15;
    }
    let calc = 0 + firstfix;
    let fix = parseInt(this.screen[1] + this.el.clientHeight * 2);
    // let fix = this.el.clientHeight
    // let fix =  0

    this.ctr.start = parseInt(bound.y - screen.h + calc + window.scrollY);
    this.ctr.limit = fix;
    // this.ctr.end = this.ctr.limit + this.el.clientHeight

    this.updateX();
    this.updateY();
    this.updateScale();

    this.resetMeshes();

    for (let [i, a] of this.medias.entries()) {
      this.meshes[i].program.uniforms.uCover.value = [this.wel, this.el.clientHeight];
    }

    // this.update(performance.now(),0,window.scrollY)
  }

  async changeState(n) {
    this.state = -1;

    const parent = this.el.parentNode.parentNode;
    const map = new Map()

      .set('n', parent.querySelector('.nfo_n'))
      .set('t', parent.querySelector('.nfo_t'))
      .set('x', parent.querySelector('.nfo_x'));

    const animout = gsap.timeline({
      paused: true,
      onComplete: () => {
        this.state = n;
      },
    });

    if (n == 1) {
      let height = 100 + 'vh';
      // if(window.innerHeight > 720){
      //   height = 720+'px'
      // }

      let waitfr = 1.6;

      animout
        .fromTo(
          this.post.passes[0].program.uniforms.uTime,
          { value: 0 },
          { value: 1, duration: 1, ease: 'power2.inOut' },
          0
        )
        .to(
          this.post.passes[0].program.uniforms.uStart,
          {
            value: 1,
            duration: 1,
            ease: 'power2.inOut',
            onStart: () => {
              this.renderer.gl.canvas.classList.add('hideme');
            },
          },
          0
        )
        .to(
          this.objpos,
          {
            timer: 0,
            duration: 0.4,
            ease: 'power2.inOut',

            onUpdate: () => {
              if (this.slideanim) {
                this.slideanim.timeScale(this.objpos.timer);
              }
            },
          },
          0
        )
        // .to(this.canvas.parentNode,{height:0,duration:.6,ease:'power2.inOut'},.6)
        .to(map.get('n'), { x: +59 + 'rem', duration: 1.8, ease: 'power2.inOut' }, 0)
        .to(map.get('t'), { x: +46.6 + 'rem', duration: 1.6, ease: 'power2.inOut' }, 0)
        .to(map.get('x'), { x: +12 + 'rem', duration: 0.6, ease: 'power2.inOut' }, 0)
        .to(
          map.get('x'),
          { paddingTop: map.get('t').clientHeight + 24 + 'px', duration: 0.6, ease: 'power2.inOut' },
          0.4
        )
        .to(
          parent,
          {
            height: height,
            duration: 1,
            ease: 'power2.inOut',
            onComplete: () => {
              parent.classList.add('cnt_el-singlemod');
              this.state = 1;
              // for(let [i,a] of this.medias.entries()){
              //   if(a.tagName == 'VIDEO'){
              //     a.pause()
              //   }
              this.animctr.progress(0);

              // }
            },
          },
          0
        )
        .to(
          parent,
          {
            opacity: 1,
            duration: 1,
            ease: 'power2.inOut',
            onComplete: () => {
              parent.classList.add('cnt_el-singlemod');
            },
          },
          0
        );
      // for(let [i,a] of this.medias.entries()){
      //   if(a.tagName == 'VIDEO'){
      //     a.pause()
      //   }

      // }

      await animout.play();

      // AT STATE 1, STOPS ALL VIDEOS EXCEPT THE FIRST
    } else {
      const animin = gsap.timeline({
        paused: true,
        onComplete: () => {
          if (this.active == 1) {
            // for(let a of this.medias){
            //   if(a.tagName == 'VIDEO'){
            //     a.play()
            //   }
            // }
            // this.slideanim.play()
          }
        },
      });
      animin
        .to(map.get('n'), { x: +0 + 'rem', duration: 1, ease: 'power2.inOut' }, 0)
        .to(map.get('t'), { x: +0 + 'rem', duration: 1.2, ease: 'power2.inOut' }, 0)
        .to(map.get('x'), { x: 0, duration: 0.6, ease: 'power2.inOut' }, 0)
        .to(map.get('x'), { paddingTop: 0, duration: 0.6, ease: 'power2.inOut' }, 0.45)
        .to(
          parent,
          {
            height: '',
            duration: 0.4,
            ease: 'power2.inOut',
            onStart: () => {
              this.slideanim.restart();
              if (this.el.dataset.ids == 0) {
                this.animfck = gsap
                  .timeline({
                    paused: true,
                    delay: 0.1,
                    onStart: () => {
                      this.active = 1;

                      for (let a of this.textures) {
                        if (a.image.tagName == 'VIDEO') {
                          a.image.play();
                        }
                      }

                      this.slideanim.play();
                    },
                    onComplete: () => {
                      delete this.animfck;
                    },
                  })
                  .fromTo(
                    this.canvas,
                    {
                      webkitFilter: 'blur(' + 6 + 'px)',
                      filter: 'blur(' + 6 + 'px)',
                    },
                    {
                      webkitFilter: 'blur(' + 0 + 'px)',
                      filter: 'blur(' + 0 + 'px)',
                      duration: 0.8,
                      ease: 'power2.inOut',
                    },
                    0
                  )

                  .fromTo(
                    this.canvas,
                    {
                      opacity: 0,
                    },
                    {
                      opacity: 1,
                      duration: 0.6,
                      ease: 'power2.inOut',
                    },
                    0
                  )
                  .fromTo(
                    this.objpos,
                    { timer: 0 },
                    {
                      timer: 1,
                      duration: 0.9,
                      ease: 'power2.inOut',
                      onUpdate: () => {
                        if (this.slideanim) {
                          this.slideanim.timeScale(this.objpos.timer);
                        }
                      },
                    },
                    0.8
                  )
                  .fromTo(
                    this.post.passes[0].program.uniforms.uStart,
                    { value: 1.5 },
                    { value: 0, duration: 0.8 },
                    0.8
                  );
              }
            },
            onComplete: () => {
              this.renderer.gl.canvas.classList.remove('hideme');
              parent.classList.remove('cnt_el-singlemod');

              this.state = 0;

              this.ctr.actual = window.scrollY;
              this.onResize(null, { w: window.innerWidth, h: window.innerHeight });

              this.slideanim.play();
              this.updateY(window.scrollY, 0);
              this.updateAnim(0);

              if (this.animfck) {
                this.animfck.play();
              }
              // Position calculation

              // for(let [i,a] of this.medias.entries()){
              //   if(a.tagName == 'VIDEO'){
              //     a.pause()
              //   }

              // }
            },
          },
          0.8
        );

      animin.play();
    }
  }
}

Slides.prototype.check = check;
Slides.prototype.start = start;
Slides.prototype.stop = stop;
Slides.prototype.updateX = updateX;
Slides.prototype.updateY = updateY;
Slides.prototype.updateScale = updateScale;
Slides.prototype.updateAnim = updateAnim;

export default Slides;


=== FILE END: src/app/gl/effects/slides/base.js ===



=== FILE START: src/app/gl/effects/slides/position.js ===

export function check(entry) {
  let vis = false;

  vis = entry.isIntersecting;

  if (vis == 1) {
    this.start(entry);
  } else if (vis == 0) {
    this.stop(entry);
  }
  return vis;
}

export function start(entry) {
  // console.log(this.meshes)
  // console.log(this.scene)
  // console.log(this.renderer)
  // console.log(this.post)

  // gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
  if (this.state == 1) {
    // if(this.el.dataset.ids != 1){
    //   return false
    // }

    if (this.single) {
      if (this.oldpos > window.scrollY) {
        // WE ARE GOING UP
        // console.log(entry.boundingClientRect.y)

        // if(entry.boundingClientRect.y > (this.h - 100 - entry.boundingClientRect.height )){
        // console.log('toco por abajo')
        if (entry.boundingClientRect.y > 60) {
          this.single.style.pointerEvents = 'all';
          // this.single.style.opacity = .4
        } else {
          // this.single.style.opacity = 0
          // this.single.style.pointerEvents = 'none'
        }
      } else {
        // WE ARE GOING DOWN

        // if(entry.boundingClientRect.y > this.h * .9){
        //   console.log('baja y entra por abajo, empieza a verse ')
        if (entry.boundingClientRect.y > 60) {
          this.single.style.pointerEvents = 'all';
          // this.single.style.opacity = .4
        } else {
          // this.single.style.opacity = 0
          this.single.style.pointerEvents = 'none';
        }

        // WE ARE GOING DOWN
      }
      this.oldpos = window.scrollY;
    }
  } else {
    gsap.set(this.canvas, { display: 'block' });
    if (this.animin) {
      this.animin.play();
      if (this.touchl) {
        this.active = 1;
      }
      return false;
    }
  }
  if (this.active == 1) {
    return false;
  }

  // this.post.render({scene:this.scene,camera:this.camera})
  // this.loss.restoreContext()

  this.active = 1;

  for (let a of this.textures) {
    if (a.image.tagName == 'VIDEO') {
      a.image.play();
    }
  }

  this.slideanim.play();
}

export function stop(entry) {
  gsap.set(this.canvas, { display: 'none' });
  if (this.state == 1) {
    // if(this.el.dataset.ids != 0){
    //   return false
    // }
    if (this.single) {
      this.single.style.pointerEvents = 'none';
      this.single.style.opacity = 0;

      this.oldpos = window.scrollY;
    }
  }
  if (this.active < 1 || this.state != 0) {
    return false;
  }
  this.slideanim.pause();
  for (let a of this.textures) {
    if (a.image.tagName == 'VIDEO') {
      a.image.pause();
    }
  }

  this.active = 0;
}
export function updateX(sum = 0) {
  this.statepos = (this.objpos.x * this.totalpos) / 1;

  let x = 0;
  for (let [i, a] of this.meshes.entries()) {
    x = this.posmeshes[i];

    x -= this.statepos;

    if (x <= this.minpos) {
      this.posmeshes[i] = this.statepos + this.maxpos + this.space;
    }

    a.position.x = -(this.viewport[0] / 2) + a.scale.x / 2 + (x / this.screen[0]) * this.viewport[0];
  }
}
export function updateY(y = 0, state = 0) {
  if (this.ctr.stop != 1) {
    this.ctr.current = y - this.ctr.start;
    this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current);
  }
}

export function updateAnim() {
  this.ctr.progt = (this.ctr.current / this.ctr.limit).toFixed(3);

  if (this.active == -2) {
    this.ctr.prog = this.ctr.progt;
  } else {
    this.ctr.prog = lerp(this.ctr.prog, this.ctr.progt, 0.015);
  }
  this.animctr.progress(this.ctr.prog);
}

export function updateScale() {
  let w = this.screen[0] * 0.322;
  let h = this.bound[3];
  if (this.device < 3) {
    w = this.screen[0] * 0.322;
  } else {
    w = this.screen[0] * 0.75;
    // h = (this.screen[0]*.8) * .5
  }

  for (let [i, a] of this.meshes.entries()) {
    a.scale.x = (this.viewport[0] * w) / this.screen[0];
    a.scale.y = (this.viewport[1] * h) / this.screen[1];
  }
}


=== FILE END: src/app/gl/effects/slides/position.js ===



=== FILE START: src/app/gl/effects/fire/base.js ===

// 🔥
import { check, start, stop, updateX, updateY, updateAnim } from './position.js';

import { Vec2 } from 'ogl';

class Footer {
  constructor(obj) {
    this.name = 'Footer';
    this.el = obj.el;
    this.pos = obj.pos;
    this.renderer = obj.renderer;
    this.mesh = obj.mesh;
    this.post = obj.post;
    this.text = obj.text;
    this.canvas = obj.canvas;

    this.touch = obj.touch;

    this.cnt = obj.el.parentNode.querySelector('.cCover');
    this.camera = obj.cam;
    this.scene = obj.scene;

    this.active = -1;
    this.isready = 0;

    this.ctr = {
      actual: 0,
      current: 0,
      limit: 0,
      start: 0,
      prog: 0,
      progt: 0,
      stop: 0,
    };
    this.animctr = gsap
      .timeline({ paused: true })
      .fromTo(
        this.post.passes[0].program.uniforms.uTime,
        { value: 0 },
        { value: 2, duration: 0.3, immediateRender: false, ease: 'power2.inOut' },
        0
      )
      .fromTo(
        this.post.passes[0].program.uniforms.uTime,
        { value: 2 },
        { value: 0, duration: 0.3, immediateRender: false, ease: 'power2.inOut' },
        0.7
      )
      .fromTo(
        this.post.passes[0].program.uniforms.uStart,
        { value: 0.39 },
        { value: 0.8, duration: 1, immediateRender: false, ease: 'power2.inOut' },
        0
      );
    this.change = 0;
    this.stopt = 0;
    //MOUSE

    this.norm = 0;
    this.end = 0;
    this.lerp = 0.6;

    this.animmouse = gsap
      .timeline({ paused: true })
      .fromTo(
        this.post.passes[0].program.uniforms.uMouseT,
        { value: 0.2 },
        { value: 2, duration: 0.3, immediateRender: false, ease: 'power2.inOut' },
        0.1
      )
      .fromTo(
        this.post.passes[0].program.uniforms.uMouseT,
        { value: 2 },
        { value: 0, duration: 0.3, immediateRender: false, ease: 'power2.inOut' },
        0.7
      )
      .fromTo(
        this.post.passes[0].program.uniforms.uMouse,
        { value: 0.39 },
        { value: 0.8, duration: 0.9, immediateRender: false, ease: 'none' },
        0.1
      );
    this.animmouse.progress(0);

    this.initEvents();
  }
  removeEvents() {
    this.active = -2;

    this.tt.style.pointerEvents = 'none';

    gsap
      .timeline({
        onUpdate: () => {
          this.post.render({ scene: this.mesh });
        },
        onComplete: () => {
          this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
          this.canvas.remove();
        },
      })
      .to(
        this.post.passes[0].program.uniforms.uOut,
        {
          value: -0.2,
          duration: 1,
          ease: 'power2.inOut',
        },
        0
      )
      .to(
        this.canvas,
        {
          opacity: 0,
          duration: 0.8,
          ease: 'none',
        },
        0.2
      );
  }

  update(time, speed, pos) {
    if (!this.renderer || this.active != 1) {
      return false;
    }
    this.end = lerp(this.end, this.norm, this.lerp);
    // this.end = parseFloat(this.end).toFixed(3)
    this.animmouse.progress(this.end);

    // this.calcChars()

    // console.log(this.positioncur)
    // console.log(this.positiontar)

    // if(this.mesh.program.uniforms.uKey.value > -1){

    //   this.mesh.program.uniforms.uKey.value = -1
    // }

    // if(speed!= 0){
    //   this.updateY(pos)

    // }

    // this.mesh.scale.x = this.viewport[0] * (this.bound[2] )/ this.screen[0]
    // this.mesh.scale.y = this.viewport[1] * this.bound[3] / this.screen[1]
    // this.post.passes[0].program.uniforms.uTime.value = time

    // this.mesh.scale.x = 12
    // this.mesh.scale.y =

    if (this.ctr.actual != pos) {
      this.ctr.actual = pos;
      this.updateY(pos);
    }
    if (this.ctr.stop != 1) {
      this.updateAnim();
    }
    if (this.stopt == 0) {
      this.post.render({ scene: this.mesh });
    }
  }
  initEvents() {
    this.tt = this.el.parentNode.querySelector('.Oiel');
    new window.SplitType(this.tt, { types: 'chars,words' });

    this.inFn = (e) => {
      this.stopt = 0;
      this.lerp = 0.02;
    };

    this.mvFn = (e) => {
      if (e.touches) {
        this.norm = e.touches[0] ? e.touches[0].pageX - this.bound[0] : 0;
        this.norm = this.norm / this.bound[3];
      } else {
        this.norm = e.layerY / this.bound[3];
      }
      this.norm = clamp(0, 1, this.norm);
      this.norm = parseFloat(this.norm).toFixed(3);
    };

    this.lvFn = (e) => {
      this.lerp = 0.01;

      if (e.touches) {
        this.norm = e.touches[0] ? e.touches[0].pageX - this.bound[0] : 0;
        this.norm = this.norm / this.bound[3];
      } else {
        this.norm = e.layerY / this.bound[3];
      }

      this.norm = parseFloat(this.norm).toFixed(3);
    };

    if (this.touch == 0) {
      this.tt.onmouseenter = (e) => this.inFn(e);
      this.tt.onmousemove = (e) => this.mvFn(e);
      this.tt.onmouseleave = (e) => this.lvFn(e);
    } else {
      // this.tt.ontouchstart = (e) => this.inFn(e)
      // this.tt.ontouchmove = (e) => this.mvFn(e)
      // this.tt.ontouchend = (e) => this.lvFn(e)
    }

    // this.tt.onmouseenter = (e) =>{
    //   this.stopt = 0

    //   this.lerp = .02

    // }
    // this.tt.onmousemove = (e) =>{
    //   this.norm = e.layerY/this.bound[3]
    //   this.norm = clamp(0,1,this.norm)
    //   this.norm = parseFloat(this.norm).toFixed(3)
    // }

    // this.tt.onmouseleave = (e) =>{
    //   this.lerp = .01
    //   this.norm = e.layerY/this.bound[3]
    //   this.norm = parseFloat(this.norm).toFixed(3)
    // }
  }

  onResize(viewport, screen) {
    let bound = this.cnt.getBoundingClientRect();
    this.bound = [bound.x, bound.y, bound.width, bound.height];

    this.screen = [bound.width, bound.height];

    let calc = this.screen[1] * 0.5;
    let fix = this.screen[1] * 0.3;

    this.ctr.start = parseInt(bound.y - screen.h + window.scrollY + calc);
    this.ctr.limit = parseInt(this.el.clientHeight + calc);

    if (this.el.parentNode.querySelector('.ttj')) {
      this.renderer.setSize(bound.width * this.el.dataset.m, bound.width * this.el.dataset.m);
    } else if (this.el.parentNode.querySelector('.tt1')) {
      // this.renderer.setSize(bound.width,bound.width)
      this.renderer.setSize(bound.width, bound.width);
    }

    this.renderer.setSize(bound.width, bound.height);
    // this.aspect = 4
    this.camera.perspective({
      aspect: this.renderer.gl.canvas.clientWidth / this.renderer.gl.canvas.clientHeight,
    });
    this.camera.fov = 45;
    this.camera.position.set(0, 0, 7);

    const fov = this.camera.fov * (Math.PI / 180);
    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;
    const width = height * this.camera.aspect;

    this.viewport = [width, height];

    this.renderer.render({ scene: this.scene, camera: this.camera });
    // this.renderer.setSize(window.innerWidth,window.innerHeight)
  }
}

Footer.prototype.check = check;
Footer.prototype.start = start;
Footer.prototype.stop = stop;
Footer.prototype.updateX = updateX;
Footer.prototype.updateY = updateY;
Footer.prototype.updateAnim = updateAnim;

export default Footer;


=== FILE END: src/app/gl/effects/fire/base.js ===



=== FILE START: src/app/gl/effects/fire/position.js ===

export function check(entry) {
  let vis = false;

  vis = entry.isIntersecting;

  if (vis == 1) {
    this.start();
  } else if (vis == 0) {
    this.stop();
  }
  return vis;
}

export function start() {
  if (this.active == 1) {
    return false;
  }

  if (this.active == -1) {
    // let anim = anime.timeline({
    //   autoplay: false
    // })
    // .add({
    //   duration:800,
    //   targets:this.mesh.program.uniforms.uStart,
    //   value:[1,0],
    //   autoplay: false,
    //   easing:(el,i,t)=>{
    //     return function(t){
    //       return window.Power4.inOut(t)
    //     }
    //     return t
    //   }
    // },0)
    // .add({
    //   duration:2000,
    //   targets:this.mesh.program.uniforms.uPower,
    //   value:[2,0],
    //   autoplay: false,
    //   easing:(el,i,t)=>{
    //     return function(t){
    //       return window.Power2.out(t)
    //     }
    //     return t
    //   }
    // },0)
    // .add({
    //   duration:11,
    //   targets:this.mesh.program.uniforms.uKey,
    //   value:-1,
    //   autoplay: false,
    //   complete:()=>{
    //     this.tt.classList.add('act')
    //     this.actualChar = -1
    //   }
    // },2000)
  }
  this.active = 1;
}

export function stop() {
  this.end = 0;
  this.ctr.prog = 0;
  this.ctr.progt = 0;
  this.animctr.progress(0);
  if (this.active < 1) {
    return false;
  }

  this.active = 0;
}
export function updateX(x = 0) {
  // this.mesh.position.x = -(this.viewport[0] / 2) + (this.mesh.scale.x / 2) + ((this.bound[0] - x) / this.screen[0]) * this.viewport[0]
}
export function updateY(y = 0) {
  if (this.ctr.stop != 1) {
    this.ctr.current = y - this.ctr.start;
    this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current);
  }

  // this.mesh.position.y = ((this.viewport[1] / 2) - (this.mesh.scale.y / 2) - ((this.bound[1] - y) / this.screen[1]) * this.viewport[1])
}

export function updateAnim() {
  this.ctr.progt = parseFloat(this.ctr.current / this.ctr.limit).toFixed(3);
  this.ctr.prog = lerp(this.ctr.prog, this.ctr.progt, 0.015);
  // this.ctr.prog = parseFloat(this.ctr.prog).toFixed(3)
  this.animctr.progress(this.ctr.prog);
}

export function updateScale() {
  // this.mesh.scale.x = this.viewport[0] * (this.bound[2] * 2.)/ this.screen[0]
  // this.mesh.scale.y = this.viewport[1] * this.bound[3] / this.screen[1]
}


=== FILE END: src/app/gl/effects/fire/position.js ===



=== FILE START: src/app/gl/effects/loader/base.js ===

// ⌛️
import { check, start, stop, updateX, updateY, updateScale } from './position.js';

import { Vec2 } from 'ogl';

class Base {
  constructor(obj) {
    this.pos = obj.pos;
    this.renderer = obj.renderer;
    this.mesh = obj.mesh;
    this.canvas = obj.canvas;
    this.program = obj.mesh.program;

    this.active = -1;
    this.isready = 0;

    this.initEvents();
  }

  update(time, speed, pos) {
    if (!this.renderer) {
      return false;
    }
    // if(this.isready == 0 || this.active == 0 ){
    //   return false
    // }
    this.program.uniforms.uTime.value = time || 0;
    this.renderer.render({ scene: this.mesh });
  }
  removeEvents() {
    this.active = 0;
    this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
    this.canvas.remove();
  }
  initEvents() {
    // let uStartgo = document.querySelector('#uStartgo')
    // uStartgo.oninput = (e) =>{
    //   gsap.fromTo(this.program.uniforms.uStart0,{value:1},{value:0,duration:1,ease:'power4.inOut'})
    //   gsap.fromTo(this.program.uniforms.uStart1,{value:.5},{value:1,duration:2,ease:'power2.inOut'})
    //   gsap.fromTo(this.program.uniforms.uStart2,{value:1},{value:0,duration:2.6,ease:'power4.inOut'})
    // }

    this.animstart = gsap
      .timeline({
        paused: true,
        onComplete: () => {
          this.active = 0;

          // document.querySelector('#uStart0').parentNode.style.display ='flex'
        },
      })
      // FIRST OPTION, VERY LONG AND TOO MUCH DETAIL
      // .fromTo(this.program.uniforms.uStart0,{value:0},{value:1,duration:.6,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartX,{value:0},{value:-.5,duration:3,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartY,{value:0.1},{value:0.95,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uMultiY,{value:0.45},{value:0.1,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStart2,{value:1},{value:0,duration:1,ease:'power2.inOut'},1.2)

      // MOUNTAIN OPTION, OOD ABOUT TIMINGS
      // .fromTo(this.program.uniforms.uStart0,{value:0},{value:1,duration:.6,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartX,{value:0},{value:-.5,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartY,{value:0.1},{value:0.95,duration:2,ease:'power2.inOut'},0)

      // .fromTo(this.program.uniforms.uMultiY,{value:0.45},{value:0.1,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStart2,{value:1},{value:0,duration:1,ease:'power2.inOut'},.6)

      // VERY LITTLE MOUNTAIN, MY OPTION, IF I REMOVE THE MULTIX, THE MOUNTAIN WILL BE NOTICED A LITTLE MORE
      .fromTo(this.program.uniforms.uStart0, { value: 0 }, { value: 1, duration: 0.6, ease: 'power2.inOut' }, 0)
      .fromTo(this.program.uniforms.uStartX, { value: 0 }, { value: -0.1, duration: 2, ease: 'power2.inOut' }, 0)
      // .set(this.program.uniforms.uMultiX,{value:-.4},0)
      .fromTo(this.program.uniforms.uMultiX, { value: -0.4 }, { value: 0.1, duration: 2, ease: 'power2.inOut' }, 0)

      .fromTo(this.program.uniforms.uStartY, { value: 0.1 }, { value: 0.95, duration: 2, ease: 'power2.inOut' }, 0)
      .fromTo(this.program.uniforms.uMultiY, { value: 0.45 }, { value: 0.3, duration: 2, ease: 'power2.inOut' }, 0)
      .fromTo(this.program.uniforms.uStart2, { value: 1 }, { value: 0, duration: 1, ease: 'power2.inOut' }, 0.6);

    this.animstart.timeScale(1.4);
  }
  onResize(viewport, screen) {
    this.viewport = [viewport.w, viewport.h];
    this.screen = [screen.w, screen.h];

    this.bound = [0, 0, screen.w, screen.h];
    // this.w = window.innerWidth
    // this.h = window.innerHeight
    if (this.renderer) {
      this.renderer.setSize(screen.w, screen.h);
      this.program.uniforms.uResolution.value = [screen.w, screen.h];
    }
  }
}

Base.prototype.check = check;
Base.prototype.start = start;
Base.prototype.stop = stop;
Base.prototype.updateX = updateX;
Base.prototype.updateY = updateY;
Base.prototype.updateScale = updateScale;

export default Base;


=== FILE END: src/app/gl/effects/loader/base.js ===



=== FILE START: src/app/gl/effects/loader/position.js ===

export function check(entry) {
  let vis = false;

  vis = entry.isIntersecting;

  if (vis == 1) {
    this.start();
  } else if (vis == 0) {
    this.stop();
  }
  return vis;
}

export function start() {
  if (this.active == 1) {
    return false;
  }

  this.active = 1;
}

export function stop() {
  if (this.active == 0) {
    return false;
  }
  if (this.anim) {
    this.anim.pause();
  }
  this.active = 0;
}
export function updateX(x = 0) {}
export function updateY(y = 0) {}

export function updateScale() {
  this.mesh.scale.x = (this.viewport[0] * this.bound[2]) / this.screen[0];
  this.mesh.scale.y = (this.viewport[1] * this.bound[3]) / this.screen[1];
}


=== FILE END: src/app/gl/effects/loader/position.js ===



=== FILE START: src/app/gl/effects/terrain/base.js ===

// 🏜️
import { check, start, stop, updateX, updateY, updateAnim, updateScale } from './position.js';

import { Vec2 } from 'ogl';

class Base {
  constructor(obj) {
    this.el = obj.el;
    this.pos = obj.pos;
    this.renderer = obj.renderer;
    this.mesh = obj.mesh;
    this.canvas = obj.canvas;
    this.program = obj.mesh.program;

    this.active = -1;
    this.isready = 0;

    this.ctr = {
      actual: 0,
      current: 0,
      limit: 0,
      start: 0,
      prog: 0,
      progt: 0,
      stop: 0,
    };

    this.initEvents();
  }

  update(time, speed, pos) {
    if (!this.renderer) {
      return false;
    }
    if (this.isready == 0 || this.active != 1) {
      return false;
    }

    if (this.ctr.actual != pos) {
      this.ctr.actual = pos;
      this.updateY(pos);

      if (this.ctr.stop != 1) {
        this.updateAnim();
      }
      this.program.uniforms.uTime.value = time || 0;
    }
  }
  initEvents() {
    // let uStartgo = document.querySelector('#uStartgo')
    // uStartgo.oninput = (e) =>{
    //   gsap.fromTo(this.program.uniforms.uStart0,{value:1},{value:0,duration:1,ease:'power4.inOut'})
    //   gsap.fromTo(this.program.uniforms.uStart1,{value:.5},{value:1,duration:2,ease:'power2.inOut'})
    //   gsap.fromTo(this.program.uniforms.uStart2,{value:1},{value:0,duration:2.6,ease:'power4.inOut'})
    // }

    this.animstart = gsap
      .timeline({
        paused: true,
        onUpdate: () => {
          this.renderer.render({ scene: this.mesh });
        },
        onComplete: () => {
          // this.active = 0
          // document.querySelector('#uStart0').parentNode.style.display ='flex'
        },
      })
      // FIRST OPTION, VERY LONG AND TOO MUCH DETAIL
      // .fromTo(this.program.uniforms.uStart0,{value:0},{value:1,duration:.6,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartX,{value:0},{value:-.5,duration:3,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartY,{value:0.1},{value:0.95,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uMultiY,{value:0.45},{value:0.1,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStart2,{value:1},{value:0,duration:1,ease:'power2.inOut'},1.2)

      // MOUNTAIN OPTION, GOOD TIMINGS
      // .fromTo(this.program.uniforms.uStart0,{value:0},{value:1,duration:.6,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartX,{value:0},{value:-.5,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartY,{value:0.1},{value:0.95,duration:2,ease:'power2.inOut'},0)

      // .fromTo(this.program.uniforms.uMultiY,{value:0.45},{value:0.1,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStart2,{value:1},{value:0,duration:1,ease:'power2.inOut'},.6)

      .fromTo('.home_about .cnt_tp', { opacity: 1 }, { opacity: 0, duration: 0.15 }, 0.9)

      // VERY LITTLE MOUNTAIN, IF I REMOVE THE MULTIX, THE MOUNTAIN IS NOTICED A BIT MORE
      .fromTo(this.program.uniforms.uStart0, { value: 0 }, { value: 1, duration: 0.6, ease: 'power2.inOut' }, 0)
      .fromTo(this.program.uniforms.uStartX, { value: 0 }, { value: -0.1, duration: 2, ease: 'power2.inOut' }, 0)
      // .set(this.program.uniforms.uMultiX,{value:-.4},0)
      .fromTo(this.program.uniforms.uMultiX, { value: -0.4 }, { value: 0.1, duration: 2, ease: 'power2.inOut' }, 0)

      .fromTo(this.program.uniforms.uStartY, { value: 0.1 }, { value: 0.95, duration: 2, ease: 'power2.inOut' }, 0)
      .fromTo(this.program.uniforms.uMultiY, { value: 0.45 }, { value: 0.3, duration: 2, ease: 'power2.inOut' }, 0)
      .fromTo(this.program.uniforms.uStart2, { value: 1 }, { value: 0, duration: 1, ease: 'power2.inOut' }, 0.6)

      // ZERO MOUNTAIN, IF I REMOVE THE SET TO MULTIX IT'S ALMOST STRAIGHT
      // .fromTo(this.program.uniforms.uStart0,{value:0},{value:1,duration:.6,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStartX,{value:0},{value:-.1,duration:2,ease:'power2.inOut'},0)
      // .set(this.program.uniforms.uMultiX,{value:0.01},0)
      // .fromTo(this.program.uniforms.uStartY,{value:0.1},{value:0.95,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uMultiY,{value:0.45},{value:0.3,duration:2,ease:'power2.inOut'},0)
      // .fromTo(this.program.uniforms.uStart2,{value:1},{value:0,duration:1,ease:'power2.inOut'},.6)

      // .fromTo(this.program.uniforms.uMultiX,{value:-.4},{value:-.34,duration:3,ease:'power2.inOut'},0)
      .fromTo(
        '.nav',
        { '--dark': '#F8F6F2', '--gray': '#8A8A8A', '--light': '#000' },
        { '--dark': '#000', '--gray': '#8A8A8A', '--light': '#F8F6F2', duration: 0.5 },
        0.1
      );
    this.animstart.progress(1);
  }
  removeEvents() {
    this.active = -2;
    gsap
      .timeline({
        onUpdate: () => {
          this.renderer.render({ scene: this.mesh });
        },
        onComplete: () => {
          this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
          this.canvas.remove();
        },
      })
      .to('.home_about .cnt_tp', { opacity: 0, duration: 0.6 }, 0)
      .to(this.program.uniforms.uStart0, { value: 1, duration: 0.4, ease: 'power2.inOut' }, 0)
      .to(this.program.uniforms.uStartX, { value: -0.1, duration: 1, ease: 'power2.inOut' }, 0)
      // .set(this.program.uniforms.uMultiX,{value:-.4},0)
      .to(this.program.uniforms.uMultiX, { value: 0.1, duration: 1, ease: 'power2.inOut' }, 0)

      .to(this.program.uniforms.uStartY, { value: 0.95, duration: 1, ease: 'power2.inOut' }, 0)
      .to(this.program.uniforms.uMultiY, { value: 0.3, duration: 1, ease: 'power2.inOut' }, 0)
      .to(this.program.uniforms.uStart2, { value: 0, duration: 0.5, ease: 'power2.inOut' }, 0.3)
      .to('.nav', { '--dark': '#000', '--light': '#F8F6F2', duration: 0.5 }, 0);
  }
  onResize(viewport, screen) {
    this.viewport = [viewport.w, viewport.h];
    this.screen = [screen.w, screen.h];

    let bound = this.el.getBoundingClientRect();
    this.bound = [bound.x, bound.y, bound.width, bound.height];
    // this.w = window.innerWidth
    // this.h = window.innerHeight
    let calc = 0;

    this.ctr.start = parseInt(bound.y - screen.h + window.scrollY);
    this.ctr.limit = parseInt(bound.height + calc);

    if (this.renderer) {
      this.renderer.setSize(screen.w, screen.h);
      this.program.uniforms.uResolution.value = [screen.w, screen.h];
    }
  }
}

Base.prototype.check = check;
Base.prototype.start = start;
Base.prototype.stop = stop;
Base.prototype.updateX = updateX;
Base.prototype.updateY = updateY;
Base.prototype.updateAnim = updateAnim;
Base.prototype.updateScale = updateScale;

export default Base;


=== FILE END: src/app/gl/effects/terrain/base.js ===



=== FILE START: src/app/gl/effects/terrain/position.js ===

export function check(entry) {
  if (entry.isIntersecting == undefined) {
    return false;
  }
  let vis = false;

  vis = entry.isIntersecting;

  if (vis == 1) {
    this.start();
  } else if (vis == 0) {
    this.stop(entry.boundingClientRect.y);
  }
  return vis;
}

export function start() {
  if (this.active == 1) {
    return false;
  }
  this.animstart.pause();
  this.active = 1;
}

export function stop(y) {
  if (this.active == 0) {
    return false;
  }

  // if(this.ctr.prog == this.ctr.progt){
  //   return false
  // }
  if (this.animstart) {
    if (y < -1) {
      this.animstart.reverse();
      this.ctr.prog = 1;
      this.ctr.progt = 1;
      this.active = 1;
    } else {
      this.animstart.play();
      this.ctr.prog = 0;
      this.ctr.progt = 0;
      this.active = 0;
    }
  }
}
export function updateX(x = 0) {}
export function updateY(y = 0) {
  if (this.ctr.stop != 1) {
    this.ctr.current = y - this.ctr.start;
    this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current);
  }
}
export function updateAnim() {
  this.ctr.progt = (this.ctr.current / this.ctr.limit).toFixed(3);
  this.ctr.prog = lerp(this.ctr.prog, this.ctr.progt, 0.045);

  this.animstart.progress(1 - this.ctr.prog);
}

export function updateScale() {
  this.mesh.scale.x = (this.viewport[0] * this.bound[2]) / this.screen[0];
  this.mesh.scale.y = (this.viewport[1] * this.bound[3]) / this.screen[1];
}


=== FILE END: src/app/gl/effects/terrain/position.js ===



=== FILE START: src/app/gl/effects/grid/base.js ===

// 🧮

import { check, checkEl, start, stop, updateX, updateY, updateScale, updateAnim } from './position.js';
// import imurl from '../📦assets/play.jpg.webp?url'
// import imurl from '../📦assets/play.jpg?url'
// import vidsmall from '../📦assets/vidsmall.mp4?url'

import PGs from '../../shaders/portfolio_main.fragment.glsl';
import PGv from '../../shaders/portfolio_main.vertex.glsl';

import { Triangle, Program, Mesh, Vec2, Texture } from 'ogl';

class Base {
  constructor(obj) {
    this.el = obj.el;
    this.pos = obj.pos;
    this.scene = obj.scene;
    this.camera = obj.cam;
    this.tex = obj.texture;

    this.renderer = obj.renderer;
    this.touch = obj.touch;
    this.device = obj.device;
    this.canvas = obj.canvas;

    this.geo = obj.geometry;

    this.rev = obj.rev;

    this.active = -1;
    this.isready = 0;
    // this.mesh.visible = false

    this.onanim = -1;

    this.els = this.el.parentNode.querySelectorAll('.el');

    this.sizer = this.el.parentNode.querySelector('.Sizer');

    this.animctr = gsap.timeline({ paused: true });

    this.meshes = [];
    this.mmap = new Set();

    let mesh = '';
    let cont = 0;
    let row = 0;
    let w = this.sizer.clientWidth;
    let h = this.sizer.clientHeight;

    // console.log(w+' '+h)
    for (let [i, a] of this.els.entries()) {
      let program = new Program(this.renderer.gl, {
        vertex: PGv,
        fragment: PGs,
        uniforms: {
          uTime: { value: 0 },
          uStart: { value: 0 },
          uZoom: { value: 1 },
          uMove: { value: 1 },
          tMap: { value: this.texture },
          uCover: { value: new Vec2(w, h) },
          uTextureSize: { value: new Vec2(0, 0) },
          uMouse: { value: 0 },
          uLoad: { value: 0 },
        },
      });
      let texture = new Texture(this.renderer.gl, {
        generateMipmaps: false,
      });

      mesh = new Mesh(this.renderer.gl, { geometry: this.geo, program: program });

      mesh.setParent(this.scene);

      const qck = gsap.utils.pipe(
        gsap.utils.clamp(-2, 2),
        gsap.quickTo(mesh.program.uniforms.uMouse, 'value', { duration: 0.8, ease: 'power1' })
      );
      this.meshes.push({
        mesh,
        texture: texture,
        el: a,
        id: cont,
        pos: i,
        row: row,
        multx: 1,
        multy: 1,
        mult: 1,
        qck,
        loaded: 0,
      });

      if (this.device < 2) {
        if (cont == 3 || cont == 6 || cont == 9 || cont == 11) {
          row++;
        }

        cont++;
        if (cont == 12) {
          cont = 0;
        }
      } else {
        cont++;
        row++;
      }
    }

    if (this.device < 2) {
      // this.calculator = [2.55,2.26]
      this.calculator = [2.55, 2.55];
    } else if (this.device == 2) {
      this.calculator = [1.49, 1.49, 0.49];
    } else {
      this.calculator = [1.33, 1.33, 0.33];
    }

    this.initEvents();
  }

  async load(loadim, loadvid) {
    this.loadImage = loadim;
    this.loadVideo = loadvid;

    // let img = await this.loadImage(this.url)
    // console.log(this.url)
    // console.log(img)
    // this.tex.image = img
    // this.mesh.program.uniforms.uTexture.value = this.tex.image
    // this.mesh.program.uniforms.uTextureSize.value = new Vec2(this.tex.image.naturalWidth,this.tex.image.naturalHeight)

    this.loadEls(this.els);
  }

  async loadEls(els) {
    let src = '';
    const video = document.createElement('video');
    video.isPlaying = false;
    video.style.display = 'none';
    video.autoplay = true;
    video.setAttribute('webkit-playsinline', 'webkit-playsinline');
    video.setAttribute('playsinline', 'playsinline');
    video.muted = true;
    video.loop = true;
    video.dataset.auto = true;

    for (let [i, el] of this.els.entries()) {
      let path = el.querySelector('.el_md video,.el_md img');
      let url = path.dataset.src;

      if (path.tagName == 'IMG') {
        if (import.meta.env.DEV) {
          url = imurl;
        }
        src = await this.loadImage(url);
        this.meshes[i].loaded = 1;
        this.meshes[i].mesh.program.uniforms.uTextureSize.value = [src.naturalWidth, src.naturalHeight];
        this.meshes[i].texture.image = src;
        this.meshes[i].mesh.program.uniforms.tMap.value = this.meshes[i].texture;
        // this.meshes[i].mesh.program.uniforms.uLoad.value = 1
      } else if (path.tagName == 'VIDEO') {
        if (import.meta.env.DEV) {
          url = vidsmall;
        }
        let vidclone = video.cloneNode();
        src = await this.loadVideo(vidclone, url);
        path.classList.add('Ldd');
        this.meshes[i].loaded = 1;

        this.meshes[i].vid = vidclone;
        this.meshes[i].texture.image = src;

        if (this.meshes[i].texture.image.readyState >= this.meshes[i].texture.image.HAVE_ENOUGH_DATA) {
          if (!this.meshes[i].texture.image) this.meshes[i].texture.image = this.meshes[i].texture.image;

          this.meshes[i].texture.needsUpdate = true;
        }

        this.meshes[i].mesh.program.uniforms.tMap.value = this.meshes[i].texture;
        this.meshes[i].mesh.program.uniforms.uTextureSize.value = [
          this.meshes[i].el.querySelector('video').width,
          this.meshes[i].el.querySelector('video').height,
        ];
        // this.meshes[i].mesh.program.uniforms.uLoad.value = 1
      }

      gsap.to(this.meshes[i].mesh.program.uniforms.uLoad, { value: 1, duration: 0.6, delay: 1, ease: 'power2.inOut' });
      this.els[i].classList.add('ldd');
    }
  }

  update(time, speed, pos) {
    if (!this.meshes) {
      return false;
    }
    if (this.isready == 0 || this.active < 0) {
      return false;
    }

    if (this.onanim != -1) {
      this.updateY(pos, true);
      this.updateX(0, this.onanim);
      this.updateScale(this.onanim);
    } else {
      this.updateY(pos);
    }

    if (this.boundh) {
      this.meshes[this.boundh[2]].qck(this.boundh[4] * this.meshes[this.boundh[2]].mult);
    }

    this.renderer.render({ scene: this.scene, camera: this.camera });
    return true;
  }
  initEvents() {
    document.querySelector('.cnt_g').onclick = async (e) => {
      if (this.isload == 1 || e.target.closest('button')) {
        return false;
      }

      this.isload = 1;

      const animsel = gsap.timeline({
        paused: true,
        // onStart:()=>{
        //   this.onanim = this.onsel
        // },
        onUpdate: (a) => {
          // this.meshes.mesh.program.uniforms.uZoom.value[0]
          // this.meshes.mesh.program.uniforms.uZoom.value[1]
        },
        onComplete: () => {},
      });
      if (this.onsel != undefined) {
        this.onanim = 0;
        animsel
          .to(this.meshes[this.onsel].mesh.program.uniforms.uZoom, { value: 1, duration: 0.9, ease: 'power2.inOut' }, 0)
          .to(this.meshes[this.onsel], { multx: 1, multy: 1, duration: 0.9, ease: 'power2.inOut' }, 0)
          .to(
            this.meshes[this.onsel].el,
            { '--scx': 1, '--scy': 1, xPercent: 0, duration: 0.9, ease: 'power2.inOut' },
            0
          );

        animsel;
        // .to(this.meshes[this.onsel].el.querySelector('.el_b'),{paddingTop:0+'rem',duration:.9,ease:'power2.inOut'},0)

        if (this.device > 1) {
        } else {
          if (this.meshes[this.onsel].id == 0) {
            if (this.meshes[this.onsel + 1])
              animsel.to(this.meshes[this.onsel + 1].el, { xPercent: 0, duration: 0.6, ease: 'power2.inOut' }, 0);
            if (this.meshes[this.onsel + 2])
              animsel.to(this.meshes[this.onsel + 2].el, { xPercent: 0, duration: 0.6, ease: 'power2.inOut' }, 0);
          } else if (
            this.meshes[this.onsel].id == 1 ||
            this.meshes[this.onsel].id == 4 ||
            this.meshes[this.onsel].id == 5
          ) {
            if (this.meshes[this.onsel + 1])
              animsel.to(this.meshes[this.onsel + 1].el, { xPercent: 0, duration: 0.9, ease: 'power2.inOut' }, 0);
          } else if ((this.meshes[this.onsel].id == 2) | (this.meshes[this.onsel].id == 9)) {
            animsel.to(this.meshes[this.onsel - 1].el, { xPercent: 0, duration: 0.9, ease: 'power2.inOut' }, 0);
          } else if (this.meshes[this.onsel].id == 3) {
            animsel
              .to(this.meshes[this.onsel - 1].el, { xPercent: 0, duration: 0.9, ease: 'power2.inOut' }, 0)
              .to(this.meshes[this.onsel - 2].el, { xPercent: 0, duration: 0.9, ease: 'power2.inOut' }, 0);
          } else if (this.meshes[this.onsel].id == 6 || this.meshes[this.onsel].id == 7) {
            // animsel
            // .to(this.meshes[this.onsel-1].el,{xPercent:0,duration:.9,ease:'power2.inOut'},0)
            // .to(this.meshes[this.onsel-2].el,{xPercent:0,duration:.9,ease:'power2.inOut'},0)
          }
        }
      }

      if (this.onsel != undefined) {
        await animsel.play();
      }
      delete this.onsel;
      delete this.isload;
      this.onanim = -1;
    };

    for (let [i, a] of this.els.entries()) {
      let b = a.querySelector('.el_b .Awrite');
      this.rev.detail.state = 0;
      this.rev.detail.el = b;
      document.dispatchEvent(this.rev);

      a.querySelector('.el_md').onclick = async () => {
        if (this.isload) {
          return false;
        }

        let wait = 0;
        this.isload = 1;
        this.onanim = i;

        const animsel = gsap.timeline({
          paused: true,
          // onStart:()=>{
          //   this.onanim = this.onsel
          // },
          onUpdate: (a) => {
            // this.meshes.mesh.program.uniforms.uZoom.value[0]
            // this.meshes.mesh.program.uniforms.uZoom.value[1]
          },
          onComplete: () => {},
        });

        if (this.onsel != undefined) {
          // .to(this.meshes[this.onsel].mesh.program.uniforms.uZoom,{value:1,duration:.9,ease:'power2.inOut'},0)
          // .to(this.meshes[this.onsel],{multx:1,multy:1,duration:.9,ease:'power2.inOut'},0)
          // .to(this.meshes[this.onsel].el,{'--scx':1,'--scy':1,xPercent:0,duration:.9,ease:'power2.inOut'},0)

          if (this.onsel != -1 && this.meshes[this.onsel].row == this.meshes[i].row) {
            // console.log('aqui, claro!'+this.meshes[this.onsel].el.querySelector('.el_md .cv').clientHeight)
            if (this.onsel != i) {
              animsel
                .set(this.meshes[i].el, { marginBottom: 16.725 * 1.26 + 'rem', ease: 'power2.inOut' }, 0)
                .set(this.meshes[i].el, { marginBottom: '', ease: 'power2.inOut' }, 2.4);
              // .set(this.meshes[this.onsel].el,{'--scx':1,'--scy':1,xPercent:0,duration:.9,ease:'power2.inOut'},0)
            }
            animsel
              .to(
                this.meshes[this.onsel].mesh.program.uniforms.uZoom,
                { value: 1, duration: 0.9, ease: 'power2.inOut' },
                0
              )
              .to(this.meshes[this.onsel], { multx: 1, multy: 1, duration: 0.9, ease: 'power2.inOut' }, 0)
              .to(
                this.meshes[this.onsel].el,
                { '--scx': 1, '--scy': 1, xPercent: 0, duration: 0.9, ease: 'power2.inOut' },
                0
              );

            wait = 0.45;
          } else {
            animsel
              .set(this.meshes[this.onsel].el, { marginBottom: '', ease: 'power2.inOut' }, 0)
              .to(
                this.meshes[this.onsel].mesh.program.uniforms.uZoom,
                { value: 1, duration: 0.9, ease: 'power2.inOut' },
                0
              )
              .to(this.meshes[this.onsel], { multx: 1, multy: 1, duration: 0.9, ease: 'power2.inOut' }, 0)
              .to(
                this.meshes[this.onsel].el,
                { '--scx': 1, '--scy': 1, xPercent: 0, duration: 0.9, ease: 'power2.inOut' },
                0
              );

            // .to(this.meshes[this.onsel].el.querySelector('.el_b'),{paddingTop:0+'rem',duration:.9,ease:'power2.inOut'},0)
          }
          if (this.device > 1) {
          } else {
            if (this.meshes[this.onsel].id == 0) {
              if (this.meshes[this.onsel + 1])
                animsel.to(this.meshes[this.onsel + 1].el, { xPercent: 0, duration: 0.6, ease: 'power2.inOut' }, 0);
              if (this.meshes[this.onsel + 2])
                animsel.to(this.meshes[this.onsel + 2].el, { xPercent: 0, duration: 0.6, ease: 'power2.inOut' }, 0);
            } else if (
              this.meshes[this.onsel].id == 1 ||
              this.meshes[this.onsel].id == 4 ||
              this.meshes[this.onsel].id == 5
            ) {
              if (this.meshes[this.onsel + 1])
                animsel.to(this.meshes[this.onsel + 1].el, { xPercent: 0, duration: 0.9, ease: 'power2.inOut' }, 0);
            } else if ((this.meshes[this.onsel].id == 2) | (this.meshes[this.onsel].id == 9)) {
              animsel.to(this.meshes[this.onsel - 1].el, { xPercent: 0, duration: 0.9, ease: 'power2.inOut' }, 0);
            } else if (this.meshes[this.onsel].id == 3) {
              animsel
                .to(this.meshes[this.onsel - 1].el, { xPercent: 0, duration: 0.9, ease: 'power2.inOut' }, 0)
                .to(this.meshes[this.onsel - 2].el, { xPercent: 0, duration: 0.9, ease: 'power2.inOut' }, 0);
            } else if (this.meshes[this.onsel].id == 6 || this.meshes[this.onsel].id == 7) {
              // animsel
              // .to(this.meshes[this.onsel-1].el,{xPercent:0,duration:.9,ease:'power2.inOut'},0)
              // .to(this.meshes[this.onsel-2].el,{xPercent:0,duration:.9,ease:'power2.inOut'},0)
            }
          }
        }

        if (this.onsel != i) {
          let multi = 0.76;
          const anim = gsap
            .timeline({
              paused: true,
              onUpdate: (a) => {
                // this.meshes.mesh.program.uniformss.uZoom.value[0]
                // this.meshes.mesh.program.uniformss.uZoom.value[1]
              },
              onComplete: () => {
                this.onsel = this.onanim;
                this.onanim = -1;

                delete this.isload;
              },
            })
            .to(this.meshes[i].mesh.program.uniforms.uZoom, { value: 2, duration: 0.9, ease: 'power2.inOut' }, wait)
            .to(this.meshes[i], { mult: -6, duration: 0.25, ease: 'none' }, wait)
            .to(this.meshes[i], { mult: 1, duration: 0.35, ease: 'none' }, wait + 0.25);
          // BASE
          // .to(this.meshes[i],{multx:2.55,multy:2.26,despx:despx,duration:1.2,ease:'power2.inOut'},0)
          // // .to(this.meshes[i],{multy:2.26,despy:despy,duration:1.2,ease:'power2.out'},.3)
          // .to(this.meshes[i].el,{'--scx':2.55,'--scy':2.26,duration:1.2,ease:'power2.inOut'},0)
          // .to(this.meshes[i].el.querySelector('.el_b'),{paddingTop:21.4+'rem',duration:1.2,ease:'power2.inOut'},0)

          if (wait == 0) {
            anim;
            // .to(this.meshes[i].el.querySelector('.el_b'),{paddingTop:21.4+'rem',duration:1.2,ease:'power2.inOut'},0)
          }

          if (this.device > 1) {
            let x = 0;
            if (i % 2 == 0) {
              x = this.calculator[2] * -100;
            }
            anim
              .to(
                this.meshes[i],
                { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                wait * multi
              )
              .to(
                this.meshes[i].el,
                {
                  '--scx': this.calculator[0],
                  '--scy': this.calculator[1],
                  xPercent: x,
                  duration: 1.2,
                  ease: 'power2.inOut',
                },
                wait * multi
              );
          } else {
            if (this.meshes[i].id == 0) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  { '--scx': this.calculator[0], '--scy': this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                );

              if (this.meshes[i + 1])
                anim.to(this.meshes[i + 1].el, { xPercent: 52, duration: 0.9, ease: 'power2.inOut' }, wait);
              if (this.meshes[i + 2])
                anim.to(this.meshes[i + 2].el, { xPercent: 52, duration: 0.9, ease: 'power2.inOut' }, wait);
            } else if (this.meshes[i].id == 1 || this.meshes[i].id == 4) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  {
                    '--scx': this.calculator[0],
                    '--scy': this.calculator[1],
                    xPercent: -104,
                    duration: 1.2,
                    ease: 'power2.inOut',
                  },
                  wait * multi
                );

              if (this.meshes[i + 1])
                anim.to(this.meshes[i + 1].el, { xPercent: 50, duration: 0.9, ease: 'power2.inOut' }, wait);
            } else if (this.meshes[i].id == 2) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  {
                    '--scx': this.calculator[0],
                    '--scy': this.calculator[1],
                    xPercent: -104,
                    duration: 1.2,
                    ease: 'power2.inOut',
                  },
                  wait * multi
                )

                .to(this.meshes[i - 1].el, { xPercent: -104, duration: 0.9, ease: 'power2.inOut' }, wait);
            } else if (this.meshes[i].id == 3) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  {
                    '--scx': this.calculator[0],
                    '--scy': this.calculator[1],
                    xPercent: -156,
                    duration: 1.2,
                    ease: 'power2.inOut',
                  },
                  wait * multi
                )

                .to(this.meshes[i - 2].el, { xPercent: -52, duration: 0.9, ease: 'power2.inOut' }, wait)
                .to(this.meshes[i - 1].el, { xPercent: -52, duration: 0.9, ease: 'power2.inOut' }, wait);
            } else if (this.meshes[i].id == 5) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  { '--scx': this.calculator[0], '--scy': this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                );

              if (this.meshes[i + 1])
                anim.to(this.meshes[i + 1].el, { xPercent: 50, duration: 0.9, ease: 'power2.inOut' }, wait);
            } else if (this.meshes[i].id == 6 || this.meshes[i].id == 11) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  {
                    '--scx': this.calculator[0],
                    '--scy': this.calculator[1],
                    xPercent: -104,
                    duration: 1.2,
                    ease: 'power2.inOut',
                  },
                  wait * multi
                );
            } else if (this.meshes[i].id == 7 || this.meshes[i].id == 10) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  { '--scx': this.calculator[0], '--scy': this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                );
            } else if (this.meshes[i].id == 8) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  {
                    '--scx': this.calculator[0],
                    '--scy': this.calculator[1],
                    xPercent: -156,
                    duration: 1.2,
                    ease: 'power2.inOut',
                  },
                  wait * multi
                );
            } else if (this.meshes[i].id == 9) {
              anim
                .to(
                  this.meshes[i],
                  { multx: this.calculator[0], multy: this.calculator[1], duration: 1.2, ease: 'power2.inOut' },
                  wait * multi
                )
                // .to(this.meshes[i],{multy:this.calculator[1],despy:despy,duration:1.2,ease:'power2.out'},.3)
                .to(
                  this.meshes[i].el,
                  {
                    '--scx': this.calculator[0],
                    '--scy': this.calculator[1],
                    xPercent: -156,
                    duration: 1.2,
                    ease: 'power2.inOut',
                  },
                  wait * multi
                )
                .to(this.meshes[i - 1].el, { xPercent: -52, duration: 0.9, ease: 'power2.inOut' }, wait);
            }
          }
          if (this.onsel != undefined) {
            animsel.play();
          }
          anim.play();
        } else {
          if (this.onsel != undefined) {
            await animsel.play();
            console.log(animsel);
          }
          delete this.onsel;
          delete this.isload;
          this.onanim = -1;
        }
      };
      this.enFn = (el, e, i) => {
        const bound = el.getBoundingClientRect();
        this.boundh = [bound.x, bound.width, i, 0, 0];
      };

      this.mvFn = (qck, e) => {
        if (!this.boundh) {
          return false;
        }

        this.boundh[3] = e.touches ? e.touches[0].clientX : e.clientX;
        // this.coords[1] = e.touches ? e.touches[0].clientY : e.clientY

        // console.log(this.coords)
        // console.log(this.viewport)
        //MAP SCREEN
        // this.norm[0] = this.map(const coords, 0, this.viewport[0], -1, 1)
        // this.norm[1] = this.map(this.coords[1], 0, this.viewport[1], 1, -1)

        const norm = (this.boundh[3] - this.boundh[0]) / this.boundh[1];
        //  this.norm[1] = (this.coords[1] - this.bound[1])/this.bound[3]

        this.boundh[4] = norm - 0.5;

        //  this.norm[1]-=.5
      };

      this.lvFn = (qck, e) => {
        delete this.boundh;
        qck(0);
        // this.norm[1] = 0
      };

      a.querySelector('.el_md .cv').onmouseenter = (e) => this.enFn(a.querySelector('.el_md .cv'), e, i);
      a.querySelector('.el_md .cv').onmousemove = (e) => this.mvFn(this.meshes[i].qck, e);
      a.querySelector('.el_md .cv').onmouseleave = (e) => this.lvFn(this.meshes[i].qck, e);

      this.meshes[i].animin = gsap.timeline({
        paused: true,
        onUpdate: () => {},
      });
      let params = [0, 3];
      let splits = b.querySelectorAll('.char');
      let times = [0.22, 0.05, 0.16, 0.05, 0.016];
      this.meshes[i].animin.set(b, { opacity: 1 }, 0);
      for (let [h, c] of splits.entries()) {
        let n = c.querySelector('.n');

        this.meshes[i].animin
          .set(c, { opacity: 1 }, 0)
          .to(
            n,
            { opacity: 1, duration: times[0], immediateRender: false, ease: 'power4.inOut' },
            h * times[1] + params[0]
          );

        for (let [z, f] of c.querySelectorAll('.f').entries()) {
          this.meshes[i].animin
            .set(f, { opacity: 0, display: 'block' }, 0)
            .fromTo(
              f,
              { scaleX: 1, opacity: 1 },
              { scaleX: 0, opacity: 0, immediateRender: false, duration: times[2], ease: 'power4.inOut' },
              params[0] + (h * times[3] + (1 + z) * times[4])
            )
            .set(f, { display: 'none' }, '>');
        }
      }

      a.onmouseenter = () => {
        this.meshes[i].animin.pause();
        this.meshes[i].animin.timeScale(1);
        this.meshes[i].animin.progress(0);
        this.meshes[i].animin.play();
      };

      // this.animout = gsap.timeline({
      //   paused:true,
      //   onComplete:()=>{

      //   }
      // })
      // splits = [...splits]

      // splits = splits.reverse()

      // for(let [i,c] of splits.entries()){
      //   let n = c.querySelector('.n')
      //   let f = c.querySelector('.f')
      //   // anim.set(n,{opacity:0},0)
      //   // if((i*.04) + .2 > .4){
      //   //   break
      //   // }
      //   this.animout
      //   .to(f,{opacity:1,scaleX:1,duration:.12,immediateRender:false,ease:'power4.inOut'},(i*.04))
      //   .to(b,{opacity:0,duration:.2,immediateRender:false,ease:'power4.inOut'},(i*.04))

      // }

      a.onmouseleave = () => {
        this.meshes[i].animin.pause();
        this.meshes[i].animin.timeScale(2.4);
        this.meshes[i].animin.reverse();
        // this.animin.pause()
        // // gsap.killTweensOf(this.animin)

        // this.animout = gsap.timeline({
        // paused:true,
        //     onComplete:()=>{

        //     }
        //   })

        //   let splits = b.querySelectorAll('.char')
        //   splits = [...splits]
        //   splits = splits.reverse()

        //   for(let [i,c] of splits.entries()){
        //     let n = c.querySelector('.n')
        //     let f = c.querySelector('.f')
        //     // anim.set(n,{opacity:0},0)
        //     // if((i*.04) + .2 > .4){
        //     //   break
        //     // }
        //     this.animout
        //     .to(f,{opacity:1,scaleX:1,duration:.12,immediateRender:false,ease:'power4.inOut'},(i*.04))
        //     .to(c,{opacity:0,duration:.2,immediateRender:false,ease:'power4.inOut'},(i*.04))

        //   }

        // this.animout.play()
      };
    }
  }
  removeEvents() {
    this.active = -2;

    delete this.boundh;

    let anim = gsap.timeline({
      onUpdate: () => {
        this.renderer.render({ scene: this.scene, camera: this.camera });
      },
      onComplete: () => {
        this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
        this.canvas.remove();
      },
    });

    for (let [i, a] of this.mmap.entries()) {
      // anim.to(this.meshes[a].mesh.program.uniforms.uLoad,{value:0,duration:.4,ease:'power2.inOut'},.4)
      anim.to(this.meshes[a].mesh.program.uniforms.uMouse, { value: -1.5, duration: 1, ease: 'power2.inOut' }, 0);
      this.meshes[a].el.classList.remove('act');
    }
    anim.to(
      this.canvas,
      {
        webkitFilter: 'blur(' + 6 + 'px)',
        filter: 'blur(' + 6 + 'px)',
        opacity: 0,
        duration: 0.6,
        ease: 'power2.inOut',
      },
      0.4
    );
  }
  onResize(viewport, screen) {
    this.viewport = [viewport.w, viewport.h];
    this.screen = [screen.w, screen.h];

    let bound = this.sizer.getBoundingClientRect();
    this.bound = [bound.x, bound.y, bound.width, bound.height];

    this.renderer.setSize(window.innerWidth, window.innerHeight);

    this.camera.perspective({
      aspect: this.renderer.gl.canvas.clientWidth / this.renderer.gl.canvas.clientHeight,
    });

    this.camera.fov = 45;
    this.camera.position.set(0, 0, 7);

    const fov = this.camera.fov * (Math.PI / 180);
    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;
    const width = height * this.camera.aspect;

    this.viewport = [width, height];

    this.w = window.innerWidth;
    this.h = window.innerHeight;

    this.updateScale();
    this.updateX();
    this.updateY(window.scrollY, true);
  }

  lerp(value1, value2, t) {
    return value1 * (1 - t) + value2 * t;
  }
}

Base.prototype.check = check;
Base.prototype.checkEl = checkEl;
Base.prototype.start = start;
Base.prototype.stop = stop;
Base.prototype.updateX = updateX;
Base.prototype.updateY = updateY;
Base.prototype.updateAnim = updateAnim;
Base.prototype.updateScale = updateScale;

export default Base;


=== FILE END: src/app/gl/effects/grid/base.js ===



=== FILE START: src/app/gl/effects/grid/position.js ===

export function check(entry) {
  let vis = false;
  vis = entry.isIntersecting;

  if (entry.target.classList.contains('Oi-pgel')) {
    this.checkEl(entry);

    return true;
  }

  if (entry.isIntersecting == undefined) {
    return vis;
  }
  if (vis == 1) {
    this.start();
  } else if (vis == 0) {
    this.stop();
  }

  return vis;
}

export function checkEl(entry) {
  if (entry.isIntersecting == true) {
    this.meshes[parseInt(entry.target.dataset.pg)].y =
      this.meshes[parseInt(entry.target.dataset.pg)].el.querySelector('.cv').getBoundingClientRect().y + window.scrollY;
    this.meshes[parseInt(entry.target.dataset.pg)].el.classList.add('act');
    this.mmap.add(this.meshes[parseInt(entry.target.dataset.pg)].pos);
    if (this.meshes[parseInt(entry.target.dataset.pg)].vid) {
      // this.meshes[parseInt(entry.target.dataset.pg)].vid.play()
      this.meshes[parseInt(entry.target.dataset.pg)].texture.image.play();
    }
  } else {
    if (this.meshes[parseInt(entry.target.dataset.pg)].vid) {
      this.meshes[parseInt(entry.target.dataset.pg)].texture.image.pause();
    }
    if (this.mmap.has(parseInt(entry.target.dataset.pg))) {
    }
  }
}
export function start() {
  if (this.active == 1) {
    return false;
  }
  // if(this.mesh){
  //   this.mesh.visible = true
  // }

  this.active = 1;
  this.updateX();
  this.updateY();
  this.updateScale();
}

export function stop() {
  if (this.active == 0 || this.active == -1) {
    return false;
  }

  // if(this.mesh){
  //   this.mesh.visible = false
  // }

  if (this.isv) {
    this.media.pause();
  }
  this.active = 0;
}
export function updateX(x = 0, anim = null) {
  if (!this.meshes) return false;

  if (anim == null) {
    for (let [i, a] of this.meshes.entries()) {
      x = a.el.querySelector('.cv').getBoundingClientRect().x;
      a.mesh.position.x = -(this.viewport[0] / 2) + a.mesh.scale.x / 2 + (x / this.screen[0]) * this.viewport[0];
    }
  } else {
    // x = this.meshes[anim].el.querySelector('.Oi').getBoundingClientRect().x
    // this.meshes[anim].mesh.position.x = -(this.viewport[0] / 2) + (this.meshes[anim].mesh.scale.x / 2) + ((x) / this.screen[0]) * this.viewport[0]

    for (let [i, a] of this.mmap.entries()) {
      const bound = this.meshes[a].el.querySelector('.cv').getBoundingClientRect();
      x = bound.x;
      this.meshes[a].mesh.position.x =
        -(this.viewport[0] / 2) + this.meshes[a].mesh.scale.x / 2 + (x / this.screen[0]) * this.viewport[0];
      if (this.boundh) {
        if (this.boundh[2] == a) {
          this.boundh[0] = bound.x;
          this.boundh[1] = bound.width;
        }
      }
    }

    // if(mover.id == 0){
    //   let dam = anim+1

    //   x = this.meshes[dam].el.querySelector('.Oi').getBoundingClientRect().x
    //   this.meshes[dam].mesh.position.x = -(this.viewport[0] / 2) + (this.meshes[dam].mesh.scale.x / 2) + ((x) / this.screen[0]) * this.viewport[0]

    //   dam = anim+2
    //   x = this.meshes[dam].el.querySelector('.Oi').getBoundingClientRect().x
    //   this.meshes[dam].mesh.position.x = -(this.viewport[0] / 2) + (this.meshes[dam].mesh.scale.x / 2) + ((x) / this.screen[0]) * this.viewport[0]

    //   // x = this.meshes[anim+1].el.querySelector('.Oi').getBoundingClientRect().x
    //   // this.meshes[anim+1].mesh.position.x = -(this.viewport[0] / 2) + (this.meshes[anim+1].mesh.scale.x / 2) + ((x) / this.screen[0]) * this.viewport[0]

    // }
  }
  // this.mesh.position.x = -(this.viewport[0] / 2) + (this.mesh.scale.x / 2) + ((this.bound[0] - x) / this.screen[0]) * this.viewport[0]
}
export function updateY(y = 0, all = null) {
  if (!this.meshes) return false;
  if (all != null) {
    for (let [i, a] of this.meshes.entries()) {
      a.y = a.el.querySelector('.cv').getBoundingClientRect().y + y;
      let ypos = a.y;
      a.mesh.position.y = this.viewport[1] / 2 - a.mesh.scale.y / 2 - ((ypos - y) / this.screen[1]) * this.viewport[1];
    }
  } else {
    for (let [i, a] of this.mmap.entries()) {
      // PARA LOS VIDEOS
      if (this.meshes[a].vid) {
        if (this.meshes[a].texture.image.readyState >= this.meshes[a].texture.image.HAVE_ENOUGH_DATA) {
          if (!this.meshes[a].texture.image) this.meshes[a].texture.image = this.meshes[a].texture.image;

          this.meshes[a].texture.needsUpdate = true;
        }
      }
      // console.log(a)
      if (this.onanim != -1) {
        let ypos = (this.meshes[a].y = this.meshes[a].el.querySelector('.Oi').getBoundingClientRect().y + y);
      }
      let ypos = this.meshes[a].y;
      this.meshes[a].mesh.position.y =
        this.viewport[1] / 2 - this.meshes[a].mesh.scale.y / 2 - ((ypos - y) / this.screen[1]) * this.viewport[1];
    }
  }

  // if(this.ctr.stop != 1){
  //   this.ctr.current = y - this.ctr.start
  //   this.ctr.current = clamp(0, this.ctr.limit, this.ctr.current)
  // }
}
export function updateAnim() {
  // this.ctr.progt = (this.ctr.current  / this.ctr.limit).toFixed(3)
  // this.ctr.prog = lerp(this.ctr.prog , this.ctr.progt , this.ctr.lerp)
  // this.animctr.progress(this.ctr.prog)
}

export function updateScale(anim = null) {
  if (!this.meshes) return false;
  if (anim == null) {
    for (let [i, a] of this.meshes.entries()) {
      a.mesh.scale.x = (this.viewport[0] * (this.bound[2] * this.meshes[i].multx)) / this.screen[0];
      a.mesh.scale.y = (this.viewport[1] * (this.bound[3] * this.meshes[i].multy)) / this.screen[1];
    }
  } else {
    // Update logic to ensure compatibility with the portfolio component
    // Ensure all event handling and animation logic is consistent with the new structure
    for (let [i, a] of this.mmap.entries()) {
      this.meshes[a].mesh.scale.x = (this.viewport[0] * (this.bound[2] * this.meshes[a].multx)) / this.screen[0];
      this.meshes[a].mesh.scale.y = (this.viewport[1] * (this.bound[3] * this.meshes[a].multy)) / this.screen[1];

      if (this.boundh) {
      }

      this.meshes[a].mesh.program.uniforms.uCover.value = [
        this.bound[2] * this.meshes[a].multx,
        this.bound[3] * this.meshes[a].multy,
      ];

      // if(this.boundh){
      //   if(this.boundh[2] == a){
      //     this.boundh[1]*=this.meshes[a].multx
      //   }
      // }
    }

    // this.meshes[this.onanim].mesh.scale.x = this.viewport[0] * (this.bound[2] * this.meshes[this.onanim].multx)/ this.screen[0]
    // this.meshes[this.onanim].mesh.scale.y = this.viewport[1] * (this.bound[3] * this.meshes[this.onanim].multy) / this.screen[1]

    // this.meshes[this.onanim].mesh.program.uniforms.uCover.value = [
    // this.bound[2] * this.meshes[this.onanim].multx,
    // this.bound[3] * this.meshes[this.onanim].multy
    // ]
  }
}


=== FILE END: src/app/gl/effects/grid/position.js ===



=== FILE START: src/app/error/page.js ===

"use client";

import Page from "@/lib/page/pagemain";
import Intro from "./intro";

class ErrorPage extends Page {
  constructor(main) {
    super(main);
  }

  async create(content, main, temp = undefined) {
    super.create(content, main);

    if (temp !== undefined) {
      document.querySelector("#content").insertAdjacentHTML("afterbegin", temp);
    } else {
      const data = await fetch(`${main.base}/wp-json/wp/v2/pages/${content.dataset.id}`)
        .then(res => res.json());
      document.querySelector("#content").insertAdjacentHTML("afterbegin", data.csskfields.main);
    }

    this.el = document.querySelector("main");

    this.DOM = { el: this.el };

    await this.createComps();
    await this.createIos();
    await this.getReady();
  }
}

export default ErrorPage;

=== FILE END: src/app/error/page.js ===



=== FILE START: src/app/globals.css ===

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}


=== FILE END: src/app/globals.css ===



=== FILE START: src/components/Mouse.jsx ===

// From components🦾🦾🦾/Mouse🐭/index.js

=== FILE END: src/components/Mouse.jsx ===



=== FILE START: src/components/TerrainCanvas.jsx ===



=== FILE END: src/components/TerrainCanvas.jsx ===



=== FILE START: src/components/FireCanvas.jsx ===

import { useEffect, useRef } from 'react';
import { Renderer } from 'ogl';

export default function FireCanvas() {
  const canvasRef = useRef();

  useEffect(() => {
    const renderer = new Renderer();
    canvasRef.current.appendChild(renderer.gl.canvas);
  }, []);

  return <div ref={canvasRef}></div>;
}


=== FILE END: src/components/FireCanvas.jsx ===



=== FILE START: src/components/TitleCanvas.jsx ===



=== FILE END: src/components/TitleCanvas.jsx ===



=== FILE START: src/components/AboutCanvas.jsx ===



=== FILE END: src/components/AboutCanvas.jsx ===



=== FILE START: src/components/Loader.jsx ===

// From components🦾🦾🦾/Loader⏳/index.js

=== FILE END: src/components/Loader.jsx ===



=== FILE START: src/components/GridCanvas.jsx ===



=== FILE END: src/components/GridCanvas.jsx ===



=== FILE START: src/components/SlidesCanvas.jsx ===



=== FILE END: src/components/SlidesCanvas.jsx ===



=== FILE START: src/components/Nav.jsx ===

// From components🦾🦾🦾/Nav🌤️/index.js

=== FILE END: src/components/Nav.jsx ===



=== FILE START: src/components/ImageCanvas.jsx ===



=== FILE END: src/components/ImageCanvas.jsx ===



=== FILE START: src/components/LoaderCanvas.jsx ===

import { useEffect, useRef } from 'react';
import { Renderer, Triangle, Program } from 'ogl';
import LoaderFragmentShader from '@/public/shaders/loader.fragment.glsl';

export default function Loader() {
  const canvasRef = useRef(null);

  useEffect(() => {
    const renderer = new Renderer({ canvas: canvasRef.current });
    const gl = renderer.gl;
    const geometry = new Triangle(gl);
    const program = new Program(gl, { fragment: LoaderFragmentShader });

    // Setup WebGL loop
    const mesh = new Mesh(gl, { geometry, program });
    function animate() {
      requestAnimationFrame(animate);
      renderer.render({ scene: mesh });
    }
    animate();
  }, []);

  return <canvas ref={canvasRef} />;
}


=== FILE END: src/components/LoaderCanvas.jsx ===



=== FILE START: src/components/RollCanvas.jsx ===



=== FILE END: src/components/RollCanvas.jsx ===



=== FILE START: src/public/shaders/roll/roll_single.vertex.glsl ===

attribute vec2 uv;
attribute vec2 position;

uniform sampler2D tMap;
uniform sampler2D tMap2;
uniform vec2 uTextureSize;
uniform vec2 uTextureSize2;
uniform vec2 uCover;
uniform float uChange;
uniform float uStart;
uniform float uEnd;
uniform float uPos;

varying vec2 vUv;
varying vec2 vUv1;
varying vec2 vUv2;

vec2 resizeUvCover(vec2 uv, vec2 size, vec2 resolution) {
  vec2 ratio = vec2(
    min(resolution.x / resolution.y / (size.x / size.y), 1.0),
    min(resolution.y / resolution.x / (size.y / size.x), 1.0)
  );

  return vec2(uv.x * ratio.x + (1.0 - ratio.x) * 0.5, uv.y * ratio.y + (1.0 - ratio.y) * 0.5);
}
void main() {
  //  + ((1.2 -  uStart) * 2.4)
  vUv = uv;
  vUv1 = resizeUvCover(vec2(uv.x, uv.y), vec2(uTextureSize.x, uTextureSize.y), vec2(uCover.x, uCover.y));
  vUv2 = resizeUvCover(
    vec2(uv.x, uv.y),
    vec2(uTextureSize2.x * (1.0 - uEnd), uTextureSize2.y),
    vec2(uCover.x, uCover.y)
  );

  gl_Position = vec4(position, 0, 1);
}


=== FILE END: src/public/shaders/roll/roll_single.vertex.glsl ===



=== FILE START: src/public/shaders/roll/roll_single.fragment.glsl ===

precision highp float;
uniform float uStart;
uniform float uEnd;
uniform float uPos;
uniform float uChange;
uniform vec2 uCover;
uniform vec2 uTextureSize;
uniform vec2 uTextureSize2;
uniform sampler2D tMap;
uniform sampler2D tMap2;

varying vec2 vUv;
varying vec2 vUv1;
varying vec2 vUv2;

void main() {
  // float timer = sin(uTime * .0005);
  float timer = uStart;

  float mouse = 0.0;

  mouse += timer * 2.8;
  float cols = 8.0;
  vec2 U = vUv1,
    P = vec2(cols, cols),
    C = floor(U * P) / P;
  float centpos = vUv1.x + mouse;
  centpos += -0.5 + mouse * 0.4;
  centpos *= 2.0;
  centpos = abs(centpos);

  float cent = 1.0 - vUv1.x;

  cent += -0.5 + mouse * 0.4;
  cent *= 2.0;

  cent = abs(cent);

  float umod = floor(cent * P.x) / P.x;
  U.x -= umod;

  U.x += mouse * (umod * 0.2);
  U.x += centpos * 1.2 * (mouse * (umod * 0.1));
  U.x += umod;

  timer = uEnd;

  mouse = 0.0;

  mouse -= timer * 2.8;

  vec2 I = vUv2,
    Q = vec2(cols, cols),
    D = floor(I * P) / P;

  float centposi = vUv2.x + mouse;
  centposi += -0.5 + mouse * 0.4;
  centposi *= 2.0;
  centposi = abs(centposi);

  float centi = 1.0 - vUv2.x;

  centi += -0.5 + mouse * 0.4;
  centi *= 2.0;

  centi = abs(centi);

  float imod = floor(centi * Q.x) / Q.x;

  I.x -= imod;
  I.x += mouse * (imod * 0.2);
  I.x += centpos * 1.2 * (mouse * (imod * 0.1));
  I.x += imod;

  float r = texture2D(tMap, vec2(U.x, U.y)).r;
  float g = texture2D(tMap, vec2(U.x, U.y)).g;
  float b = texture2D(tMap, vec2(U.x, U.y)).b;

  vec4 tex1 = vec4(r, g, b, 1.0);

  r = texture2D(tMap2, vec2(I.x, I.y)).r;
  g = texture2D(tMap2, vec2(I.x, I.y)).g;
  b = texture2D(tMap2, vec2(I.x, I.y)).b;

  vec4 tex2 = vec4(r, g, b, 1.0);

  // gl_FragColor.r = step(abs(uStart), fract(cols * vUv.x * -1.));

  // float change = 1. - step(uChange, fract(cols * ((uChange * .2) - vUv.x)));
  float change = 1.0 - step(uChange, fract(-1.0 * vUv.x));

  gl_FragColor = mix(tex1, tex2, change);
}

// blury (Gaussian Blur Simple and Fast) https://www.shadertoy.com/view/Xltfzj
// blur (Pseudo Gaussian Blur) https://www.shadertoy.com/view/Mtl3Rj
// 2D (lygia/filter/gaussianBlur/2D) - https://lygia.xyz/filter/gaussianBlur/2D



=== FILE END: src/public/shaders/roll/roll_single.fragment.glsl ===



=== FILE START: src/public/shaders/title/title_msdf.fragment.glsl ===

#version 300 es
precision highp float;
#define varying in
#define texture2D texture
#define gl_FragColor FragColor
#define numTextures PITO
out vec4 FragColor;

uniform sampler2D tMap;
uniform float uTime;
uniform vec2 uScreen;
uniform vec2 uMouse;

uniform float uPower;
uniform float uCols;
uniform float uColor;
uniform float uStart;
uniform float uKey;
uniform float uPowers[numTextures];


varying vec2 vUv;
varying vec2 vUvR;

varying vec3 vPos;
varying float vId;
varying vec3 vIndex;

// https://www.shadertoy.com/view/XsfSRr

float ripple(float uv, float time, float prog) {
        float distance = length((uv ) + time  );
        return tan(distance * (prog) ) * (-.01);

        
      }

void main() {




    // uv.y += sin(uTime*.0005) * (vId.x + 1. )*.014;
    float time = abs(sin(uTime * 0.002));
    float time2 = (sin(uTime * 0.001));
    float time3 = abs( sin(uTime * 0.001) ) ;
    float rippleUV = 0.;
    float cols = uCols;
    float startshit = 0.;
    float halfv = (vUvR.y - 1.) * 7.; 
    float halfanim = 0.;
    vec3 tex = vec3(0.);

    float difIndex = 0.;

    float sumac = 0.;
    time3 = abs( sin(uTime * 0.0008) ) ;
    time2 = (sin(uTime * 0.0008));

    float mPos = 0.;
    float mPower = 0.;

    highp int index = int(vId);

    
    if(uKey == -2.){
      
      mPower = 1. - uStart;
      mPos = (uStart - 1.)*1. ;



      startshit =  (( (halfv * .001)) * uStart);
      sumac = (ripple(vUvR.y ,mPos, cols) * ( (.4  ) * ( 1. - mPower + (1. * uPower) ) ) );
      rippleUV = (vUv.x + (startshit)) + sumac;
      tex = texture2D(tMap, vec2(rippleUV, vUv.y) ).rgb;
      
    }
    else if(uKey != -1.){
      time2 = uMouse.x * -2. ;
      time3 = .0;
      halfanim = 1.;



        // for( float i = 0.; i <= count; i+= 1.0 ){

        //       mPos = uPowers[index] * -2. + (i * .2);
        //       mPower = abs(uPowers[index] * 2.);
              
            
        // }
          mPos = uPowers[index] * -2.;
          mPower = abs(uPowers[index] * (2. - abs(time2 * .5) ));


          // NEGATIVE TO THE LEFT THE DISTO
          // mPos = -.3 * -2.;
          // mPower = abs(-.3 * 2.);
          // CENTER IS EQUAL TO 0
          // mPos = 0. * -2.;
          // mPower = abs(0. * 2.);
          // POSITIVE TO THE RIGHT THE DISTO
          // mPos = .3 * -2.;
          // mPower = abs(.3 * 2.);


          // if(vId == uKey){
          //   mPos = uMouse.x * -2.;
          //   mPower = abs(uMouse.x * 2.);
          // }
          // else if((vId+1.) == uKey){

          //   mPos = -1.;
          //   // time3 = .5 + abs(uMouse.x * 2.);
          //   mPower = 1.;

          // }
          // else if((vId-1.) == uKey){

          //   mPos = 1.;
          //   // time3 = .5 + abs(uMouse.x * 2.);
          //   mPower = 1.;
            
          // }
          // else{
          //   mPos = 0.;
          //   mPower = 1.;
          // }
          sumac = (ripple(vUvR.y ,mPos, cols) * ( (.2 * (1. - mPower)  ) * ( 1. - mPower  ) ) );
          // EFFECT THAT LOOKS FRACTAL
          // sumac = (ripple(vUvR.y ,mPos, cols) * ( (.2 * (1. - mPower)  ) * ( .5 - mPower  ) ) );

          
          rippleUV = (vUv.x) + sumac;
          tex = texture2D(tMap, vec2(rippleUV, vUv.y) ).rgb;
      
      
    }
    else if(uKey ==  -1.){

      
          mPos = uPowers[index] * -2.;
          mPower = abs(uPowers[index] *(2. - abs(time2 * .5) ));
          sumac = (ripple(vUv.y ,mPos, cols) * ( (.2 * (1. - mPower)  ) * ( 1. - mPower  ) ) );
          rippleUV = (vUv.x) + sumac;
          tex = texture2D(tMap, vec2(rippleUV, vUv.y) ).rgb;
      // time2 = uMouse.x * -2. ;
      // rippleUV = (vUv.x) + (ripple(vUvR.y ,mPos, cols) * ( (.2 ) * ( uPower  ) ) );
      // tex = texture2D(tMap, vec2(rippleUV, vUv.y) ).rgb;
    }


    float signedDist = max(min(tex.r, tex.g), min(max(tex.r, tex.g), tex.b)) - 0.5;
    float d = fwidth(signedDist);
    float alpha = smoothstep(-d, d, signedDist);

    
    gl_FragColor.rgb = vec3(uColor);
    // gl_FragColor.r += distance(uMouse.x + .5 ,vUvR.y * .5);
    

      // gl_FragColor.r =abs(mPower);
    gl_FragColor.a = alpha * (1. - uStart * 1.9);
    if(uKey ==  -2.){
    gl_FragColor.a -= abs(sumac * 8.);
    }
    else{
    gl_FragColor.a -= abs(sumac * 8.);

    }

}

=== FILE END: src/public/shaders/title/title_msdf.fragment.glsl ===



=== FILE START: src/public/shaders/title/title_msdf.vertex.glsl ===

#version 300 es
precision highp float;
#define attribute in
#define varying out

attribute vec2 uv;
attribute vec3 position;

                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;


attribute float id;
attribute vec3 index;

uniform sampler2D tMap;
uniform float uTime;
uniform vec2 uMouse;
uniform float uPower;
uniform float uCols;
uniform int uLength;

varying vec2 vUv;
varying vec2 vUvR;

varying vec3 vPos;
varying vec3 vIndex;
varying float vId;


void main() {
    vUv = uv;
    vUvR = vec2(gl_VertexID << 1 & 2, gl_VertexID & 2);

    vPos = position;
    // vPos.x *=.5;
    vId = id;
    vIndex = index;
    
    if(vId == 3.){
      // vPos.x += sin(uTime * .002) * .005;
      // vUvR.x += sin(uTime * .002) * .1;
    }

    // gl_Position = vec4(vPos.x,vPos.y,vPos.z,  1.);

      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

// gl_Position = position;

}




=== FILE END: src/public/shaders/title/title_msdf.vertex.glsl ===



=== FILE START: src/public/shaders/about/about_msdf.fragment.glsl ===

#version 300 es
precision highp float;
#define varying in
#define texture2D texture
#define gl_FragColor FragColor
out vec4 FragColor;

uniform sampler2D tMap;

uniform float uColor;



varying vec2 vUv;
varying vec2 vUvR;


void main() {



    
    vec3 tex = vec3(0.);



    tex = texture2D(tMap, vUv ).rgb;

    float signedDist = max(min(tex.r, tex.g), min(max(tex.r, tex.g), tex.b)) - 0.5;
    float d = fwidth(signedDist);
    float alpha = smoothstep(-d, d, signedDist);


    gl_FragColor.rgb = vec3(uColor);
    // gl_FragColor.r += distance(uMouse.x + .5 ,vUvR.y * .5);
    
    gl_FragColor.a = alpha;
    

}

=== FILE END: src/public/shaders/about/about_msdf.fragment.glsl ===



=== FILE START: src/public/shaders/about/about_parent.fragment.glsl ===

#version 300 es
precision highp float;
#define attribute in
#define varying out

attribute vec2 uv;
attribute vec3 position;

                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;


attribute float id;
attribute vec3 index;

uniform sampler2D tMap;
uniform float uTime;
uniform vec2 uMouse;
uniform float uPower;
uniform float uCols;
uniform int uLength;

varying vec2 vUv;
varying vec2 vUvR;

varying vec3 vPos;
varying vec3 vIndex;
varying float vId;


void main() {
    vUv = uv;
    vUvR = vec2(gl_VertexID << 1 & 2, gl_VertexID & 2);

    vPos = position;
    // vPos.x *=.5;
    vId = id;
    vIndex = index;
    
    if(vId == 3.){
      // vPos.x += sin(uTime * .002) * .005;
      // vUvR.x += sin(uTime * .002) * .1;
    }

    // gl_Position = vec4(vPos.x,vPos.y,vPos.z,  1.);

      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

// gl_Position = position;

}




=== FILE END: src/public/shaders/about/about_parent.fragment.glsl ===



=== FILE START: src/public/shaders/image/image_main.vertex.glsl ===

attribute vec2 uv;
attribute vec2 position;

uniform sampler2D tMap;
uniform vec2 uCover;
uniform vec2 uTextureSize;
uniform float uTime;
uniform vec2 uMouse;

varying vec2 vUv;

vec2 resizeUvCover(vec2 uvn, vec2 size, vec2 resolution) {
  vec2 ratio = vec2(
    min(resolution.x / resolution.y / (size.x / size.y), 1.0),
    min(resolution.y / resolution.x / (size.y / size.x), 1.0)
  );

  return vec2(uvn.x * ratio.x + (1.0 - ratio.x) * 0.5, uvn.y * ratio.y + (1.0 - ratio.y) * 0.5);
}
void main() {
  vUv = uv.xy;
  vUv = resizeUvCover(uv, uTextureSize, uCover);

  gl_Position = vec4(position, 0, 1);
}


=== FILE END: src/public/shaders/image/image_main.vertex.glsl ===



=== FILE START: src/public/shaders/image/image_main.fragment.glsl ===

precision highp float;

uniform vec2 uCover;
uniform vec2 uTextureSize;
uniform sampler2D tMap;
uniform float uStart;
uniform float uStart1;
uniform float uTime;
uniform vec2 uMouse;

varying vec2 vUv;
varying float vPos;

// vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
// vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
// float cnoise(vec2 P){
//   vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
//   vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
//   Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
//   vec4 ix = Pi.xzxz;
//   vec4 iy = Pi.yyww;
//   vec4 fx = Pf.xzxz;
//   vec4 fy = Pf.yyww;
//   vec4 i = permute(permute(ix) + iy);
//   vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
//   vec4 gy = abs(gx) - 0.5;
//   vec4 tx = floor(gx + 0.5);
//   gx = gx - tx;
//   vec2 g00 = vec2(gx.x,gy.x);
//   vec2 g10 = vec2(gx.y,gy.y);
//   vec2 g01 = vec2(gx.z,gy.z);
//   vec2 g11 = vec2(gx.w,gy.w);
//   vec4 norm = 1.79284291400159 - 0.85373472095314 *
//     vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
//   g00 *= norm.x;
//   g01 *= norm.y;
//   g10 *= norm.z;
//   g11 *= norm.w;
//   float n00 = dot(g00, vec2(fx.x, fy.x));
//   float n10 = dot(g10, vec2(fx.y, fy.y));
//   float n01 = dot(g01, vec2(fx.z, fy.z));
//   float n11 = dot(g11, vec2(fx.w, fy.w));
//   vec2 fade_xy = fade(Pf.xy);
//   vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
//   float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
//   return 2.3 * n_xy;
// }

vec2 coverTexture(vec2 imgSize, vec2 ouv, vec2 mouse) {
  vec2 s = uCover;
  vec2 i = imgSize;
  // Displacement 20-80%
  // ouv.x-=( (mouse.x) * 1.2);
  ouv.x -= mouse.x * 1.0;

  // Displacement sudden
  // ouv.x-=( (mouse.x) * 2.);
  // i.y *= 1.2;

  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = ouv * s / new + offset;

  // uv.x *= 1. + (1. * (.5 *  ( 1. + sin(time*.002))));
  // uv.x -= .05 * (.5 *  ( 1. + sin(time*.002)));
  // uv.x += .02 *  sin(time*.001);

  // uv.x += .6 * mouse.x;

  // uv.x += .05 * ( (sin(time*.002)));
  // return texture2D(tex, uv);
  return uv;
}

void main() {
  float sum = 0.0;
  vec2 mouse = uMouse;

  vec2 tSize = uTextureSize;
  mouse.x += uStart * -0.8;
  tSize.x *= 1.0 + abs(mouse.x);

  vec2 cover = coverTexture(tSize, vUv, mouse);

  float cols = 8.0;

  float timeralpha = 0.0;
  float alpha = 1.0;
  // float alpha = 1. - step(uStart, fract(1. * vUv.x));
  // mouse.x += (1. - uStart) * .8;
  // mouse.x += (uStart) * -.8;

  vec2 U = cover,
    P = vec2(cols, cols),
    C = floor(U * P) / P;

  float centpos = vUv.x + mouse.x;
  centpos += -0.5 + mouse.x * 2.4;
  centpos *= 2.0;
  centpos = abs(centpos);

  float cent = 1.0 - vUv.x;

  // float cent = vUv.y;
  // Here is the key so that the SIN can be done well but without centering,
  // comment the line below
  cent += -0.5 + mouse.x * 0.4;
  cent *= 2.0;

  // THIS IS IN CASE YOU WANT TO MOVE THE COLS
  // cent += uMouse.y;

  cent = abs(cent);

  // A LOT MORE DISTORTION
  // cent *= 2.12;
  // float otro = floor(vUv.y*P.y)/P.y;
  float otro = floor(cent * P.x) / P.x;
  // Looks like a camera lens change
  // otro *= vUv.x - .5;
  // Not much ago, just exaggerating a little
  // otro += vUv.x - .5;
  U.x -= otro;

  // The mouse does not affect the amount of distortion with position
  U.x += mouse.x * (otro * 0.2);
  U.x += centpos * 1.2 * (mouse.x * (otro * 0.1));

  // if(otro < uMouse.y){
  // U.y += ripple;
  // EFFECT REQUIRED BUT WE WANT IT TO ONLY BE DONE IN 5 COLS
  // U.y += (otro * .3);
  // }

  U.x += otro;
  // INVERT EFFECT WITH WHAT IS MULTIPLIED OF THE DISTORT

  // float chk = 0.;
  //  if(U.x > 1.){
  //     U.x -= .12;
  //   }
  //   else if(U.x < 0.){
  //     chk = 1.;
  //     U.x += .12;
  //   }

  vec2 direction = U;

  float distor = 1.0;
  distor += 0.006 * abs(mouse.x);

  U.x += uMouse.x * 0.2;

  // CONTROL THE DISTORT BY THE EXTERNALS
  if (U.x > 1.0) {
    // distor += (.02 * abs(mouse.x - .1));// distor += (.002 * abs(mouse.x));// mouse.x *=-1.;// float noise = cnoise(// vec2(//   .1 + vUv.x + (1. - mouse.x),//   .1 + vUv.y - (1. + mouse.x)//   )// ) ;// U.x *= noise * (.2 - mouse.x);
  }

  if (U.x < 0.0) {
    // distor += (.02 * abs(mouse.x - .1));// distor += (.002 * abs(mouse.x));// float noise = cnoise(// vec2(//   .1 + vUv.x + (1. + mouse.x),//   .1 + vUv.y + (2. + mouse.x)//   )// ) ;// U.x *= noise * (1.2 + mouse.x);// U.y -= noise ;// U.x *= -.5;
  }

  vec2 end = U;

  // vec4 final = texture2D(tMap, U);
  float r = texture2D(tMap, vec2(end.x, end.y)).r;
  float g = texture2D(tMap, vec2(end.x, end.y)).g;
  float b = texture2D(tMap, vec2(end.x, end.y)).b;

  // gl_FragColor = vec4(r , g , b ,alpha);
  gl_FragColor = vec4(r, g, b, alpha);

  // if(U.x > 1.){
  //     gl_FragColor = vec4(1.,0.,0.,1.);
  //   }

  //   if(U.x < 0.){
  //     gl_FragColor = vec4(1.,0.,0.,1.);
  //   }

  //TEST
  // gl_FragColor = vec4(centpos*.5 + (mouse.x * (otro * .2)),0.,0.,1.);
  // gl_FragColor = vec4(centpos ,0.,0.,1.);
  //gl_FragColor = vec4((0.5 * (otro)),0.,0.,1.);

  // if(chk == 1.){
  //   gl_FragColor.r = 1.;
  // }

}


=== FILE END: src/public/shaders/image/image_main.fragment.glsl ===



=== FILE START: src/public/shaders/slides/slides_parent.fragment.glsl ===

precision highp float;

// Default uniform for previous pass is 'tMap'.
// Can change this using the 'textureUniform' property
// when adding a pass.
uniform sampler2D tMap;

uniform float uTime;
uniform float uStart;
uniform float uHover;

varying vec2 vUv;

// fake bokeh - https://www.shadertoy.com/view/XsfSRr
// Bokeh Blur Demo - https://www.shadertoy.com/view/3sjBRR
// CIRCULAR, THIS IS PLAYABLE - Fine fake bokeh - https://www.shadertoy.com/view/XtjGWm
// OTHER - Fake bokeh - https://www.shadertoy.com/view/WdVSWd
// Easy Bokeh Blur - https://www.shadertoy.com/view/NtGczw
// Bokehs and Chromatic Aberration - https://www.shadertoy.com/view/Ds2XRR
// PRETTY SIMPLE - Bokeh circle blur  https://www.shadertoy.com/view/3sBXDh
// SIMPLE - BlurstFilter https://www.shadertoy.com/view/mslSzs
// SIMPLE ALSO AND WITH GRAD - bokeh͏ https://www.shadertoy.com/view/ct2cRD
void main() {
  // vec3 kernel[SAMPLES] = vec3[70][
  // v3(-3,-2,0.0099343), v3(-3,-1,0.0158491), v3(-3,0,0.0198582), v3(-3,1,0.0193742), v3(-3,2,0.01562), v3(-3,3,0.0092086), v3(-2,-3,0.0036023), v3(-2,-2,0.017351), v3(-2,-1,0.026431), v3(-2,0,0.0318141), v3(-2,1,0.0318476), v3(-2,2,0.0282652), v3(-2,3,0.0207794), v3(-2,4,0.0100408), v3(-1,-3,0.0118306), v3(-1,-2,0.0230702), v3(-1,-1,0.028688), v3(-1,0,0.0287297), v3(-1,1,0.0291755), v3(-1,2,0.0288904), v3(-1,3,0.0242141), v3(-1,4,0.0133157), v3(0,-3,0.0177183), v3(0,-2,0.0269386), v3(0,-1,0.0255012), v3(0,0,0.0231038), v3(0,1,0.0240891), v3(0,2,0.0266765), v3(0,3,0.026509), v3(0,4,0.0185881), v3(1,-4,0.0066892), v3(1,-3,0.0225386), v3(1,-2,0.0271861), v3(1,-1,0.0236909), v3(1,0,0.0199988), v3(1,1,0.0204911), v3(1,2,0.0250744), v3(1,3,0.0265619), v3(1,4,0.0210398), v3(2,-4,0.0087099), v3(2,-3,0.0241667), v3(2,-2,0.027311), v3(2,-1,0.0227511), v3(2,0,0.019024), v3(2,1,0.0192731), v3(2,2,0.023786), v3(2,3,0.0278565), v3(2,4,0.022605), v3(2,5,0.0069317), v3(3,-4,0.0080222), v3(3,-3,0.0218081), v3(3,-2,0.0268296), v3(3,-1,0.0238996), v3(3,0,0.0200351), v3(3,1,0.0195484), v3(3,2,0.0230739), v3(3,3,0.0269896), v3(3,4,0.0210053), v3(3,5,0.0032463), v3(4,-3,0.0189985), v3(4,-2,0.026861), v3(4,-1,0.0267855), v3(4,0,0.0236707), v3(4,1,0.0230364), v3(4,2,0.0262396), v3(4,3,0.0261808), v3(4,4,0.0176466), v3(5,-3,0.0156334), v3(5,-2,0.0255458), v3(5,-1,0.0285479), v3(5,0,0.029006), v3(5,1,0.0285642), v3(5,2,0.0279639), v3(5,3,0.0220895), v3(5,4,0.011235), v3(6,-3,0.007862), v3(6,-2,0.021451), v3(6,-1,0.0280171), v3(6,0,0.0326608), v3(6,1,0.032852), v3(6,2,0.0261432), v3(6,3,0.0160087), v3(7,-2,0.0028554), v3(7,-1,0.0142694), v3(7,0,0.0180889), v3(7,1,0.0194572), v3(7,2,0.0142807)
  // ];

  // float moder = sin(uTime * .0005);
  // TO MAKE THE HOVER CRAZIER
  float moder = clamp(uStart * 0.5 + uHover, 0.0, 1.0);
  // SOMETHING CALMER
  // float moder = clamp(uStart,0.,1.);

  float cols = 16.0;
  vec2 U = vec2(vUv.x - moder * 0.2, vUv.y);
  vec2 P = vec2(cols, cols);
  vec2 C = floor(U * P) / P;

  vec2 mouse = vec2(moder, 0.0);

  float centpos = vUv.x + mouse.x;
  // centpos += -.5;
  // centpos *=2.;
  // centpos = abs(centpos);

  float cent = 1.0 - vUv.x;

  cent += -0.5;
  cent *= 2.0;

  float otro = floor(cent * P.x) / P.x;
  U.x -= otro;

  U.x += mouse.x * (otro * 0.2);
  U.x += centpos * 1.2 * (mouse.x * (otro * 0.1));

  float hov = 0.1 * uHover;
  U.x += otro + otro * hov + uHover * 0.16;

  // U.y += moder * .1002;

  float r = texture2D(tMap, vec2(U.x, U.y)).r;
  float g = texture2D(tMap, vec2(U.x, U.y)).g;
  float b = texture2D(tMap, vec2(U.x, U.y)).b;

  float a = texture2D(tMap, vec2(vUv.x, vUv.y)).a;

  gl_FragColor = vec4(r, g, b, a);
  // gl_FragColor.a = step(uTime, fract(16. * vUv.x));

  // gl_FragColor = vec4(U.x,0.,0. ,a);
}


=== FILE END: src/public/shaders/slides/slides_parent.fragment.glsl ===



=== FILE START: src/public/shaders/slides/slides_main.vertex.glsl ===

attribute vec3 uv;
attribute vec3 position;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

uniform vec2 uScreen;
uniform sampler2D tMap;
uniform vec2 uTextureSize;
uniform vec2 uCover;
uniform float uTime;
uniform float uStart;
uniform vec2 uMouse;

varying vec2 vUv;

void main() {
  vUv = uv.xy;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}


=== FILE END: src/public/shaders/slides/slides_main.vertex.glsl ===



=== FILE START: src/public/shaders/slides/slides_main.fragment.glsl ===

precision highp float;

uniform float uStart;
uniform float uTime;
uniform vec2 uCover;
uniform vec2 uTextureSize;
uniform sampler2D tMap;

varying vec2 vUv;

vec2 coverTexture(vec2 imgSize, vec2 ouv, vec2 mouse) {
  vec2 s = uCover;
  vec2 i = imgSize;
  // Displacement 20-80%
  // ouv.x-=( (mouse.x) * 1.2);

  // Displacement sudden
  // ouv.x-=( (mouse.x) * 2.);
  // i.y *= 1.2;

  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = ouv * s / new + offset;

  // uv.x *= 1. + (1. * (.5 *  ( 1. + sin(time*.002))));
  // uv.x -= .05 * (.5 *  ( 1. + sin(time*.002)));
  // uv.x += .02 *  sin(time*.001);

  // uv.x += .6 * mouse.x;

  // uv.x += .05 * ( (sin(time*.002)));
  // return texture2D(tex, uv);
  return uv;
}

void main() {
  vec2 cover = coverTexture(uTextureSize, vUv, vec2(0.0));
  gl_FragColor = texture2D(tMap, cover);

}


=== FILE END: src/public/shaders/slides/slides_main.fragment.glsl ===



=== FILE START: src/public/shaders/fire/fire_msdf.fragment.glsl ===

#version 300 es
precision highp float;
#define varying in
#define texture2D texture
#define gl_FragColor FragColor
out vec4 FragColor;

uniform sampler2D tMap;

uniform float uColor;
uniform float uStart;



varying vec2 vUv;
varying vec2 vUvR;


void main() {



    
    vec3 tex = vec3(0.);



    tex = texture2D(tMap, vUv ).rgb;

    float signedDist = max(min(tex.r, tex.g), min(max(tex.r, tex.g), tex.b)) - 0.5;
    float d = fwidth(signedDist);
    float alpha = smoothstep(-d, d, signedDist);


    gl_FragColor.rgb = vec3(uColor);
    // gl_FragColor.r += distance(uMouse.x + .5 ,vUvR.y * .5);
    
    gl_FragColor.a = alpha;
    

}

=== FILE END: src/public/shaders/fire/fire_msdf.fragment.glsl ===



=== FILE START: src/public/shaders/fire/fire_parent.fragment.glsl ===

precision highp float;

// Default uniform for previous pass is 'tMap'.
// Can change this using the 'textureUniform' property
// when adding a pass.
uniform sampler2D tMap;

uniform float uTime;
uniform float uStart;
uniform float uOut;
uniform float uMouseT;
uniform float uMouse;

varying vec2 vUv;

float ripple(float uv, float time, float prog) {
  // float distance = length((uv ) + min(max(.2 ,time ), .7 ) );
  float distance = length(uv + time * 2.0);
  return tan(distance * 1.0) * (prog * -1.85);
}

float rippleout(float uv, float time, float prog, float multi) {
  float distance = length(uv * 3.0 + time * 1.4);
  return tan(distance * 1.0) * (multi * prog);

}

void main() {
  float timer = uOut;
  // timer = 1.;
  float centeredy = (vUv.y - 0.5) * 2.0;

  float rippleOut = rippleout(vUv.y, timer, 1.0 - abs(timer), -0.36) * (0.1 * (1.0 - abs(timer)));

  float time2 = abs(uStart) * 2.0;
  float rippleUV = ripple(vUv.y, uStart, uTime) * (0.001 * uTime);

  float rippleUV2 = ripple(vUv.y, uMouse, uMouseT) * (0.0006 * uMouseT);
  // rippleUV *= uTime;
  // rippleUV2 *= uMouseT;
  // float rippleUV = vUv.y + ((ripple(vUv.y * 6.2,time2, 1.))*.002) ;
  // vec4 raw = texture2D(tMap, vec2(vUv.x,rippleUV));
  // raw = texture2D(tMap, vUv);
  // Split screen in half to show side-by-side comparison

  // gl_FragColor =raw;

  // float raw = newRipple(vUv,time2*.9) * 13.;
  // raw = texture2D(tMap, vec2(vUv.x,r + vUv.y));

  vec2 U = vec2(vUv.x, rippleUV + rippleUV2 + vUv.y + rippleOut);
  //vec2 U = vec2(vUv.x, rippleUV2 + vUv.y);

  float distor = 1.0;
  // distor -= (.002 * uStart);

  U.y += uStart * 0.1002;

  float r = texture2D(tMap, vec2(U.x * distor, U.y / distor)).r;
  float g = texture2D(tMap, vec2(U.x, U.y)).g * distor;
  float b = texture2D(tMap, vec2(U.x, U.y)).b * (distor + 1.6 * (distor - 1.0));
  float a = texture2D(tMap, vec2(U.x, U.y)).a;

  // gl_FragColor = vec4(1. , 0. , 0. ,rippleUV);

  if (rippleOut * -32.0 > centeredy + timer) {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    gl_FragColor = vec4(r, g, b, a);
    gl_FragColor.a -= abs(rippleUV) * 0.5;
    gl_FragColor.a -= abs(rippleUV2) * 0.5;

  }

}


=== FILE END: src/public/shaders/fire/fire_parent.fragment.glsl ===



=== FILE START: src/public/shaders/loader/loader_main.vertex.glsl ===

attribute vec2 uv;
attribute vec2 position;

uniform vec2 uResolution;

varying vec2 vUv;

void main() {
  vUv = uv;

  gl_Position = vec4(position, 0, 1);
}


=== FILE END: src/public/shaders/loader/loader_main.vertex.glsl ===



=== FILE START: src/public/shaders/loader/loader_main.fragment.glsl ===

precision highp float;

uniform vec2 uResolution;
uniform float uTime;
uniform float uStart0;
uniform float uStart1;
uniform float uStart2;

uniform float uStartX;
uniform float uStartY;
uniform float uMultiX;
uniform float uMultiY;

varying vec2 vUv;
vec2 fade(vec2 t) {
  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
vec4 permute(vec4 x) {
  return mod((x * 34.0 + 1.0) * x, 289.0);
}
float cnoise(vec2 P) {
  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
  vec4 ix = Pi.xzxz;
  vec4 iy = Pi.yyww;
  vec4 fx = Pf.xzxz;
  vec4 fy = Pf.yyww;
  vec4 i = permute(permute(ix) + iy);
  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
  vec4 gy = abs(gx) - 0.5;
  vec4 tx = floor(gx + 0.5);
  gx = gx - tx;
  vec2 g00 = vec2(gx.x, gy.x);
  vec2 g10 = vec2(gx.y, gy.y);
  vec2 g01 = vec2(gx.z, gy.z);
  vec2 g11 = vec2(gx.w, gy.w);
  vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;
  float n00 = dot(g00, vec2(fx.x, fy.x));
  float n10 = dot(g10, vec2(fx.y, fy.y));
  float n01 = dot(g01, vec2(fx.z, fy.z));
  float n11 = dot(g11, vec2(fx.w, fy.w));
  vec2 fade_xy = fade(Pf.xy);
  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

void main() {
  float prog = 0.5;
  float time = uStart1;
  // float time2 = (sin(uTime * .001) * -.51 );
  float time2 = uStart1 * 2.0;
  // time *= -1.;
  prog = 0.4;
  // time = uStart0;
  // time2 = uStart1;

  // float noise = cnoise((vec2(vUv.x*.6,vUv.y) * time2) + (time * 3.6) + time)*3.;
  // float noise = cnoise(
  //   vec2(
  //   0.,
  //   ((vUv.y*.85)+.35)
  //   )
  // )*3.;

  // float noise = cnoise(
  //   vec2(
  //   vUv.x*(.6 * time2),
  //    ((vUv.x * (.1 + ( time * .5) )) + .5 - time) - (.12 * vUv.y)
  //   )
  // )*3.;

  // float noise = cnoise(
  //   vec2(
  //   vUv.x+(1. * uStartX),
  //   vUv.y+(1. * uStartY),
  //   )
  // )*3.;

  // float noise = cnoise(
  //   vec2(
  //   (vUv.x * ( -.25 )) + uStartX,
  //   vUv.y +(1. +  uStartY)
  //   )
  // )*3.;

  float noise = cnoise(vec2(vUv.x * uMultiX + uStartX, vUv.y * uMultiY + uStartY)) * 3.0;

  gl_FragColor.rgb = vec3(0.0);
  // gl_FragColor.a = (( uStart1 ) - (noise + prog)) * ( uStart0);

  // gl_FragColor.a = uStart0 - ((noise + prog) * (1. - uStart1));
  // gl_FragColor.a = uStart0 + (noise + prog);

  gl_FragColor.a = mix(1.0, noise + prog, uStart0);

  gl_FragColor.a *= uStart2;
}


=== FILE END: src/public/shaders/loader/loader_main.fragment.glsl ===



=== FILE START: src/public/shaders/terrain/terrain_main.fragment.glsl ===

precision highp float;

uniform vec2 uResolution;
uniform float uTime;
uniform float uStart0;
uniform float uStart1;
uniform float uStart2;

uniform float uStartX;
uniform float uStartY;
uniform float uMultiX;
uniform float uMultiY;

varying vec2 vUv;
vec2 fade(vec2 t) {
  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
vec4 permute(vec4 x) {
  return mod((x * 34.0 + 1.0) * x, 289.0);
}
float cnoise(vec2 P) {
  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
  vec4 ix = Pi.xzxz;
  vec4 iy = Pi.yyww;
  vec4 fx = Pf.xzxz;
  vec4 fy = Pf.yyww;
  vec4 i = permute(permute(ix) + iy);
  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
  vec4 gy = abs(gx) - 0.5;
  vec4 tx = floor(gx + 0.5);
  gx = gx - tx;
  vec2 g00 = vec2(gx.x, gy.x);
  vec2 g10 = vec2(gx.y, gy.y);
  vec2 g01 = vec2(gx.z, gy.z);
  vec2 g11 = vec2(gx.w, gy.w);
  vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;
  float n00 = dot(g00, vec2(fx.x, fy.x));
  float n10 = dot(g10, vec2(fx.y, fy.y));
  float n01 = dot(g01, vec2(fx.z, fy.z));
  float n11 = dot(g11, vec2(fx.w, fy.w));
  vec2 fade_xy = fade(Pf.xy);
  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

void main() {
  float prog = 0.5;
  float time = uStart1;
  // float time2 = (sin(uTime * .001) * -.51 );
  float time2 = uStart1 * 2.0;
  // time *= -1.;
  prog = 0.4;
  // time = uStart0;
  // time2 = uStart1;

  // float noise = cnoise((vec2(vUv.x*.6,vUv.y) * time2) + (time * 3.6) + time)*3.;
  // float noise = cnoise(
  //   vec2(
  //   0.,
  //   ((vUv.y*.85)+.35)
  //   )
  // )*3.;

  // float noise = cnoise(
  //   vec2(
  //   vUv.x*(.6 * time2),
  //    ((vUv.x * (.1 + ( time * .5) )) + .5 - time) - (.12 * vUv.y)
  //   )
  // )*3.;

  // float noise = cnoise(
  //   vec2(
  //   vUv.x+(1. * uStartX),
  //   vUv.y+(1. * uStartY),
  //   )
  // )*3.;

  // float noise = cnoise(
  //   vec2(
  //   (vUv.x * ( -.25 )) + uStartX,
  //   vUv.y +(1. +  uStartY)
  //   )
  // )*3.;

  float noise = cnoise(vec2(vUv.x * uMultiX + uStartX, vUv.y * uMultiY + uStartY)) * 3.0;

  gl_FragColor.rgb = vec3(0.0);
  // gl_FragColor.a = (( uStart1 ) - (noise + prog)) * ( uStart0);

  // gl_FragColor.a = uStart0 - ((noise + prog) * (1. - uStart1));
  // gl_FragColor.a = uStart0 + (noise + prog);

  gl_FragColor.a = mix(1.0, noise + prog, uStart0);

  gl_FragColor.a *= uStart2;
}


=== FILE END: src/public/shaders/terrain/terrain_main.fragment.glsl ===



=== FILE START: src/public/shaders/terrain/terrain_main.vertex.glsl ===

attribute vec2 uv;
attribute vec2 position;

uniform vec2 uResolution;

varying vec2 vUv;

void main() {
  vUv = uv;

  gl_Position = vec4(position, 0, 1);
}


=== FILE END: src/public/shaders/terrain/terrain_main.vertex.glsl ===



=== FILE START: src/public/shaders/grid/grid_main.vertex.glsl ===

attribute vec3 uv;
attribute vec3 position;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

uniform vec2 uCover;
uniform float uZoom;
uniform float uMove;

varying vec3 vUv;

void main() {
  vUv = uv.xyz;

  vec3 pos = position;
  // pos.x *= 1.5;
  // pos.y *= 1.5;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}


=== FILE END: src/public/shaders/grid/grid_main.vertex.glsl ===



=== FILE START: src/public/shaders/grid/grid_main.fragment.glsl ===

precision highp float;

uniform sampler2D tMap;
uniform vec2 uCover;
uniform float uMouse;
uniform vec2 uTextureSize;
uniform float uLoad;
uniform float uZoom;
uniform float uMove;
varying vec3 vUv;

vec2 coverTexture(vec2 imgSize, vec2 ouv, float mouse) {
  vec2 s = uCover;
  vec2 i = imgSize;
  ouv.x -= mouse * 1.0;

  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = ouv * s / new + offset;

  return uv;
}

void main() {
  if (uLoad != 0.0) {
    vec2 tsize = uTextureSize;
    float mouse = uMouse;
    float cols = 4.0 * uZoom;

    tsize.x *= 1.0 + abs(mouse);
    vec2 cover = coverTexture(tsize, vUv.xy, mouse);

    vec2 U = cover,
      P = vec2(cols, cols),
      C = floor(U * P) / P;

    float centpos = vUv.x + mouse;
    float cent = 1.0 - vUv.x;
    centpos += -0.5 + mouse * 2.4;
    centpos *= 2.0;
    centpos = abs(centpos);

    cent += -0.5 + mouse * 0.4;
    cent *= 2.0;
    cent = abs(cent);
    float otro = floor(cent * P.x) / P.x;
    U.x -= otro;
    U.x += mouse * (otro * 0.2);
    U.x += centpos * 1.2 * (mouse * (otro * 0.1));

    U.x += otro;
    U.x += uMouse * 0.2;

    gl_FragColor = texture2D(tMap, U);

    gl_FragColor.a = uLoad;

  } else {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);

  }
  // gl_FragColor = vec4(vUv.x,1. - vUv.x,vUv.x * .5,1.0);
}


=== FILE END: src/public/shaders/grid/grid_main.fragment.glsl ===



=== FILE START: src/lib/page/scroll.js ===



//* Funciones de control
export  function stopScroll(){
    // this.isVisible = 0
  }
  export  function startScroll(){
    // this.isVisible = 1
  }
  
  //* Función para Smooth
  // REVISAR HACER LOS FOR DE LAS ANIMACIONES ASÍNCRONAS POR EL REFLOW ( Mejora rendimiento )
  
  
  
  export function animIosScroll(){
    if(this.isVisible == 0){
      return false
    }
    if(this.iosupdaters.length){
      for(let c of this.iosupdaters){
        
        this.ios[c].class.update(window.scrollY)
        
      }
    }
  }
  

=== FILE END: src/lib/page/scroll.js ===



=== FILE START: src/lib/page/events.js ===



export  function onResize () {
  
    for(let [index,key] of Object.keys(this.components).entries()){

      if(Array.isArray(this.components[key])){
        for(let comp of this.components[key]){
          if(comp.onResize){
            comp.onResize()
          }
        }
      }
      else{
        if(this.components[key].onResize){
          this.components[key].onResize()
        }
      }

    }


    for(let el of this.ios){
      if(el){
        if(el.class){
          if(el.class.onResize){
            el.class.onResize(this.scroll.target)
          }
        }
      }
    }
    
    
    this.resizeLimit()


    

}
export  function resizeLimit(){
  let size = 0

    

    // size -=  window.innerHeight
      
    this.scroll.limit = this.DOM.el.clientHeight - this.main.screen.h
    
}

export  function onScroll (scrollY){
  // this.scroll.target = document.body.scrollTop
  
}

export  function onTouchDown (event) {
  this.isDown = true
  
  
  
}

export  function onTouchMove (event) {
  if (!this.isDown) return
  
}

export  function onTouchUp (event) {

  this.isDown = false
}


export  function onWheel (y) {
  if(this.isVisible==0){
    return
  }
  // y = clamp(-60,60,y)
  // this.scroll.target += y

  
}



=== FILE END: src/lib/page/events.js ===



=== FILE START: src/lib/page/loads.js ===

export function timeout(ms){
    return new Promise(resolve => setTimeout(resolve, ms))
  }
  
  export async function loadRestApi(url,id='',temp=''){
    
    if(import.meta.env.DEV == true){
  
      console.log(url+id+'?device='+this.main.device+'&webp='+this.main.webp+'&template='+temp)
    }
  
    let formData = new FormData()
    let info = {
      device:this.main.device,
      webp:this.main.webp,
      webgl:this.main.webgl
      
    }
  
    if(temp!=''){
      info.template=temp
    }
  
    formData.set("form", JSON.stringify(info))
  
  
    if(document.body.dataset.nonce){
  
      
  
      const response = await fetch(url+id,{
        method: "POST",
        body: formData,
        headers: {
          'X-WP-Nonce': document.body.dataset.nonce,
          // 'Content-Type': 'application/json',
        }
      })
  
      const data = await response.json()
  
  
      return data
    }
    else{
      url +=id
      url +='?device='+this.main.device
      url +='&webp='+this.main.webp
      url +='&webgl='+this.main.webgl
      if(temp!=''){
       
        url +='&template='+temp 
      }
      const response = await fetch(url,{
        method: "GET",
       
      })
      const data = await response.json()
      if(import.meta.env.DEV == true && data.csskfields){
        
      }
      return data
    }
  
  }
  //Images
  export async function loadImages(){
    this.DOM.images = document.querySelectorAll('img')
    const imageswait = document.querySelectorAll('img.Wait')
    const imagesnowait = document.querySelectorAll('img:not(.Wait)')
    let promiseswait = []
    for(let path of imageswait){
      
      promiseswait.push(this.loadImage(path))
      
  
    }
  
    await Promise.all(promiseswait)
    this.scaleLoads(imagesnowait)
  }
  
  
  export async function scaleLoads(elswait){
  
    for(let path of elswait){
  
      if(path.tagName=='IMG'){
        if(!path.dataset.lazy){
          await this.loadImage(path)
  
        }
      }
      else if(path.tagName=='VIDEO'){
        if(!path.dataset.lazy){
          await this.loadVideo(path)
          path.classList.add('Ldd')
        }
      }
    }
    
  }
  
  
  export async function newImages(){
    const newimages = document.querySelectorAll('img')
    let images1 = Array.prototype.slice.call(newimages)
    let images2 = Array.prototype.slice.call(this.DOM.images)
    // // console.log(array1)
    // // console.log(array2)
    let imagesfiltered = images1.filter(val => !images2.includes(val))
    let promises = []
    for(let path of imagesfiltered){
      if(path.classList.contains('Wait')){
        promises.push(this.loadImage(path))
  
      }
      else{
        this.loadImage(path,1)
      }
  
    }
  
    await Promise.all(promises)
    this.DOM.images = this.DOM.el.querySelectorAll('img')
  }
  
  
  export async function loadImage(elem,nowait = null) {
    
      return new Promise((resolve, reject) => {
        
        if(elem.getAttribute('src')){
          resolve(elem)
          return false
        }
        let img = new Image()
        let url = ''
        if(elem.dataset.src){
          
          url = elem.dataset.src
        }
       
  
  
        
        let gif=0
        if(/\.(gif)$/.test(url)){
          gif=1
        }
  
        elem.onload = () => {
          elem.classList.add('Ldd')
          delete elem.dataset.src
          resolve(elem)
        }
  
        elem.onerror = () => {
          resolve(elem)
        }
  
        img.onload = () =>{
          elem.src = url
        }
  
        img.onerror = () =>{
          elem.src = url
          resolve(elem)
        }
  
        img.src = url
        if(gif==1){
          elem.src = url
          elem.classList.add('Ldd')
        }
        
        
      })
  
  
  }
  
  export async function loadVideos(){
    this.DOM.videos = this.DOM.el.querySelectorAll('video')
    const videoswait = this.DOM.el.querySelectorAll('video.Wait')
    const videosnowait = this.DOM.el.querySelectorAll('video:not(.Wait)')
    
    let promiseswait = []
    for(let path of videoswait){
     
      promiseswait.push(this.loadVideo(path))
  
    }
    await Promise.all(promiseswait)
    this.scaleLoads(videosnowait)
  }
  
  
  export async function newVideos(){
    const newvideos = this.DOM.el.querySelectorAll('video')
    let videos1 = Array.prototype.slice.call(newvideos)
    let videos2 = Array.prototype.slice.call(this.DOM.videos)
    // // console.log(array1)
    // // console.log(array2)
    let videosfiltered = videos1.filter(val => !videos2.includes(val))
    let promises = []
  
    for(let path of videosfiltered){
      if(path.classList.contains('Wait')){
        promises.push(this.loadVideo(path))
  
      }
      else{
        this.loadVideo(path,1)
      }
  
    }
    await Promise.all(promises)
    this.DOM.videos = this.DOM.el.querySelectorAll('video')
  }
  
  
  function cleanVid(elem){
    elem.oncanplay = null
    elem.onplay = null
    elem.currentTime=0
  
    let isPlaying = elem.currentTime > 0 && !elem.paused && !elem.ended 
    && elem.readyState > elem.HAVE_CURRENT_DATA
  
  
    if(!isPlaying && !elem.dataset.auto){
      elem.pause()
    }
  }
  export async function loadVideo(elem, nowait = false) {
    // Add preload="metadata" to video tag and then listen to loadedmetadata event. It works in IOS Safari as well
  
  
    return new Promise((resolve, reject) => {
      if(elem.dataset.loop){
        elem.loop = false
      }
      else{
        elem.loop = true
      }
      elem.muted = true
      elem.autoplay = true
      elem.setAttribute('webkit-playsinline', 'webkit-playsinline')
      elem.setAttribute('playsinline', 'playsinline')
      elem.onplay = () => {
  
        elem.isPlaying = true
        
      }
      
      elem.oncanplay = () => {
        if (elem.isPlaying) {
          elem.classList.add('Ldd')
          cleanVid(elem)
          resolve(elem)
        }
      }
      if(elem.dataset.opac){
        if(this.main.webm==true){
          elem.src = elem.dataset.src+'.webm'
        }
        else{
          elem.src = elem.dataset.src+'.mp4'
  
        }
      }
      else{
        elem.src = elem.dataset.src
  
      }
      elem.onerror = () =>{
        resolve(elem)
      }
      
      elem.play()
      
    })
  
  }

=== FILE END: src/lib/page/loads.js ===



=== FILE START: src/lib/page/ios.js ===

// import Write from '/ios⛓️⛓️⛓️/Write'

import lazyVideo from '/ios⛓️⛓️⛓️/lazyVideo'
import lazyImg from '/ios⛓️⛓️⛓️/lazyImg'
// import lightNav from '/ios⛓️⛓️⛓️/lightnav.js'


export function buildThresholdList(numSteps) {
  var thresholds = []

  for (var i=1.0; i<=numSteps; i++) {
    var ratio = i/numSteps
    thresholds.push(ratio)
  }

  thresholds.push(0)
  return thresholds
}
//* función que se lanza en el callback de un io, solo se lanza si el IO tiene una clase
export function checkIo(pos,entry){
  let check = false
  check = this.ios[pos].class.check(entry,this.scroll.current)
  if(!this.ios[pos].class.isupdate){
    return false
  }
  if(check == true){
    if(this.ios[pos].class.isupdate==1){
      let i = this.iosupdaters.indexOf(pos)
      
      if(i==-1){
        this.iosupdaters.push(pos)
      }
    }
    else if(this.ios[pos].class.isupdate==2){
      let i = this.updaters.indexOf(pos)
    
      if(i==-1){
        this.updaters.push(pos)

      }
    }
    else{
      this.observer.unobserve(entry.target)
      
    }
  }
  
  else{
    if(this.ios[pos].class.isupdate==1){
      let i = this.iosupdaters.indexOf(pos)
      if(i!=-1){
        this.iosupdaters.splice(i, 1)
      }
    }
    else if(this.ios[pos].class.isupdate==2){
      let i = this.updaters.indexOf(pos)
      if(i!=-1){
        this.updaters.splice(i, 1)
      }
    }
  }
}


//* Se lanza en start ( que debería ir después del page.show ) y lo que hace es hacer los observers
export function callIos(){
    this.callback = (entries,observer) =>{
      entries.forEach(entry=>{
        //Si la vista no está en visible, si el elemento no tiene pos o si tiene el dataset.no ( que lo endiña el delay )
        if(entry.target.dataset.no ||!entry.target.dataset.io || this.isVisible == 0){
          return false
        }
        
        
        const pos = entry.target.dataset.io
        if(this.ios[pos]){
          if(this.ios[pos].class){
            if(this.ios[pos].class.check){
              this.checkIo(pos,entry)
              
            }
          }
          else{
            if(entry.isIntersecting){
              this.inViewAddClass(entry)
            }
            else{
              entry.target.parentNode.classList.remove('inview')
              entry.target.parentNode.classList.remove('okF')
            }
            


          }
        }

        

      })
    }
    
    let root = null
    
    if(this.main.isTouch){
      // root = document.body
      this.optionsob = {
        root:root,
        // threshold:this.buildThresholdList(500)
        // threshold:[0,.2,.4,.6,.8,1]
        // threshold: []
        threshold:[0,1]
      }
    }
    else{
      this.optionsob = {
        root:root,
        // threshold:this.buildThresholdList(500)
        // threshold:[0,.2,.4,.6,.8,1]
        // threshold: []
        threshold: [0,1]
      }
    }
    

    this.observer = new IntersectionObserver(this.callback,this.optionsob)

    // this.ios = this.DOM.el.querySelectorAll('.iO')
    
    if(this.ios){
      this.ios.forEach((el)=>{
        if(el.class){
          //el noob es por si no quieres que lo observe
          if(el.class.noob==1){
            return false
          }
        }
        this.observer.observe(el.el)
      })
    }

}


//* Hace la query de los ios, y lanza la fn iO, para seleccionar el tipo de iO
export function createIos () {
    this.DOM.ios = this.DOM.el.querySelectorAll('.iO')
    if(this.DOM.ios){
      let animobj = ''
      for(let[index,anim] of this.DOM.ios.entries()){
        animobj = this.iO(index,anim)


        this.ios.push(animobj)
      }
      //* El sort este, no sé si sirve
      // this.ios.sort((a, b) => {
      //   if(!a.class){
      //     return 1
      //   }
      //   if(a.class.prior == b.class.prior) {
      //     return 0; 
      //   }
      //   if(a.class.prior < b.class.prior) {
      //     return -1;
      //   }
      //   return 1;
      // })
    }
  }
  
  //* Para las cargas de Ajax que genera nuevos elementos, buscar los Ios nuevos y elimina los que ya no están
  
  export async function newIos(fromel = null){
    let newios = null
    if(fromel == null){
      newios = document.body.querySelectorAll('.iO')
  
    }
    else{
      newios = fromel.querySelectorAll('.iO')
    }
  
    if(newios.length == 0){
      return false
    }
  
    newios = Array.prototype.slice.call(newios)
    let oldios = Array.prototype.slice.call(this.DOM.ios)

    for(let [i,a] of this.DOM.ios.entries()){
      let foundio = newios.find(element => element === a)
      

      if(foundio==undefined){
        let pos = a.dataset.io
        if(this.ios[pos]){
          if(this.ios[pos].class){
            if(this.ios[pos].class.isupdate==1){
              let i = this.iosupdaters.indexOf(pos)
              if(i!=-1){
                this.iosupdaters.splice(i, 1)
              }
            }
            else if(this.ios[pos].class.isupdate==2){
              let i = this.updaters.indexOf(pos)
              if(i!=-1){
                this.updaters.splice(i, 1)
              }
            }
          }
        }
        this.observer.unobserve(a)
        delete this.ios[pos]



      }

    }

    this.ios = this.ios.filter(x => x !== undefined)
    //Se borran los antiguos que ya no existen y se limpia el array    


    //se buscan los nuevos
    for(let [i,a] of newios.entries()){
      let foundio = oldios.find(element => element === a)
      
      if(foundio==undefined){
        let newindex = this.ios.length
        let animobj = this.iO(newindex,a)
           
        this.ios.push(animobj)
        let last = this.ios.length-1
        if(this.ios[last].class){
          this.ios[last].class.onResize(this.scroll.current)
        
        }
        this.observer.observe(this.ios[last].el)
        
      }
    }

    this.DOM.ios = document.body.querySelectorAll('.iO')

  }

export  function iOpage(animobj){

    return animobj

}
//* Búsqueda de elementos Ios, lanza ioPage para buscar los específicos por page
export  function iO(index,anim){
    if(anim.dataset.io){
      return false
    }
      anim.dataset.io = index
    let animobj = {
      el: anim,
      pos: index,
      active: false
    }

    if(anim.classList.contains('iO-lazyV')){
      animobj.class = new lazyVideo(animobj,this.main.isTouch,this.main.vidauto,this.main.events.anim)
       
    }
    else if(anim.classList.contains('iO-lazyI')){
      animobj.class = new lazyImg(animobj,this.main.device,this.main.isTouch)
      
    }
    else{


      if(anim.classList.contains('iO-std')){

        this.main.events.anim.detail.state = 0
        this.main.events.anim.detail.el = anim.parentNode
        document.dispatchEvent(this.main.events.anim)


        if(anim.parentNode.tagName=='A' || anim.parentNode.tagName=='BUTTON'){

          anim.parentNode.onmouseenter = () =>{
            this.main.events.anim.detail.state = 1
            this.main.events.anim.detail.el = anim.parentNode
            document.dispatchEvent(this.main.events.anim)
          }

        }
      }


      animobj = this.iOpage(animobj)
    }

    if(animobj.class){
      if(animobj.class.prior==undefined){
        animobj.class.prior = 10
      }
      
    }
    return animobj

}

//* Mete clase y deja de observar ( se usa cuando no tiene ningún tipo )
export function inViewAddClass(entry){
    // if(entry.intersectionRatio > 0.6){

      entry.target.parentNode.classList.add('inview')
      if(!entry.target.parentNode.dataset.bucle && entry.target.parentNode.classList.contains('stview')){
        return false
      }
      entry.target.parentNode.classList.add('stview')
      if(entry.target.classList.contains('iO-std')){

        this.main.events.anim.detail.state = 1
        this.main.events.anim.detail.el = entry.target.parentNode
        
        document.dispatchEvent(this.main.events.anim)
        
        if(entry.target.parentNode.dataset.bucle){
          entry.target.parentNode.classList.add('okF')

          return false

        }
      }
      // this.observer.unobserve(entry.target)
    // }
}


 //* Para mostrar los ios,lanza el show por si en el create se tiene que poner una animación de los ios a 0
 //* y se respetan delays y demás
export  function showIos(){
    this.waitres = 0
    for(let a of this.ios){

      if(a.el.dataset.delay){
        a.el.dataset.no = 'true'
        a.el.style.display = 'none'
        setTimeout(()=>{

          a.el.removeAttribute('data-no')
          a.el.style.display = 'block'
          a.el.style.visibility = 'visible'

          if(a.class){
            if(a.class.create){
              a.class.create()
              a.class.isstarted = 1
            
            }
            if(a.class.check){
              let bound = a.el.getBoundingClientRect()
              let entry = {
                boundingClientRect:{
                  top:bound.top,
                  bottom:bound.bottom,
                  left:bound.left,
                  right:bound.right,
                  width:a.el.clientWidth,
                  height:a.el.clientHeight
                }
              }

              this.ios[a.el.dataset.io].class.onResize(this.scroll.current)
              
              this.ios[a.el.dataset.io].class.update(this.speed,this.scroll.current)
              
              this.checkIo(a.el.dataset.io,entry)

            }
          }
        },a.el.dataset.delay)
        
      }
      if(a.el.dataset.await){
        setTimeout(()=>{

          a.el.style.visibility = 'visible'
        },a.el.dataset.await)
        if(this.waitres < a.el.dataset.await){
          this.waitres = parseInt(a.el.dataset.await)
        }
      }
      else{
        a.el.style.visibility = 'visible'
        if(a.class){
          if(a.class.check){
            let bound = a.el.getBoundingClientRect()
            let entry = {
              boundingClientRect:{
                top:bound.top,
                bottom:bound.bottom,
                left:bound.left,
                right:bound.right,
                width:a.el.clientWidth,
                height:a.el.clientHeight
              }
            }

            this.ios[a.el.dataset.io].class.onResize(this.scroll.current)

            this.ios[a.el.dataset.io].class.update(this.speed,this.scroll.current)

            this.checkIo(a.el.dataset.io,entry)

          }
        }
      }

    }
    this.waitres +=24
}

//* Para animar los ios cuando se hace scroll



=== FILE END: src/lib/page/ios.js ===



=== FILE START: src/lib/page/create.js ===



// import Selc from '/atoms🧿🧿🧿/Selc'
// import Chk from '/atoms🧿🧿🧿/Chk'
import Link from '/atoms🧿🧿🧿/Link'
import Title from '/atoms🧿🧿🧿/Title'


export async function create (content,main,temp=undefined) {



    this.ios = []
    this.iosupdaters = []
    this.updaters = []
    
    this.components = {

    }
    this.main=main
    
    if(this.main.isTouch){
      this.scroll = {
        target: 0,
        current:0,
        limit:0,
        last:0,
        down:1
      }
      
    }
    else{
      this.scroll = {
        target:0,
        last:0,
        limit:0,
        down:1
      }
    }
    

    
}

//* Función crear componentes
export async function createComps(){


  if(this.main.device > 1){
    if(this.DOM.el.querySelectorAll('.footer')){
      for(let a of this.DOM.el.querySelectorAll('.footer .Awrite .iO')){


        a.parentNode.classList.add('ivi')
        a.parentNode.classList.add('nono')
        a.parentNode.classList.add('stview')
        
        
        

    }
    }

  }


}


export  function cleanP(){
    if(this.DOM.el.querySelector('p:empty')){
      for(let p of this.DOM.el.querySelectorAll('p:empty')){
        p.remove()
      }
    }
}

export function cleanWysi(){
    for(let a of this.DOM.el.querySelectorAll('.wysi img')){
      a.removeAttribute('loading')
      let src = a.src
      a.dataset.src = src
      a.removeAttribute('src')
      a.removeAttribute('width')
      a.removeAttribute('height')

      let parent = a.parentNode
      // console.log(parent.tagName)
      if(parent.tagName=='P'){
        // parent.parent.replaceChild(a,parent)

        parent.parentNode.insertBefore(a, parent)
        parent.remove()

      }

    }
}

=== FILE END: src/lib/page/create.js ===



=== FILE START: src/lib/page/comps.js ===



export async function startComps(){
    for(let [index,key] of Object.keys(this.components).entries()){

      if(Array.isArray(this.components[key])){
        for(let comp of this.components[key]){
          if(comp.load){
            await comp.load()
          }
          if(comp.initEvents){
            comp.initEvents()
          }
        }
      }
      else{
        if(this.components[key].load){
          await this.components[key].load()
        }
        if(this.components[key].initEvents){
          
          this.components[key].initEvents()
        }
      }

    }
    for(let el of this.ios){
      if(el.class!=null){
        if(el.class.initEvents){
          el.class.initEvents()
        }
        if(el.class.load){
          if(el.el.dataset.nowait){
            el.class.load()
          }
          else{
            await el.class.load()

          }
        }
      }
    }
}

export async function stopComps(){
    for(let [index,key] of Object.keys(this.components).entries()){

      if(Array.isArray(this.components[key])){
        for(let comp of this.components[key]){
          if(comp.removeEvents){
            comp.removeEvents()
          }
        }
      }
      else{
        
        if(this.components[key].removeEvents){
          this.components[key].removeEvents()
        }
      }

    }


    for(let el of this.ios){
      if(el.class!= null && el.class.removeEvents){
        el.class.removeEvents()
      }
      
      this.observer.unobserve(el.el)

    }

}


=== FILE END: src/lib/page/comps.js ===



=== FILE START: src/lib/page/pagemain.js ===


//Create
import {
    create,
    createComps,
    cleanP,
    cleanWysi,
    } from './create.js'
    //Comps
    import {
    startComps,
    stopComps
    } from './comps.js'
    //Events
    import {
    onResize,
    resizeLimit,
    onScroll,
    onTouchDown,
    onTouchMove,
    onTouchUp,
    onWheel
    } from './events.js'
    //ios
    import {
    buildThresholdList,
    checkIo,
    callIos,
    createIos,
    newIos,
    iOpage,
    iO,
    inViewAddClass,
    showIos,
    } from './ios.js'
    //loads
    import {
    timeout,
    loadRestApi,
    loadImage,
    loadImages,
    newImages,
    loadVideos,
    newVideos,
    loadVideo,
    scaleLoads
    } from './loads.js'
    //scroll
    import {
    stopScroll,
    startScroll,
    animIosScroll
    } from './scroll.js'
    //showhide
    import {
    getReady,
    show,
    animIntro,
    animOut,
    start,
    hide
    } from './showhide.js'
    
    
    class Page{
      constructor (main) {
    
    
        this.content = document.querySelector("#content")
        this.main = main
        // this.footer = footer
        this.speed = 0
        this.isVisible = 0
        this.isScrollable = 1
        this.firstload = 1
        
    
        this.font = parseFloat(getComputedStyle(document.documentElement).fontSize)
      }
      
      update(speed,posy) {
        if(this.isVisible == 0){
          return false
        }
    
        this.speed = speed
        
    
        for(let c of this.updaters){
          this.ios[c].class.update(this.speed,posy)
        }
    
        
      }
    
    }
    
    //Create
    Page.prototype.create=create
    Page.prototype.createComps=createComps
    Page.prototype.cleanP=cleanP
    Page.prototype.cleanWysi=cleanWysi
    //Comps
    Page.prototype.startComps=startComps
    Page.prototype.stopComps=stopComps
    //Events
    Page.prototype.onResize=onResize
    Page.prototype.resizeLimit=resizeLimit
    Page.prototype.onScroll=onScroll
    Page.prototype.onTouchDown=onTouchDown
    Page.prototype.onTouchMove=onTouchMove
    Page.prototype.onTouchUp=onTouchUp
    Page.prototype.onWheel=onWheel
    //ios
    Page.prototype.buildThresholdList=buildThresholdList
    Page.prototype.checkIo=checkIo
    Page.prototype.callIos=callIos
    Page.prototype.createIos=createIos
    Page.prototype.newIos=newIos
    Page.prototype.iOpage=iOpage
    Page.prototype.iO=iO
    Page.prototype.inViewAddClass=inViewAddClass
    Page.prototype.showIos=showIos
    //loads
    Page.prototype.timeout=timeout
    Page.prototype.loadRestApi=loadRestApi
    Page.prototype.loadImage=loadImage
    Page.prototype.loadImages=loadImages
    Page.prototype.newImages=newImages
    Page.prototype.loadVideos=loadVideos
    Page.prototype.newVideos=newVideos
    Page.prototype.loadVideo=loadVideo
    Page.prototype.scaleLoads=scaleLoads
    
    
    //scroll
    Page.prototype.stopScroll=stopScroll
    Page.prototype.startScroll=startScroll
    Page.prototype.animIosScroll=animIosScroll
    //showhide
    Page.prototype.getReady=getReady
    Page.prototype.show=show
    Page.prototype.animIntro=animIntro
    Page.prototype.animOut=animOut
    Page.prototype.start=start
    Page.prototype.hide=hide
    
    
    
    
    export default Page

=== FILE END: src/lib/page/pagemain.js ===



=== FILE START: src/lib/page/showhide.js ===


//READY
export async function  getReady() {
    
    this.cleanP()
    this.cleanWysi()
    await this.startComps()

}


//INTRO
export async function show(){
    this.showIos()
    this.onResize()
    await this.timeout(1)

    
}

export async function start(val = 0){

    this.isVisible = 1



    let result = await this.animIntro(val)
    this.callIos()
    return result

}


export async function animIntro(){
  await gsap.fromTo(this.DOM.el,{opacity:1,duration:.45,delay:.1})

}
//OUT
export async function animOut(){

  if(this.main.isTouch){
    this.DOM.el.classList.add('isGone')  
  
  }
  for(let a of this.DOM.el.querySelectorAll('.inview')){
    
    a.classList.remove('inview')
    a.classList.remove('stview')
    this.main.events.anim.detail.state = -1
    this.main.events.anim.detail.el = a
    document.dispatchEvent(this.main.events.anim)

  }

  // await gsap.to(this.DOM.el,{opacity:.3,duration:.45})

}

export async function hide() {
    
  this.isVisible = 0
  this.stopComps()

}

=== FILE END: src/lib/page/showhide.js ===



=== FILE START: src/lib/lazyImg.js ===

// From ios⛓️⛓️⛓️/lazyImg/index.js

import { checkPos,clamp } from '/js🧠🧠🧠/defaults/math🧮.js'

export default class{
  constructor (obj,device,touch) {
    
    this.el = obj.el    


    this.pos = obj.pos
    this.device = device
    this.touch = touch
    
    this.DOM = {
      el:obj.el,
      img:obj.el.parentNode.querySelector('img'),
    }


    this.active = 0
    this.isupdate = 3
    

    this.create()
  }
  
  create(){

    
  }
  check(entry,pos){
    let vis = false
    if(entry.isIntersecting == undefined){
      return false
    }
    vis = entry.isIntersecting
    if(vis==true){
      this.start()
      vis = entry.isIntersecting
      
      if(this.DOM.img.getAttribute('src')){
        return -1
      }


      let img = new Image()
      let url = ''
      if(this.DOM.img.dataset.lazy){
          
        url = this.DOM.img.dataset.lazy
      }
      
      let gif=0
      if(/\.(gif)$/.test(url)){
        gif=1
      }


      this.DOM.img.onload = () => {
        delete this.DOM.img.dataset.lazy
        this.DOM.img.classList.add('Ldd')
      
      }
      img.onload = () =>{
        this.DOM.img.src = url
      }
      img.src = url

      if(gif==1){
        this.DOM.img.src = url
        this.DOM.img.classList.add('Ldd')
      }

      vis = -1
    }
    else if(vis==false){
      this.stop()
    }
    return vis

  }
  
  start(){
    this.DOM.img.classList.add('ivi')
    this.active = 1

  }
  
  stop(){

    this.DOM.img.classList.remove('ivi')
    this.active = 0

  }

  initEvents(){

  }
  removeEvents(){

  }
  update(){
      
      
  }

  onResize(scrollCurrent){
    this.h = window.innerHeight
    this.max =this.el.clientHeight

    this.checkobj = {
      firstin: Math.min(this.h,this.el.clientHeight)*0.92,
      firstout:this.h*0.92,
      secout:this.el.clientHeight*-1,
      limit:this.el.clientHeight

    }
  }
  
}


=== FILE END: src/lib/lazyImg.js ===



=== FILE START: src/lib/lazyVideo.js ===

// From ios⛓️⛓️⛓️/lazyVideo/index.js


export default class{
    constructor (obj,touch,canplay,animev) {
      
      this.el = obj.el    
  
      this.pos = obj.pos
      this.touch = touch
      this.canplay = canplay
      this.animev = animev
      
      this.DOM = {
        el:obj.el,
        video:obj.el.parentNode.querySelector('video'),
      }
      this.auto = false
      if(this.DOM.video.dataset.auto){
        this.auto = true
  
        this.DOM.video.loop = true
        this.DOM.video.muted = true
        this.DOM.video.setAttribute('webkit-playsinline', 'webkit-playsinline')
        this.DOM.video.setAttribute('playsinline', 'playsinline')
  
  
        if(this.touch){
  
          this.DOM.video.load()
        }
      }
  
      this.active = 0
      
      
      this.isloaded = 0
  
  
  
  
      this.create()
    }
    
    create(){
      this.toggleAudio = async(out=null) =>{
        if(!this.DOM.b || this.togglein == 1){
          return false
        }
        this.togglein = 1
        
        if(out==1 || this.DOM.video.muted == false){
  
          this.DOM.video.muted = true
  
  
          
  
  
          this.animev.detail.state = -1
          this.animev.detail.el = this.DOM.bOn
          document.dispatchEvent(this.animev)
  
          await window.waiter(64)
          
          this.animev.detail.state = 1
          this.animev.detail.el = this.DOM.bOff
          document.dispatchEvent(this.animev)
  
  
        }
        else{
  
  
  
          this.DOM.video.muted = false
          
          this.animev.detail.state = -1
          this.animev.detail.el = this.DOM.bOff
          document.dispatchEvent(this.animev)
  
          await window.waiter(64)
  
          this.animev.detail.state = 1
          this.animev.detail.el = this.DOM.bOn
          document.dispatchEvent(this.animev)
        }
  
        await window.waiter(320)
  
  
        this.togglein = 0
      }
  
  
  
      if(this.DOM.el.parentNode.querySelector('button.cAudio')){
        this.DOM.b = this.DOM.el.parentNode.querySelector('button.cAudio')
  
        this.DOM.bOn = this.DOM.b.querySelector('.on')
        this.DOM.bOff = this.DOM.b.querySelector('.off')
        
        
  
        this.animev.detail.state = 0
        this.animev.detail.el = this.DOM.bOn
        document.dispatchEvent(this.animev)
  
  
        this.animev.detail.state = 0
        this.animev.detail.el = this.DOM.bOff
        document.dispatchEvent(this.animev)
  
        this.animev.detail.state = 1
        this.animev.detail.el = this.DOM.bOff
        document.dispatchEvent(this.animev)
  
  
  
        this.DOM.b.onclick = ()=> this.toggleAudio()
      }
  
      
    }
    check(entry,pos){
      let vis = false
      let isPlaying = false
  
        if(entry.isIntersecting==undefined){
          // this.DOM.video.pause()
          return false
        }
        else if(entry.isIntersecting==true){
          this.start()
          if(this.isloaded == 1){
            if(this.touch == 0){
              this.DOM.video.play()
  
            }
            else{
              this.DOM.video.setAttribute('autoplay', 'true')
  
            }
          }
          else{
              this.DOM.video.src = this.DOM.video.dataset.lazy
              if(this.touch == 0){
                this.DOM.video.play()
  
              }
              else{
                this.DOM.video.setAttribute('autoplay', 'true')
  
              }
             
          }
        }
        else{
          this.stop()
          isPlaying = this.DOM.video.currentTime > 0 && !this.DOM.video.paused && !this.DOM.video.ended 
          && this.DOM.video.readyState > this.DOM.video.HAVE_CURRENT_DATA
          if(isPlaying){
            if(this.touch == 1){
  
              this.DOM.video.setAttribute('autoplay', 'false')
              this.toggleAudio(1)
            }
            else{
              this.DOM.video.pause()
              this.toggleAudio(1)
            }
          }
        }
       
        
        
  
      return false
  
    }
    
    start(){
      this.active = 1
      this.DOM.video.classList.add('ivi')
    }
    
    stop(){
  
      this.active = 0
      this.DOM.video.classList.remove('ivi')
  
    }
  
    initEvents(){
      this.DOM.video.oncanplay = () => {
        this.isloaded = 1
        this.DOM.video.classList.add('Ldd')
        
      }
      this.DOM.video.onplay = () => {
        this.DOM.video.isPlaying = true
        
      }
    }
    removeEvents(){
      this.DOM.video.pause()
      this.DOM.video.muted=true
  
    }
    update(){
        
        
    }
  
    onResize(scrollCurrent){
      this.h = window.innerHeight
      this.max =this.el.clientHeight
  
      this.checkobj = {
        firstin: Math.min(this.h,this.el.clientHeight)*0.92,
        firstout:this.h*0.92,
        secout:this.el.clientHeight*-1,
        limit:this.el.clientHeight
  
      }
    }
    
  }
  

=== FILE END: src/lib/lazyVideo.js ===



=== FILE START: src/lib/start/constructor.js ===

// From start🏁🏁🏁/constructor🫀.js

//                                            `/+o/.
    //                        .+sso+/:oydyo/:-:+shdys/    `-:.     `-/+o+/`
    //                    `/sdh+/::/::ss:`ymdhyso//hmMNyhNNms+ososys+/-:/shms/`
    //                 .+hNNy++oo+/.`.--/osyhdmNNMMMMMMMMMNdsssssoso+hhhhsoo+ymdo.
    //               -smNy/+ymmmmmNNNNMNMMMMMNNNmmNMMMMMMMMMho:///:--shydNMMNdo-sNs`
    //             -hNd+-sNMNdmNMMMNNNMNNNMMMddNMMNNmNMMMMMMNmy+///::/:-:/++ymNNdmMN:
    //           `sNMs`+NMNNNMMMMNNNMMMMMMNmhyso///+ohMmoNMmoo+/::/-:oymNNmsosshdhmMM/
    //          +NMMy`hMMMhyNMNMMNNNMds:-.`-:syddmNMMmyo`+yMMho:..-+//++omMNNNNNNNmdNMs
    //        :mMMMh`yMNdodNNNMNMMMs.+sdmmmmmdhNMMMNhy/..`-syhNmdyssso+/.`:yNMMMMNMNMMMy
    //       :NMNh:-+MMh+mdNNNNNMd.+NNMMMMMMMMmho:-......:--::ohNMMMMMMNmNy/.oNMNmNMNMMMs
    //      :NMm+/dmmMNydyhNdhMMN.yMMNmhysso+:-``        ```.--:/+sdMMMMMNNNm:-mMNNNNMMMMy
    //     :NMy/hNMMMMmNddsh/NmMy-Mms:..`.--.`                ``..-.:yNMMMMNMNs:NMMMNNNNMMy
    //    :NNy/mMMMMMMmNMMshsNdMo/d-...``                       ```...-yMMMNNMd`NMMNMdmoNMM-
    //   /mMm+NMNNMMNMNNNNNNNNMMmom/                              ```..`+NMMMMh`NMMMMNNdhNMh
    //  +NMMmmMNyNMNMMMMMNmmmNMdNNyh+.                             ``````/NMMM::MMMMNMNNmNMN
    // +MNNMMMNymMNNMMMNNNNNMh+:+dNmddhyoo+`                        ````.`sMMN`sMNNMNNMNNNNN
    // dNNNMNNddMNNNNNNmymMN+---::/shdhyyy:                         `````..hMo.NMNMNMMMNmMMd
    // dNNNMMNmNNNmmNMNdNMM+.-..----.-:::.                          ````...:mh/NMMMNMMMNNMMh
    // sMNNMMNMNNmyNMNdmNMo--.....                                  ``...---:dNMNMMNMMNNNMMN.
    // :NNNMMMNNNsmMNmMNMy...`.-.`                                    `.-----:odNmmNMMMMMNMMo
    // .NMMMmMMMNmMNNNNMm:-.```..                                       ``-----:/o//dMMMNMMMm
    // .NMMMNMMNMMNMNNNNs--.``...                                          `....---..dMNMMMMM`
    // .NNMMNNNNNMMMNNNN:-...`...                                           ```.....`+MMMMMMM.
    // .MNNNNNNNMMMMMNNy.......-.`                                          ``..---.`.NMMMMMM`
    // `NMNMMNNNMMNMMMm-...`.-----.`                                        ``.-----.`yMMMMMd
    //  dMMMNNNNMMNNMMo`-....----..`          ``                      `.`` ```.------`:MMMMM-
    //  /MMNMNNNMMNMMN-`.`..-.--.` `--..-:-.-.``..``               ```.-......--.----..NMMMd
    //  `mMNMNNMMMNNMN.``...-.-../hddyysyhysyyso+--/::-..--...----:::+syyyyhhdddy+:-.-.hMMM:
    //   :NNNNNNMMMMMN.`....--.:dy/:-.-/+++ososss+/:+shyo/::/:+os+:+syosyoso+/://ss//.`+MMm
    //    +MdmNNMNMMMN+.--....:+-.-:+ooymdddmdhyo++ss+/yMo.`..oNsyhdhmdmmmmNmdo:-.--:+-:MM/
    //   `y/..-+dNNMMMo-shhyo++--+sso-`dsymoso.smyso+//.od+/:/ho+yyhd/ymsNhyy./yy/``.-hhmm`
    //   .s+md+- oMMMm``.-/sy//-.+/s.  odys+s-  /shyso+.sm+:::yd/hh+:`.hyyhy- `/y/.` `hs/s`
    //   -oyMNyhs:NMMo     `.-`         .---` ``.`/::+s/ms````-mo+:`````.--` ````     `sNm`
    //   `hsMh`.hymMM:       `-         `          .:+:hy`     od:-`                  .+sM-``
    //    o+o/``-/mMM-        .-                ``.```hy`       s.`.`                 -/+M+``
    //   .s `./NMMMM-         --            ````  `:ho`        .s`  ```             ./.+My`
    //    /: `+MMdMM/          -.  `       `   ..+++-           :d/.             ``:o-`oMy
    //     o. .sdNMMm`            `--:://+//.`-///:.           `.ohooo:-.`` `.-:+//:..`hMy
    //     `s```.yMMMs                  ```     .y+  `::.:----.-``o:-::/:::--:::-----..mMo
    //      :s` `oMNMN-                         :N+  -NNhy/:/sds./:..----------------`/MN.
    //       +o``-NMNMd`                      `-syyoo++/.++:so/+yN+..--....-..-....--`dM+
    //        +:.`oMNNN`                     .:-` `.::.` `--..---/+/---.```........-.:d:
    //         ./++Ny::`                   `--`          .--..-----::-..```......---.s.
    //           `:os.--`                  .`            `.. ``.------.`.```..-----.:o
    //             `h-..`                 ``        .:syy/-/ydho-.--...`````.------.+.
    //              +o`.`                        ./ymNNNNNNNmmNNNh:....``.```.-----:s
    //              `h-`.                    -/+oyo/:----:---.--:+sso:........--::-+:
    //               /d...                 `.++:  -:--/+:/oo+o++-.``--.....-----:-:y
    //               `Md:.`                ``     `-:/+ooooo+/-........-----------yo
    //                mNNs-`                     `..-/oo+://:/oo:......----------os
    //                h:+md:.                  ...``.`         `------.---------++
    //               `h..-+ddo.`                            ``.----------------s:
    //                 h` .--/ydy:`                   `...--------------------+y.
    //                 h`   ..--+yds+.`               `....----------------:+dN`
    //                `y      `.-.-:sdhs:.`    `...````..----------------:smsdm
    //                `h         .--..-+ymdy+/:----:----------------.-/shs+.`os
    //                `h           `..--..:sdmmhyo/::----------::/+syhy/....`+-
    //                -y              `..--..--/oosyyyhhhyyyssoooo/:.`...`.` /-
    //                `.                  `..--.......................````   +`
    //                                       `...------..-.........``
    //                                           ``..-.--........``
    //                                                ```..```





    import '/scss🖌️🖌️🖌️/base🔧/normalize.scss'
    import '/scss🖌️🖌️🖌️/base🔧/generics.scss'
    import '/scss🖌️🖌️🖌️/base🔧/swiper.scss'
    import '/scss🖌️🖌️🖌️/base🔧/♿.scss'
    
    
    import '/scss🖌️🖌️🖌️/theme/rotate🔄.scss'
    import '/scss🖌️🖌️🖌️/theme/scroll.scss'
    import '/scss🖌️🖌️🖌️/theme/main🐙.scss'
    // import '/scss🖌️🖌️🖌️/theme/grid.scss'
    
    import '/scss🖌️🖌️🖌️/theme/fonts🔤.scss'
    import '/scss🖌️🖌️🖌️/theme/wysi.scss'
    
    // import '/scss🖌️🖌️🖌️/theme/uikit⚙️.scss'
    
    
    
    import '/atoms🧿🧿🧿/Awrite.scss'
    import '/atoms🧿🧿🧿/Atitle.scss'
    
    import '/components🦾🦾🦾/Mouse🐭/index.scss'
    import '/components🦾🦾🦾/Footer🔥'
    
    import browser from './browser🕸️.js'
    import loadRestApi from './firstload📊.js'
    
    
    import App from '/main🐙🐙🐙'
    
    import FontFaceObserver from 'fontfaceobserver'
    // import anime from 'animejs/lib/anime.es.js'
    
    import gsap from "gsap"
    import SplitType from 'split-type'
    
    
    
    import { Power2,Power4 } from "./ease.js"
    
    if (window.history.scrollRestoration) {
      window.history.scrollRestoration = 'manual'
    }
    
    
    
    document.documentElement.style.setProperty("--ck_hvar", window.innerHeight+'px')
    document.documentElement.classList.add('lenis-stopped')
    
    if(import.meta.env.DEV == true){
    
      document.documentElement.classList.add('dev')
      
      
    }
    // browser.revCheck()
    
    const global = browser.browserCheck()
    if(browser.glCheck()==false){
      global.webgl = 0
      document.documentElement.classList.add('AND')
    }
    else{
      if(navigator.userAgent.toLowerCase().indexOf("android") > -1){
        global.webgl = 0
        document.documentElement.classList.add('AND')
    
      }
      else{
        global.webgl = 1
    
      }
    }
    
    window.gsap = gsap
    gsap.ticker.remove(gsap.updateRoot)
    
    // window.anime = anime
    // window.Power4 = Power4
    // window.Power2 = Power2
    
    // window.gsap = gsap
    // window.Power2 = Power2
    // window.Power4 = Power4
    // // window.gsap.registerPlugin(CustomEase)
    // window.gsap.ticker.remove(window.gsap.updateRoot)
    
    // CustomEase.create("jumpy","M0,0 C0,0 0.01469,0.00118 0.0225,0.00384 0.03114,0.00678 0.0373,0.01003 0.045,0.01531 0.05437,0.02175 0.06019,0.027 0.06833,0.03531 0.07729,0.04446 0.08301,0.05052 0.09,0.06126 0.10835,0.08948 0.12012,0.10726 0.135,0.13783 0.15528,0.1795 0.16554,0.20527 0.18167,0.24958 0.20191,0.30521 0.21165,0.33689 0.22833,0.39428 0.2477,0.46092 0.25693,0.49719 0.27333,0.565 0.2925,0.64425 0.3017,0.68628 0.31833,0.76635 0.33738,0.85807 0.35992,0.98074 0.36333,0.99833 0.367,0.98976 0.39079,0.92757 0.41167,0.88536 0.42663,0.8551 0.43825,0.83737 0.45667,0.80962 0.46416,0.79833 0.47043,0.792 0.48,0.7824 0.4875,0.77488 0.49296,0.77021 0.50167,0.7645 0.50943,0.75941 0.51555,0.75621 0.52417,0.75343 0.53199,0.75092 0.53854,0.74986 0.54667,0.75001 0.55484,0.75016 0.5614,0.75142 0.56917,0.75426 0.57814,0.75754 0.58445,0.76112 0.5925,0.76674 0.60126,0.77286 0.60664,0.7778 0.61417,0.78571 0.62376,0.79581 0.62997,0.80237 0.6375,0.81408 0.65594,0.84278 0.66746,0.86097 0.6825,0.89204 0.70173,0.93177 0.72026,0.98293 0.72667,0.99834 0.73065,0.99401 0.74305,0.9793 0.75417,0.9685 0.76124,0.96162 0.76611,0.95737 0.77417,0.95216 0.782,0.94709 0.78804,0.94381 0.79667,0.941 0.80448,0.93846 0.81103,0.93739 0.81917,0.93751 0.82734,0.93764 0.83384,0.93894 0.84167,0.94167 0.85002,0.94459 0.85584,0.9478 0.86333,0.95292 0.87204,0.95887 0.87749,0.96358 0.885,0.97126 0.89458,0.98107 0.90284,0.99244 0.90833,0.99896 0.91422,0.99633 0.92376,0.99071 0.93333,0.98778 0.94128,0.98534 0.94771,0.98424 0.95583,0.98439 0.96401,0.98455 0.97051,0.98589 0.97833,0.98865 0.98669,0.99161 1,1 1,1 ")
    
    
    window.SplitType = SplitType
    
    // EL TIPO DE INCREMENTO PARA TAMAÑOS POR ENCIMA DE DISEÑO
    global.design = {
      L:{
        w : 1440,
        h : 800,
        multi:.4,
        total:0,
        ratio:5.56,
        wide:((window.innerHeight*10)/window.innerWidth).toFixed(2),
        
      },
      P:{
        w:390,
        h:640,
        multi:.4,
        total:0
      }
    }
    
    // console.log(global.design.L.ratio)
    // console.log(global.design.L.wide)
    
    // EL MULTI, si queremos no crezcan los elemento sería 1
    // si queremos que crezca de manera natural el rem, se pondría a 0
    
    global.design.L.total = ( ( global.design.L.w / window.innerWidth ) * 10 )
    // SE COGE LA DIFERENCIA ENTRE AMBAS Y SE HACE EL MULTI
    global.design.L.total = 10 - ((10 - global.design.L.total) * global.design.L.multi)
    // UN MATH.MIN PARA QUE NO SE PASE LA REDUCCIÓN Y HAGA EL EFECTO REM NATURAL
    global.design.L.total = Math.min(10,global.design.L.total)
    
    
    global.design.P.total = ( ( global.design.P.w / window.innerWidth ) * 10 )
    // SE COGE LA DIFERENCIA ENTRE AMBAS Y SE HACE EL MULTI
    global.design.P.total = 10 - ((10 - global.design.P.total) * global.design.P.multi)
    // UN MATH.MIN PARA QUE NO SE PASE LA REDUCCIÓN Y HAGA EL EFECTO REM NATURAL
    global.design.P.total = Math.min(10,global.design.P.total)
    
    
    //MULTI PARA EL WIDE
    // global.design.L.total *=  Math.min(1,(global.design.L.wide/global.design.L.ratio)*1.05)
    
    document.documentElement.style.setProperty("--ck_multiL", global.design.L.total)
    document.documentElement.style.setProperty("--ck_multiP", global.design.P.total)
    
    
    document.documentElement.style.setProperty("--ck_accent", '#fff')
    document.documentElement.style.setProperty("--ck_other", '#050505')
    
    //SIZES : Explicados en guides🔪🔪🔪
    if(global.isTouch == 1){
    
      document.documentElement.style.setProperty("--ck_hscr", window.screen.height+'px')
      document.documentElement.style.setProperty("--ck_hvar", window.innerHeight+'px')
      document.documentElement.style.setProperty("--ck_hmin", document.documentElement.clientHeight+'px')
      
    }
    else{
    
      document.documentElement.style.setProperty("--ck_hscr", window.innerHeight+'px')
      document.documentElement.style.setProperty("--ck_hvar", window.innerHeight+'px')
      document.documentElement.style.setProperty("--ck_hmin", window.innerHeight+'px')
    
    }
      // if(import.meta.env.DEV == true && document.documentElement.classList.contains('logme')){
      //   const user = await login()
      // }
    
      let content = document.querySelector('#content')
        Promise.all([
        // fetch(document.body.dataset.js+'/wp-json/csskiller/v1/options?device='+global.device+'&webp='+global.webp).then(resp => resp.json()),
            
    
        loadRestApi.loadRestApi(
        {
          url:document.body.dataset.js+'/wp-json/csskiller/v1/options',
          device:global.device,
          webp:global.webp,
          id:content.dataset.id,
          template:content.dataset.template,
          webgl:global.webgl,
        }),
            new FontFaceObserver('montrealbook').load(),
            new FontFaceObserver('montreal').load(),
        
        // new FontFaceObserver('TTFors').load(),
      
            
            
        ]).then((loaded) => {
    
        const M = new App([global,loaded[0]])
        
      })
      
    
    
    
      // async function login(){
      //   let info = []
      //   let formData = new FormData()
      //   info.push({label:'username', value:'aserver@csskiller.es'})
      //   info.push({label:'password', value:encodeURIComponent('jy1&K7w)i14O$BDCtC')})
      //   info.push({label:'remember', value:true})
    
    
      //   formData.set("form", JSON.stringify(info))
      //   const logtest = await fetch(document.body.dataset.js+'/wp-json/csskiller/v1/login',{
          
      //     method: 'post',
      //     body: formData
      //   })
      //   const datalog = await logtest.json()
    
      //   console.log(datalog)
    
      //   if(datalog.errors){
      //     if(typeof datalog.errors=='string'){
      //       console.log(datalog.errors)
      //     }
      //     else{
      //       console.log(Object.values(datalog.errors)[0][0])
    
      //     }
      //   }
      //   else{
      //     document.body.dataset.nonce=datalog.nonce
      //     document.body.dataset.user=datalog.user.ID
      //     document.documentElement.classList.add('logged')
    
      //   }
    
      //   return datalog
        
      // }
    
      window.lerp = function(p1, p2, t) {
        return p1 + (p2 - p1) * t
    
        // console.log('ioos')
      }
    
      window.clamp = function(min, max, num) {return Math.min(Math.max(num, min), max)}
    
    
    
      window.waiter = function (ms){
        return new Promise(resolve => setTimeout(resolve, ms))
      }
    

=== FILE END: src/lib/start/constructor.js ===



=== FILE START: src/lib/start/firstload.js ===

// From start🏁🏁🏁/firstload📊.js

async function loadRestApi({url='',device=0,webp=0,id='',template='',logged=0,visible=0,webgl=1}){
  
    if(import.meta.env.DEV == true){
  
      console.log(url+'?device='+device+'&id='+id+'&webp='+webp+'&template='+template+'&logged='+logged+'&visible='+visible)
    }
  
    let formData = new FormData()
    let info = {
      device:device,
      webp:webp,
      id:id,
      template:template,
      logged:logged,
      webgl:webgl,
      visible:visible
    }
  
    formData.set("form", JSON.stringify(info))
  
  
    if(document.body.dataset.nonce){
  
      
  
      const response = await fetch(url,{
        method: "POST",
        body: formData,
        headers: {
          'X-WP-Nonce': document.body.dataset.nonce,
          // 'Content-Type': 'application/json',
        }
      })
  
      const data = await response.json()
  
  
      return data
    }
    else{
      url +='?device='+device
      url +='&id='+id
      url +='&webp='+webp
      url +='&template='+template
      url +='&logged='+logged
      url +='&visible='+visible
      url +='&webgl='+webgl
      const response = await fetch(url,{
        method: "GET",
       
      })
      const data = await response.json()
      return data
    }
  
  }
  
  
  export default { loadRestApi }

=== FILE END: src/lib/start/firstload.js ===



=== FILE START: src/lib/start/browser.js ===

// From start🏁🏁🏁/browser🕸️.js
function browserCheck(){
    //No memoria scroll
    if (window.history.scrollRestoration) {
      window.history.scrollRestoration = 'manual'
    }
    
    //🍫
    //--🪟 2
    //--🖼️ 1
    //🖥️ 0
    //📲 3
  
    // Tablets
    // Landscape (1) is treated as desktop, receives mobile-sized images (< 1366)
    // Portrait (2) is treated as mobile, receives images < 1366
    
    //Mobile
    // Portrait only (3), takes portrait images.
  
  
    //Images
    // If larger than 0 (desktop), takes the small size (< 1366)
  
  
    // TOUCH
    const isTouch = /Mobi|Andrdoid|Tablet|iPad|iPhone/.test(navigator.userAgent)||"MacIntel"===navigator.platform&&1<navigator.maxTouchPoints
    const w = window.innerWidth
    const h = window.innerHeight
    let devnum = 0
    let  devicec = ''
    
    if(!isTouch){
      devicec = 'desktop'
      devnum = 0
      document.documentElement.classList.add("D")
  
      if(w > 1780){
        devnum = -1
      }
    }
    else{
      devicec = 'mobile'
      devnum = 3
      if(w > 767){
        if(w > h){
          devicec = 'tabletL'
          devnum = 1
        }
        else{
          devicec = 'tabletS'
          devnum = 2
        }
      }
      
      document.documentElement.classList.add("T")
      document.documentElement.classList.add(devicec)
    }
    
  
    console.log(devnum)
  
   
  
    //WebP
  
    const element = document.createElement('canvas')
    let isWebPCheck = false
    let isWebgl = false
    let file = ''
    if (element.getContext && element.getContext('2d')) {
      isWebPCheck = element.toDataURL('image/webp').indexOf('data:image/webp') === 0
      
    }
  
    
  
    let isWebMCheck = true
    const ua = navigator.userAgent.toLowerCase()
    if (ua.indexOf('safari') != -1) {
      
      if (ua.indexOf('chrome') > -1) {
      } 
      else {
        isWebMCheck = false
      }
    }
    
    let autoplay = true
    const video = document.createElement('video')
    video.isPlaying = false
    video.src = 'data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAAAAG1wNDJtcDQxaXNvbWF2YzEAAATKbW9vdgAAAGxtdmhkAAAAANLEP5XSxD+VAAB1MAAAdU4AAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAACFpb2RzAAAAABCAgIAQAE////9//w6AgIAEAAAAAQAABDV0cmFrAAAAXHRraGQAAAAH0sQ/ldLEP5UAAAABAAAAAAAAdU4AAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAoAAAAFoAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAHVOAAAH0gABAAAAAAOtbWRpYQAAACBtZGhkAAAAANLEP5XSxD+VAAB1MAAAdU5VxAAAAAAANmhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABMLVNNQVNIIFZpZGVvIEhhbmRsZXIAAAADT21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAw9zdGJsAAAAwXN0c2QAAAAAAAAAAQAAALFhdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAoABaABIAAAASAAAAAAAAAABCkFWQyBDb2RpbmcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAAAOGF2Y0MBZAAf/+EAHGdkAB+s2UCgL/lwFqCgoKgAAB9IAAdTAHjBjLABAAVo6+yyLP34+AAAAAATY29scm5jbHgABQAFAAUAAAAAEHBhc3AAAAABAAAAAQAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAAQBjdHRzAAAAAAAAAB4AAAABAAAH0gAAAAEAABONAAAAAQAAB9IAAAABAAAAAAAAAAEAAAPpAAAAAQAAE40AAAABAAAH0gAAAAEAAAAAAAAAAQAAA+kAAAABAAATjQAAAAEAAAfSAAAAAQAAAAAAAAABAAAD6QAAAAEAABONAAAAAQAAB9IAAAABAAAAAAAAAAEAAAPpAAAAAQAAE40AAAABAAAH0gAAAAEAAAAAAAAAAQAAA+kAAAABAAATjQAAAAEAAAfSAAAAAQAAAAAAAAABAAAD6QAAAAEAABONAAAAAQAAB9IAAAABAAAAAAAAAAEAAAPpAAAAAQAAB9IAAAAUc3RzcwAAAAAAAAABAAAAAQAAACpzZHRwAAAAAKaWlpqalpaampaWmpqWlpqalpaampaWmpqWlpqalgAAABxzdHNjAAAAAAAAAAEAAAABAAAAHgAAAAEAAACMc3RzegAAAAAAAAAAAAAAHgAAA5YAAAAVAAAAEwAAABMAAAATAAAAGwAAABUAAAATAAAAEwAAABsAAAAVAAAAEwAAABMAAAAbAAAAFQAAABMAAAATAAAAGwAAABUAAAATAAAAEwAAABsAAAAVAAAAEwAAABMAAAAbAAAAFQAAABMAAAATAAAAGwAAABRzdGNvAAAAAAAAAAEAAAT6AAAAGHNncGQBAAAAcm9sbAAAAAIAAAAAAAAAHHNiZ3AAAAAAcm9sbAAAAAEAAAAeAAAAAAAAAAhmcmVlAAAGC21kYXQAAAMfBgX///8b3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0OCByMTEgNzU5OTIxMCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTUgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0xIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDM6MHgxMTMgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTEgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz0xMSBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgc3RpdGNoYWJsZT0xIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PWluZmluaXRlIGtleWludF9taW49Mjkgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD00MCByYz0ycGFzcyBtYnRyZWU9MSBiaXRyYXRlPTExMiByYXRldG9sPTEuMCBxY29tcD0wLjYwIHFwbWluPTUgcXBtYXg9NjkgcXBzdGVwPTQgY3BseGJsdXI9MjAuMCBxYmx1cj0wLjUgdmJ2X21heHJhdGU9ODI1IHZidl9idWZzaXplPTkwMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAG9liIQAFf/+963fgU3DKzVrulc4tMurlDQ9UfaUpni2SAAAAwAAAwAAD/DNvp9RFdeXpgAAAwB+ABHAWYLWHUFwGoHeKCOoUwgBAAADAAADAAADAAADAAAHgvugkks0lyOD2SZ76WaUEkznLgAAFFEAAAARQZokbEFf/rUqgAAAAwAAHVAAAAAPQZ5CeIK/AAADAAADAA6ZAAAADwGeYXRBXwAAAwAAAwAOmAAAAA8BnmNqQV8AAAMAAAMADpkAAAAXQZpoSahBaJlMCCv//rUqgAAAAwAAHVEAAAARQZ6GRREsFf8AAAMAAAMADpkAAAAPAZ6ldEFfAAADAAADAA6ZAAAADwGep2pBXwAAAwAAAwAOmAAAABdBmqxJqEFsmUwIK//+tSqAAAADAAAdUAAAABFBnspFFSwV/wAAAwAAAwAOmQAAAA8Bnul0QV8AAAMAAAMADpgAAAAPAZ7rakFfAAADAAADAA6YAAAAF0Ga8EmoQWyZTAgr//61KoAAAAMAAB1RAAAAEUGfDkUVLBX/AAADAAADAA6ZAAAADwGfLXRBXwAAAwAAAwAOmQAAAA8Bny9qQV8AAAMAAAMADpgAAAAXQZs0SahBbJlMCCv//rUqgAAAAwAAHVAAAAARQZ9SRRUsFf8AAAMAAAMADpkAAAAPAZ9xdEFfAAADAAADAA6YAAAADwGfc2pBXwAAAwAAAwAOmAAAABdBm3hJqEFsmUwIK//+tSqAAAADAAAdUQAAABFBn5ZFFSwV/wAAAwAAAwAOmAAAAA8Bn7V0QV8AAAMAAAMADpkAAAAPAZ+3akFfAAADAAADAA6ZAAAAF0GbvEmoQWyZTAgr//61KoAAAAMAAB1QAAAAEUGf2kUVLBX/AAADAAADAA6ZAAAADwGf+XRBXwAAAwAAAwAOmAAAAA8Bn/tqQV8AAAMAAAMADpkAAAAXQZv9SahBbJlMCCv//rUqgAAAAwAAHVE='
    video.load()
    video.style.display = 'none'
    video.autoplay = true
    video.setAttribute('webkit-playsinline', 'webkit-playsinline')
    video.setAttribute('playsinline', 'playsinline')
    video.muted = true
    
    video.onplay = () => {
      video.isPlaying = true
    }
    video.oncanplay = () => {
      if (video.isPlaying) {
        autoplay = true
      } else {
        autoplay = false
      }
      video.pause()
      video.remove()
    }
    if(isTouch!=true){
      video.play()
    }
    else{
      video.setAttribute('autoplay', 'true')
  
    }
  
    if(ua.indexOf('firefox') > -1){
      document.documentElement.classList.add('CBff')
    }
    
  
  
    return {
      'deviceclass':devicec,
      'device':devnum,
      'isTouch':isTouch,
      'webp':+isWebPCheck,
      'webm':+isWebMCheck,
      'vidauto':+autoplay,
    }
  }
  
  function revCheck (){
    const checkfix = document.createElement('div')
    checkfix.className = 'checkfix'
    checkfix.insertAdjacentHTML('afterbegin','<div class="checkfix_t"></div>')
    
    document.querySelector('body').appendChild(checkfix)
    let ratio = ((window.innerWidth*9)/window.innerHeight).toFixed(2)
    let zoom = window.innerWidth != window.outerWidth
    document.querySelector('.checkfix_t').innerHTML = 'Width: '+window.innerWidth+'<br>Height: '+window.innerHeight+'<br>Ratio: '+ratio+'/9<br>'+(16/ratio).toFixed(3)+'<br>Zoom: '+zoom
  
    window.addEventListener('resize',()=>{
  
      let zoom = window.innerWidth != window.outerWidth
      let ratio = ((window.innerWidth*9)/window.innerHeight).toFixed(2)
      document.querySelector('.checkfix_t').innerHTML = 'Width: '+window.innerWidth+'<br>Height: '+window.innerHeight+'<br>Ratio: '+ratio+'/9<br>'+(16/ratio).toFixed(3)+'<br>Zoom: '+zoom
    })
  }
  
  function glCheck () { 
    try {
     var canvas = document.createElement('canvas'); 
  
     if(!!window.WebGL2RenderingContext &&
      (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))){
      
       return 'webgl2'
      };
     if(!!window.WebGLRenderingContext &&
      (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))){
  
       return 'webgl'
      };
      
    } catch(e) {
      return false;
    }
  }
  
  export default { browserCheck, revCheck, glCheck }
  

=== FILE END: src/lib/start/browser.js ===



=== FILE START: src/lib/webgl.js ===

import { Renderer, Camera, Transform } from 'ogl';

export function initWebGL(canvas) {
  const renderer = new Renderer({ canvas, alpha: true });
  const gl = renderer.gl;
  const camera = new Camera(gl);
  const scene = new Transform();
  return { gl, renderer, camera, scene };
}


=== FILE END: src/lib/webgl.js ===



=== FILE START: src/lib/main/events.js ===


export function addEvents () {

    this.main.events = {
      startscroll: new Event('startscroll'),
      stopscroll: new Event('stopscroll'),
      scrollto : new Event('scrollto',
      { bubbles: true, detail: { id: '' }}),
  
      // animshow : new CustomEvent('animshow',
      // {
      //   detail: 
      //   { el: '',
      //     param: 0 
      //   }
      // }),
      // animhide : new CustomEvent('animhide',
      // {  
      //     detail: 
      //     { el: '',
      //       param: 0 
      //     }
      // }),
      // animcreate : new CustomEvent('animcreate',
      // {  
      //     detail: 
      //     { el: '',
      //       param: 0 
      //     }
      // }),
      anim:new CustomEvent('anim',
      {
        detail: 
        { el: '',
          state:0,
          style:0,
          params: [0] 
        }
      }),
      nextprj:new CustomEvent('nextprj',
      {
        detail: 
        { el: '',
          url: '' 
        }
      }),
      newlinks : new Event('newlinks'),
      openmenu : new Event('openmenu'),
      closemenu : new Event('closemenu'),
    }
  
    document.addEventListener('startscroll',(e)=>{
      this.controlScroll(1)
    })
    document.addEventListener('stopscroll',(e)=>{
      this.controlScroll(0)
    })
    document.addEventListener('newlinks',(e)=>{
      
      this.addLinks()
    })
    document.addEventListener('scrollto',(e)=>{
      
      this.lenis.scrollTo('#'+e.target.dataset.goto,{offset:-100})
    })
    document.addEventListener('openmenu',(e)=>{
      this.controlScroll(0)
    })
    document.addEventListener('closemenu',(e)=>{
      this.controlScroll(1)
    })
    document.addEventListener('nextprj',async (e)=>{
     
  
      this.lenis.stop()
      this.lenis.scrollTo(this.page.DOM.el.querySelector('.project_nxt'),{duration:.3,force:true})
      await window.waiter(300)
  
        this.onChange({
        url:e.detail.url,
        link:e.detail.el
      })
      
      
  
    })
  
  
    document.addEventListener('anim',async (e)=>{
     
      if(e.detail.style == 0){
        if(e.detail.el.classList.contains('nono')){
          return false
        }
        this.writeFn( e.detail.el, e.detail.state)
        
      
      }
      else if(e.detail.style == 1){
        this.lenis.scrollTo(0)
        await window.waiter(600)
        this.controlScroll(0)
        Promise.all([
        this.gl.changeSlides(e.detail.state)
        ]).then(()=>{
          this.controlScroll(1)
        })
  
        
      }
      
  
    })
  
    document.addEventListener('visibilitychange',(e) =>{
      if (this.isload == 1) { 
        return false 
      }
      if(document.visibilityState=='hidden'){
        this.lenis.stop()
        window.cancelAnimationFrame(this.upid)
      }
      else{
        this.lenis.start()
        this.update(performance.now())
      }
    })
  
    window.addEventListener('popstate', (e)=>this.onPopState(e), { passive: true })
    window.onresize = ()=>{
  
      clearTimeout(this.res)
      this.res = setTimeout(this.onResize, 400)
    }
  
  
    // window.addEventListener('mousedown', this.onTouchDown, { passive: true })
    // window.addEventListener('mousemove', this.onTouchMove, { passive: true })
    // window.addEventListener('mouseup', this.onTouchUp, { passive: true })
  
    // window.addEventListener('touchstart', this.onTouchDown, { passive: true })
    // window.addEventListener('touchmove', this.onTouchMove, { passive: true })
    // window.addEventListener('touchend', this.onTouchUp, { passive: true })
  
    
  
    if(this.main.isTouch){
      window.addEventListener("orientationchange", function(event) {
        location.reload()
      })
  
      // window.addEventListener('scroll', this.onScroll, { passive: true })
    }
  }
  
  
  
    // EVENTS
  
    // export function onContextMenu (event) {
    //   event.preventDefault()
    //   event.stopPropagation()
  
    //   return false
    // }
  
  
    export function onResize () {
      
      
      this.main.design.L.total = ( ( this.main.design.L.w / window.innerWidth ) * 10 )
      this.main.design.L.total = 10 - ((10 - this.main.design.L.total) * this.main.design.L.multi)
      this.main.design.L.total = Math.min(10,this.main.design.L.total)
  
      //MULTI PARA EL WIDE
      // this.main.design.L.wide = ((window.innerHeight*10)/window.innerWidth).toFixed(2)
      // this.main.design.L.total *=  Math.min(1,(this.main.design.L.wide/this.main.design.L.ratio)*1.05)
      
  
  
      this.main.design.P.total = ( ( this.main.design.P.w / window.innerWidth ) * 10 )
      this.main.design.P.total = 10 - ((10 - this.main.design.P.total) * this.main.design.P.multi)
      this.main.design.P.total = Math.min(10,this.main.design.P.total)
  
  
  
      document.documentElement.style.setProperty("--ck_multiL", this.main.design.L.total)
      document.documentElement.style.setProperty("--ck_multiP", this.main.design.P.total)
  
      if (this.main.isTouch){
        document.documentElement.style.setProperty("--ck_hscr", window.screen.height+'px')
        document.documentElement.style.setProperty("--ck_hmin", document.documentElement.clientHeight+'px')
        gsap.to(document.documentElement,{"--ck_hvar":window.innerHeight+"px",duration:.4})
        var isTouch = /Android|iPhone|iPad|iPod|Bla--ckBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1
        if(!isTouch){
          location.reload()
        }
      
      }
      else{
      document.documentElement.style.setProperty("--ck_hscr", window.innerHeight+'px')
      document.documentElement.style.setProperty("--ck_hvar", window.innerHeight+'px')
      document.documentElement.style.setProperty("--ck_hmin", window.innerHeight+'px')
      var isTouch = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1
      
      if(isTouch){
        location.reload()
      }
  
    }
  
      this.main.screen.w = window.innerWidth
      this.main.screen.h = window.innerHeight
      if (this.gl && this.gl.onResize) {
        this.gl.main.screen.w = window.innerWidth
        this.gl.main.screen.h = window.innerHeight
        this.gl.onResize()
      }
      if (this.page) {
        this.page.main.screen.w = window.innerWidth
        this.page.main.screen.h = window.innerHeight
        this.page.onResize()
      }
  
      if(this.mouse){
        this.mouse.main.screen.w = window.innerWidth
        this.mouse.main.screen.h = window.innerHeight
  
      }
  
      if(this.nav){
        this.nav.main.screen.w = window.innerWidth
        this.nav.main.screen.h = window.innerHeight
        this.nav.onResize()
  
      }
  
        
    }
  
    // export function onTouchDown (event) {
    //   event.stopPropagation()
    //   if (this.main.isTouch) return
    //   this.isclick = 1
    //   setTimeout(()=>{
    //     this.isclick = 0
    //   },12)
    //   // this.mouse.position.x = event.touches ? event.touches[0].clientX : event.clientX
    //   // this.mouse.position.y = event.touches ? event.touches[0].clientY : event.clientY
      
    //   // if (event.target.tagName === 'A') return
  
    //   // this.mouse.x = event.touches ? event.touches[0].clientX : event.clientX
    //   // this.mouse.y = event.touches ? event.touches[0].clientY : event.clientY
  
    //   if (this.page && this.page.onTouchDown) {
    //     this.page.onTouchDown(event)
    //   }
  
    // }
  
    // export function onTouchMove (event) {
    //   event.stopPropagation()
      
    //   if (this.main.isTouch) return
    //   if (!this.mouse) return
      
    //   this.mouse.position.x = event.touches ? event.touches[0].clientX : event.clientX
    //   this.mouse.position.y = event.touches ? event.touches[0].clientY : event.clientY
  
  
      
  
    //   if (this.page && this.page.onTouchMove) {
    //     this.page.onTouchMove(event)
    //   }
  
    // }
  
    // export function onTouchUp (event) {
    //   event.stopPropagation()
      
    //   if (this.main.isTouch) return
  
  
    //   if (this.page && this.page.onTouchUp) {
    //     this.page.onTouchUp(event)
    //   }
  
    // }
  
    //Scroll móvil
    // export function onScroll (event) {
      
  
    // }
  
    // export function onWheel (event) {
  
      
    // }
  
  
    // export function startWheel(ev){
    //   this.wheeling = 1
      
      
    //   this.pHide.style.pointerEvents='all'
    //   document.documentElement.classList.add('scroll-is')
      
    // }
  
    // export function stopWheel(){
    //   this.wheeling = 0
    //   this.speed = 0
    //   this.pHide.style.pointerEvents='none'
    //   document.documentElement.classList.remove('scroll-is')
     
    // }
  
    // export function onInteract () {
    //   window.removeEventListener('mousemove', this.onInteract)
    //   window.removeEventListener('touchstart', this.onInteract)
    //   this.update()
    // }
  
    // export function onKeyDown(event){
    //   if(document.querySelector('input:focus')){
    //     return false
    //   }
    //   // if(event.keyCode==40){
    //   //   this.speed += 20
  
    //   // }
    //   // else if(event.keyCode==38){
    //   //   this.speed -= 20
  
    //   // }
     
    // }
  

=== FILE END: src/lib/main/events.js ===



=== FILE START: src/lib/main/index.js ===

import AutoBind from 'auto-bind'
import Lenis from '@studio-freight/lenis'
//Basic
import Nav from '/components🦾🦾🦾/Nav🌤️'
import Loader from '/components🦾🦾🦾/Loader⏳'

import gl from '/gl🌊🌊🌊/gl.js'

//Mouse
import Mouse from '/components🦾🦾🦾/Mouse🐭'


// import home from '/views👁️👁️👁️/⚪Home/home.js?url'
// import enterprise from '/views👁️👁️👁️/🔵Enterprise/enterprise.js?url'
// import ai from '/views👁️👁️👁️/🟢Ai/ai.js?url'
// import news from '/views👁️👁️👁️/📚News/news.js?url'

import {
  createViews


} from './👁️.js'

import {
  onPopState,
  onRequest,
  onChange,
  newView,
  resetLinks


} from './pop.js'

import {
  addEvents,
  // onTouchDown,
  // onTouchMove,
  // onTouchUp,
  // onKeyDown,
  // onWheel,
  // onScroll,
  onResize


} from './events.js'


import {
  writeFn,
  writeCt


} from './anims.js'


class App {
  constructor (info) {
   AutoBind(this)
    this.content = document.querySelector('#content')
    this.main = info[0]
    this.main.base = info[1].fields.base
    this.main.template = info[1].fields.template

    this.main.screen = {
      w:window.innerWidth,
      h:window.innerHeight
    }

    this.FR = 1e3 / 60

    this.speed = 0
    this.wheeling = 0
    this.isclick = 0
    this.searching = 0
    this.isload = 1
    this.scry = 0

    this.resizevar = ''
    this.url = window.location.pathname


    this.initApp(info[1],info[1].texs)
    
  }
  
  async initApp (temps,texs) {
    //Events
    this.addEvents()



    //Lenis
    this.lenis = new Lenis({
      wheelEventsTarget:document.documentElement,
      // lerp:.1,
      // lerp:.06,
      lerp:.04,
      duration:.8,
      smoothWheel:!this.main.isTouch,
      smoothTouch:false,
      normalizeWheel:true,
    })

    this.lenis.stop()

    if(this.main.isTouch == 0){
      this.createScrollBar()
    }


    this.createScrollCheck()
    //Loader
    let time = 1400
    if(import.meta.env.DEV == true){
      time = 1400
    }
    this.template = this.content.dataset.template
    
    this.loader = new Loader(this.main,temps.loader,this.main.device)
      
    await this.loader.create()
    
    this.loader.start()
    
    let firsttemp = undefined
    if(temps.main){
      firsttemp = temps.main
    }
    
    
    //PHIDE
    this.pHide = document.createElement('div')
    this.pHide.className = 'pHide'
    document.querySelector('body').appendChild(this.pHide)

    //Pages
    this.createViews()
    if(this.template.includes('lcl')){
      this.template = this.template.substring(0,this.template.length-3)
    }
    
    //Page
    this.page = this.pages.get(this.template)
    await this.page.create(this.content,this.main,firsttemp)
    
    //Nav
    this.nav = new Nav(this.main)
    this.nav.create(temps.nav)



    //Lets play
    
    this.update()

    await this.timeout(260)
    
    let funcgl = ''
    //GL
    if(this.main.webgl==1){
      this.gl = new gl(this.main)
      funcgl = this.gl.create(texs)
    }


  

    
    // if(import.meta.env.DEV == false){
    // }
    // else{
    //   loadpage = import(this.pages.get(this.template))
    // }

    // this.video = new VideoModal(this.main)
    // this.video.on('start', ()=>this.controlScroll(0))
    // this.video.on('stop', ()=>this.controlScroll(1))

    //Mouse
    if(!this.main.isTouch && typeof Mouse==='function'){
      this.mouse = new Mouse(this.main)
     
    }

    


	  await Promise.all([
      // loadpage,
      // this.pages.get(this.template),
      // waitcanvas,
      funcgl,
      this.timeout(time),
    
    ])

    if(this.gl){
      this.gl.createTemp(this.template)
    }
    this.firstView()
    


  }

  

  async firstView(){
    //Mouse
    if(this.mouse){
      this.mouse.create()
      this.mouse.start()
      this.mouse.reset()
    }
    
    await this.timeout(11)
    await this.loader.hideIntro(this.template)
    if(this.gl){
      this.gl.loader.animstart.play()
    }
    await this.timeout(820)



    if(this.gl){
      this.gl.show()
    }
    

    //State es para diferenciar entre el firstView y un PopState
    this.page.show()
    let state = await this.page.start(0)


    if(this.main.device < 2){

      this.nav.show()
    }
    else{
      this.nav.show()
    }

    this.lenis.start()
    this.addControllers()

    this.isload = 0
  }

  
  
  controlScroll(state){
    if(!this.page){
      return false
    }
    if(state==0){
      this.lenis.stop()
      this.page.stopScroll()
    }
    else{
      this.lenis.start()
      this.page.startScroll()

    }
  }

  update(time) {
    if(this.lenis){
      this.lenis.raf(time)
    }

    if (this.page) {
      this.page.update(this.speed,this.lenis.scroll)
    }
    
    if (this.nav) {
      this.nav.update(time)
    }

    if (this.mouse) {
      this.mouse.update()
    }
    if (this.gl) {
      this.gl.update(time,this.speed,this.lenis.scroll)
    }

    
    gsap.updateRoot(time/ 1000)

    this.upid = window.requestAnimationFrame(this.update)
  }

  timeout(ms){
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  
  
  onPopState () {
    this.onChange({
      url: window.location.pathname,
      push: false
    })
  }

  // Controllers son modales, popstates y demás
  addControllers () {
    if(this.video){
      this.video.resetLinks()
    }
    this.resetLinks()

  }


  

  


  createScrollCheck(){
    if(this.main.isTouch == 0){
      this.scrollFn = ()=>{
        this.speed = this.lenis.velocity
        

        if(this.page){
  
          // this.page.scroll.target = this.lenis.targetScroll
          // this.page.scroll.current = this.lenis.animatedScroll
          // this.page.scroll.last = this.lenis.animatedScroll
          this.page.animIosScroll()
        }

        // this.scrollanim.progress(this.lenis.progress)


        if(Math.abs(this.speed) < 0.3){
          this.pHide.style.pointerEvents = 'none'
        }
        else{
  
          this.pHide.style.pointerEvents = 'all'
        }
        
  
  
        if(this.speed < 0){
          document.documentElement.classList.add('scroll-up')
        }
        else if(this.speed > 0){
          document.documentElement.classList.remove('scroll-up')
  
        }
  
        if(this.lenis.targetScroll == 0){
          document.documentElement.classList.remove('scroll-start')
        }
        else if(this.lenis.targetScroll > 0){
          document.documentElement.classList.add('scroll-start')
  
        }
        
  
        



      }
    }

    else{
      

      this.scrollFn = ()=>{
        this.speed = this.lenis.velocity
        if(Math.abs(this.speed) < 0.01){
          this.pHide.style.pointerEvents = 'none'
        }
        else{
  
          this.pHide.style.pointerEvents = 'all'
        }
        
        if(!this.page){
          return false
        }
  
        if(this.page.scroll.target > this.lenis.targetScroll){
          document.documentElement.classList.add('scroll-up')
        }
        else if(this.page.scroll.target < this.lenis.targetScroll){
          document.documentElement.classList.remove('scroll-up')
  
        }
  
        if(this.lenis.targetScroll == 0){
          document.documentElement.classList.remove('scroll-start')
        }
        else if(this.lenis.targetScroll > 0){
          document.documentElement.classList.add('scroll-start')
  
        }
        
  
        if(this.page){
  
          this.page.scroll.target = this.lenis.targetScroll
          
          this.page.animIosScroll()
        }
      }

    }


    this.lenis.on('scroll',this.scrollFn)
  }

  createScrollBar(){

    // this.scrBar = document.querySelector('.BGscroll')

    // this.scrollanim = new Interpol({
    //   duration:1000,
    //   paused:true,
    //   ease:'power3.easeInOut',
    //   props: {
    //     width: [0, 100,'%'],
    //   },
    //   onUpdate: ({ width }) => {
    //     if(this.scrBar){
    //       this.scrBar.style.width = width
    //     }
    //   },
    
    // })


  }
  
  getRnd(max){
    return Math.floor(Math.random() * max)
  }

  // writeCt(el){
  //   let fakes = '##·$%&/=€|()@+09*+]}{['
  //   let fakeslength = fakes.length - 1

  //   new window.SplitType(el, { types: 'chars,words' })

  //   let splits = el.querySelectorAll('.char')
  //   for(let [i,a] of splits.entries()){


  //   a.innerHTML = '<span class="n">'+a.innerHTML+'</span>'
    
    
  //   let rnd = 0
  //   for ( let u=0;u<3;u++){
  //     rnd = this.getRnd(fakeslength)
  //     a.insertAdjacentHTML('afterbegin','<span class="f">'+fakes[rnd]+'</span>')

  //   }

    
  //   el.style.opacity = 0

    
  // }

  // }
  // writeFn(parnt){
    
    
  //   let splits = parnt.querySelectorAll('.char')


  //   const anim = gsap.timeline({paused:true})

  //   if(parnt.classList.contains('Awrite-inv')){
      
  //     anim.to(parnt,{opacity:1,duration:1.8,immediateRender:false,ease:'power4.inOut'},0)

  //     // anim
  //     // .add({
  //     //   duration:1800,
  //     //   targets:parnt,
  //     //   opacity:1,
  //     //   autoplay: false,
  //     //   easing:(el,i,t)=>{ 
  //     //     return function(t){
  //     //       return window.Power4.inOut(t) 

  //     //     }
  //     //     return t
        
  //     //   }

  //     // },0)
  //   }
  //   else{
  //     anim.set(parnt,{opacity:1},0)

  //     // parnt.style.opacity = 1
  //   }

  //   for(let [i,a] of splits.entries()){
  //     let n = a.querySelector('.n')


  //     anim
  //     .to(n,{opacity:1,duration:.6,immediateRender:false,ease:'power4.inOut'},i*.1)

  //     // anim
  //     // .add({
  //     //   duration:11,
  //     //   targets:n,
  //     //   opacity:0,
  //     //   easing:'linear',
  //     //   autoplay: false,

  //     // },0)
  //     // .add({
  //     //   duration:600,
  //     //   targets:n,
  //     //   opacity:1,
  //     //   autoplay: false,
  //     //   easing:(el,i,t)=>{ 
  //     //     return function(t){
  //     //       return window.Power4.inOut(t) 

  //     //     }
  //     //     return t
        
  //     //   }
  //     //     // easing:'linear'
  //     // },(i*.1) * 1000)




  //     for(let [u,f] of a.querySelectorAll('.f').entries()){
  //       anim
  //       .set(f,{opacity:0},0)
  //       .fromTo(f,{scaleX:1,opacity:1},{scaleX:0,opacity:0,immediateRender:false,duration:.2,ease:'power4.inOut'},((i*.1) + ((1+u)*.03)))

  //       // anim
  //       // .add({
  //       //   duration:1,
  //       //   targets:f,
  //       //   opacity:0,
  //       //   easing:'linear',
  //       //   autoplay: false,

  //       // },0)
  //       // .add({
  //       //   duration:200,
  //       //   targets:f,
  //       //   opacity:[1,0],
  //       //   scaleX:[1,0],

  //       //   easing:(el,i,t)=>{ 
  //       //     return function(t){
  //       //       return window.Power4.inOut(t) 
  
  //       //     }
  //       //     return t
          
  //       //   }

  //       // },((i*.1) + ((1+u)*.03)) * 1000) 
        
        
        


  //       // console.log((i*.1) * 100)
  //       // console.log(((i*.1) + ((1+u)*.03)) * 100)
  //     }
      
  //   }

  //   anim.play()
  // }


}
//Start
App.prototype.createViews = createViews

//Events
App.prototype.addEvents = addEvents
// App.prototype.onTouchDown = onTouchDown
// App.prototype.onTouchMove = onTouchMove
// App.prototype.onTouchUp = onTouchUp
// App.prototype.onKeyDown = onKeyDown
// App.prototype.onWheel = onWheel
// App.prototype.onScroll = onScroll
App.prototype.onResize = onResize

//Pop
App.prototype.onPopState = onPopState
App.prototype.onChange = onChange
App.prototype.onRequest = onRequest
App.prototype.newView = newView

App.prototype.resetLinks = resetLinks

//Anims

App.prototype.writeFn = writeFn
App.prototype.writeCt = writeCt

//Rest



export default App

=== FILE END: src/lib/main/index.js ===



=== FILE START: src/lib/main/anims.js ===

export async function writeFn(parent,state=0){


    if(state == 0 ){
      
      this.writeCt(parent)
      
  
    }
    else if(state == 1){
      let params = [0,3]
      
      if(parent.dataset.params){
        
        params = parent.dataset.params.split(',')
        
        for(let i = 0;i<params.length;i++){
  
          params[i]=parseFloat(params[i])
          
        }
  
      }
  
      if(parent.dataset.clean){
  
        parent.dataset.params=parent.dataset.clean
        delete parent.dataset.clean 
      
      }
      
      
      if(parent.classList.contains('Atext')){
        
        for(let a of parent.querySelectorAll('.line')){
          this.writeFn(a,1)
        }
      }
      else if(parent.classList.contains('Aline')){
        
        let splits = parent.querySelectorAll('.line')
        let anim = gsap.timeline({paused:true,onComplete:()=>{
          parent.classList.add('ivi')
        }})
        anim.set(parent,{opacity:1},0)
       
        for(let [i,a] of splits.entries()){
  
          // anim.set(n,{opacity:0},0)
          // if((i*.04) + .2 > .4){
          //   break
          // }
          anim
          // anim.set(a,{opacity:0},0)
          .fromTo(a,{opacity:0,yPercent:50},{opacity:1,duration:.6,yPercent:0,ease:'power4.inOut'},(i*.1))
          // .to(a,{opacity:1,duration:.6,immediateRender:false,ease:'power4.inOut'},(i*.1))
    
        }
        anim.play()
      }
      else{
  
        let splits = parent.querySelectorAll('.char')
        let anim = gsap.timeline({paused:true,onComplete:()=>{
          parent.classList.add('ivi')
        }})
        if(parent.dataset.bucle){
          if(parent.classList.contains('okF')){
            params[0] = 2
          }
          anim = gsap.timeline({paused:true,onComplete:()=>{
            if(parent.classList.contains('inview')){
  
              this.main.events.anim.detail.state = 1
              this.main.events.anim.detail.el = parent
              document.dispatchEvent(this.main.events.anim)
            }
          }
          })
        }
        if(parent.classList.contains('Awrite-inv') ){
  
          anim.to(parent,{opacity:1,immediateRender:false,ease:'power4.inOut'},params[0])
        }
        else{
  
          anim.set(parent,{opacity:1},0)
  
  
        }
     
  
      // .6 PRIMERO ES APARICIÓN DE LA PALABRA
      // .1 DELAY DE LA APARICIóN DE LA PRIMERA
      // .2 VELOCIDAD DE DESAPARICIÓN de la LETRA
      // .1 DELAY DE LA APARICIóN DE LA PRIMERA?
      // .03 SEPARACIÓN ENTRE LAS LETRAS 
  
      let times = [.3,.05,.16,.05,.016]
  
      // let times = [.6,.1,.2,.1,.03]
      if(parent.classList.contains('line')){
        times = [.3,.05,.16,.05,.016]
      }
      else if(parent.classList.contains('Ms')){
        times = [.22,.05,.16,.05,.016]
  
      }
      anim.set(parent,{opacity:1},0)
      for(let [i,a] of splits.entries()){
        let n = a.querySelector('.n')
  
        anim
        .set(a,{opacity:1},0)
        .to(n,{opacity:1,duration:times[0],immediateRender:false,ease:'power4.inOut'},(i*times[1]) + ( params[0] ))
  
        for(let [u,f] of a.querySelectorAll('.f').entries()){
          
          anim
          .set(f,{opacity:0,display:'block'},0)
          .fromTo(f,{scaleX:1,opacity:1},{scaleX:0,opacity:0,immediateRender:false,duration:times[2],ease:'power4.inOut'},params[0]+((i*times[3]) + ((1+u)*times[4])))
          .set(f,{display:'none'},'>')
  
  
        }
      }
  
        if(params[1]==-1){
          anim.progress(1)
        }
        else{
          anim.play()
        }
      }
    }
  
    else if(state == -1){
  
      gsap.killTweensOf(parent)
      const anim = gsap.timeline({
        paused:true,
        onComplete:()=>{
          
        }
      })
      if(parent.classList.contains('Awrite')){
  
        parent.classList.remove('ivi')
        gsap.killTweensOf(parent)
        let splits = parent.querySelectorAll('.char')
        
    
        splits = [...splits]
    
        splits = splits.reverse()
    
        for(let [i,a] of splits.entries()){
          let n = a.querySelector('.n')
          let f = a.querySelector('.f')
          // anim.set(n,{opacity:0},0)
          // if((i*.04) + .2 > .4){
          //   break
          // }
          anim
          .to(f,{opacity:1,scaleX:1,duration:.12,immediateRender:false,ease:'power4.inOut'},(i*.04))
          .to(a,{opacity:0,duration:.2,immediateRender:false,ease:'power4.inOut'},(i*.04))
    
        }
    
        anim.to(parent,{opacity:0,duration:.4,immediateRender:false,ease:'power4.inOut'},.4)
      }
      else if(parent.classList.contains('Atext') || parent.classList.contains('Aline')){
       
      parent.classList.remove('ivi')
      gsap.killTweensOf(parent)
      let splits = parent.querySelectorAll('.line')
      
  
      splits = [...splits]
  
      splits = splits.reverse()
  
      for(let [i,a] of splits.entries()){
        // anim.set(n,{opacity:0},0)
        // if((i*.04) + .2 > .4){
        //   break
        // }
        anim
        .to(a,{opacity:0,duration:.2,immediateRender:false,ease:'power4.inOut'},(i*.04))
        
      }
  
      anim.to(parent,{opacity:0,duration:.4,immediateRender:false,ease:'power4.inOut'},.4)
  
      }
      else{
        parent.classList.remove('inview')
        parent.classList.remove('stview')
        return false
      }
  
  
      anim.play()
  
    }
  
  
  }
  
  
  export async function writeCt(el,l=2){
    let fakes = '##·$%&/=€|()@+09*+]}{['
    let fakeslength = fakes.length - 1
  
    if(el.classList.contains('Atext')){
      // await window.waiter(66)
      let spty = new window.SplitType(el.querySelectorAll('.Atext_el,p'), { types: 'lines' })
  
      let splits = el.querySelectorAll('.line')
      for(let [i,a] of splits.entries()){
        // a.classList.add('Awrite')
        a.dataset.params = i * .15
       
        this.writeCt(a,0)
  
      }
  
      
    }
    else if(el.classList.contains('Aline')){
      // await window.waiter(66)
      let spty = new window.SplitType(el.querySelectorAll('.Aline_el,p'), { types: 'lines' })
  
      let splits = el.querySelectorAll('.line')
      for(let [i,a] of splits.entries()){
        // a.classList.add('Awrite')
  
      }
  
      
    }
    else{
  
      new window.SplitType(el, { types: 'chars,words' })
  
      let splits = el.querySelectorAll('.char')
      for(let [i,a] of splits.entries()){
        
      a.innerHTML = '<span class="n">'+a.innerHTML+'</span>'
      
      
      let rnd = 0
      for ( let u=0;u<l;u++){
  
        rnd = this.getRnd(fakeslength)
        a.insertAdjacentHTML('afterbegin','<span class="f" aria-hidden="true">'+fakes[rnd]+'</span>')
    
      }
    }
  
  
    
    el.style.opacity = 0
  
    
  }

=== FILE END: src/lib/main/anims.js ===



=== FILE START: src/lib/main/views.js ===


//VIEWS
//🟠🔴🔵🟢🟣🟡⚪⚫🟤
import Home from '/views👁️👁️👁️/⚪Home/home.js'
import Projects from '/views👁️👁️👁️/🔵🔵🔵Projects/projects.js'
import Project from '/views👁️👁️👁️/🔵Project/project.js'
import About from '/views👁️👁️👁️/🟢About/about.js'
import Error from '/views👁️👁️👁️/🚫Error/error.js'
import Playground from '/views👁️👁️👁️/🟡Playground/playground.js'


import '/views👁️👁️👁️/⚪Home/styles.js'
import '/views👁️👁️👁️/🔵🔵🔵Projects/styles.js'
import '/views👁️👁️👁️/🔵Project/styles.js'
import '/views👁️👁️👁️/🟢About/styles.js'
import '/views👁️👁️👁️/🚫Error/styles.js'
import '/views👁️👁️👁️/🟡Playground/styles.js'

// import Uikit from '/views👁️👁️👁️/Uikit⚙️'
// import Project from '/views👁️👁️👁️/Project🟢'
// import Contact from '/views👁️👁️👁️/Contact🔵'


// import Legal from '/views👁️👁️👁️/🔗Legal'

  




export function createViews(){


  this.pages = new Map()
    this.pages.set('home', new Home(this.main))
    this.pages.set('projects', new Projects(this.main))
    this.pages.set('project', new Project(this.main))
    this.pages.set('about', new About(this.main))
    this.pages.set('error', new Error(this.main))
    this.pages.set('playground', new Playground(this.main))



}



=== FILE END: src/lib/main/views.js ===



=== FILE START: src/lib/main/pop.js ===



export function addPop () {

    //window.addEventListener('popstate', this.onPopState, { passive: true })
    
  }
  
  
  
    // EVENTS
  
    // Patrás y palante
  export function onPopState (e) {
    if(this.isload == 1){
      e.preventDefault()
      return false
    }
      this.onChange({
        url: window.location.pathname,
        link:null,
      })
  }
  
  
  
    // Empieza el cambio
  export async function onChange ({ url = null, link = null }) {
      url = url.replace(window.location.origin, '')
      if (this.isload == 1 || this.url === url) return
      this.lenis.stop()
      this.issame = 0
      this.page.isVisible = false
      this.isload = 1
      
      
      
      if(this.mouse){
        this.mouse.clean()
      }
      
      let time = 1200
      
      this.url = url
  
      let functowait = []
      // functowait.push()
      // await this.page.hide()
      
      document.body.style.pointerEvents = 'none'
  
      const request = await window.fetch(url, {
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      })
  
      const response = await request.text()
      var push = true
  
      if(this.gl){
        this.gl.cleanTemp()
      }
      
      let checkout = await this.page.animOut(link,this.lenis)
      
      
      if(Array.isArray(checkout)){
        time = 0
        document.querySelector('body').insertAdjacentHTML('afterbegin','<div class="faketit c-vw nfo"></div>')
        let faketit = document.querySelector('.faketit')
        faketit.appendChild(checkout[0].cloneNode(true))
        faketit.appendChild(checkout[1].cloneNode(true))
        checkout[0].remove()
        checkout[1].remove()
      }
  
      await this.timeout(time)
  
  
        Promise.all([
        this.onRequest({
          push,
          response,
          url
        })
      ]).then(()=>{
        this.newView()
  
      })
  
    }
  
    // llamada de la nueva URL
  export async function onRequest ({ push, response, url }) {
      const html = document.createElement('div')
  
      html.innerHTML = response
      if(html.querySelector('title')){
        document.title = html.querySelector('title').textContent
      }
      this.content = html.querySelector('#content')
      
  
      if (push) {
        window.history.pushState({}, document.title, url)
      }
  
      await this.page.hide()
      this.lenis.scrollTo(0,{immediate:true,lock:true,force:true})
      this.page.DOM.el.remove()
      
      
  
      this.template = this.content.dataset.template
      this.newpage = this.pages.get(this.template)
      this.newpage.id = this.content.dataset.id
  
      this.newpage.ispop = 1
      await this.newpage.create(this.content,this.main,null)
      if(this.gl){
        await this.gl.createTemp(this.template)
      }
      
  }
  
  
  export async function newView(){
      
      
       
      // console.log('estoy aquí')
      // this.loader.hide()
  
      if(this.mouse){
        this.mouse.reset()
      }
  
      
      document.body.style.pointerEvents = ''
      this.isload = 0
      
      this.newpage.show(0)
  
      if(this.canvas){
        this.canvas.show()
      }
  
      this.page = this.newpage
      let state = this.page.start(0)
      if(this.gl){
        this.gl.show()
      }
  
      this.newpage.ispop = 0
      
  
  
      this.addControllers()
      this.lenis.start()
  
  }
  
  
  //CHECKS 
  //1.Onchange
  //2.Pops palante y patrás
  ////3.tener en cuenta menú abierto o modales
  ////4.tener en cuenta transiciones entre vistas del mismo tipo ( de post a post, por ejemplo )
  
  
  
  
  export  function resetLinks(){
    const links = document.querySelectorAll('a')
    
  
    const actual = window.location.href
    for(let link of links){
  
      if(link.classList.contains('Awrite')){
  
        // link.onmouseenter = () => this.writeFn(link)
  
  
        // link.onmouseenter = () => {
        //   this.main.events.animglobal.detail.el = link
        //   document.dispatchEvent(this.main.events.animglobal)
         
        // }
  
        
      }
  
      let isLocal = link.href.indexOf(this.main.base) == 0
      const isAnchor = link.href.indexOf('#') > -1
  
      if(link.dataset.type && !isAnchor){
        if(import.meta.env.DEV){
          isLocal = true
          if(link.dataset.type){
            link.href = '/'+link.dataset.type+'.html'
          }
        }
        link.removeAttribute('data-type')
      }
  
     
      
  
  
      if (isLocal || isAnchor) {
        link.onclick = async(event) => {
          event.preventDefault()
          
          if (!isAnchor) {
            
            this.onChange({
              url: link.href,
              id: link.dataset.id,
              link:link
              
            })
          }
          else{
            
            if(this.nav.isOpen==1){
              this.nav.isOpen = 0
              this.nav.closeMenu()
              await this.timeout(450)
  
  
  
            }
            if(link.href.split('#').length == 2){
              this.lenis.scrollTo('#'+link.href.split('#')[1],{offset:-100})
            }
  
          }
        }
      } else if (link.href.indexOf('mailto') === -1 && link.href.indexOf('tel') === -1) {
        link.rel = 'noopener'
        link.target = '_blank'
      }
      //CLEAN CLASS
      if(actual==link.href){
        link.classList.add('actLink')
        
      }
      else{
        link.classList.remove('actLink')
      }
    }
  }
  

=== FILE END: src/lib/main/pop.js ===

